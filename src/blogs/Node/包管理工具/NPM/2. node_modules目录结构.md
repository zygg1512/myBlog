# node_modules目录结构
假设项目`App`中有如下三个依赖：
```json
"dependencies": {
    "A": "1.0.0",
    "B": "1.0.0",
    "C": "1.0.0"
}
```
A、B、C三个模块又有如下依赖：
```text
A@1.0.0 -> D@1.0.0

B@1.0.0 -> D@2.0.0

C@1.0.0 -> D@1.0.0
```
## npm 2.x - 嵌套结构
`npm 2.x`安装依赖方式比较简单直接，以递归的方式，按照包依赖的树形结构下载填充本地目录结构，也就是说每个包都会将该包的依赖安装到当前包所在的`node_modules`目录中。执行`npm install`后，项目`App`的`node_modules`会变成如下目录结构：
```bash
├── node_modules
│   ├── A@1.0.0
│   │   └── node_modules
│   │   │   └── D@1.0.0
│   ├── B@1.0.0
│   │   └── node_modules
│   │   │   └── D@2.0.0
│   └── C@1.0.0
│   │   └── node_modules
│   │   │   └── D@1.0.0
```
很显然这样的依赖组织结构，有如下优点：
- 层级结构明显
- 简单的实现了多版本兼容
- 保证了对依赖包无论是安装还是删除都会有统一的行为和结构

但是缺点也一样很明显：
- 可能造成相同模块大量冗余问题
- 可能造成目录结构嵌套比较深的问题
## npm 3.x - 扁平结构
`npm 3.x`则采用了扁平化的结构来安装组织`node_modules`也就是在执行`npm install`的时候，按照`package.json`里依赖的顺序依次解析，**遇到新的包就把它安装在第一级目录，后续安装如果遇到一级目录已经存在的包，会先按照约定版本判断版本，如果符合版本约定则忽略，否则会按照`npm 2.x`的方式依次挂在依赖包目录下**假设有如下两个包，都依赖`xxx`：
```bash
├── foo
│   ├── xxx@1.2.1
├── bar
│   └── xxx@1.3.0
```
通过 npm/yarn 扁平化之后他的结构可能是下面两种：
```bash
## 种类一
├── foo
├── xxx@1.2.1
├── bar
│   └── xxx@1.3.0
## 种类二
├── bar
├── xxx@1.3.0
├── foo
│   └── xxx@1.2.1
```
具体顺序取决于`foo`和`bar`在`package.json`中的位置，如果`foo`声明在前面，那么就是前面的结构，否则是后面的结构，也就是说 **npm3.x 存在依赖结构不确定的问题。**

**这也是 lock 文件诞生的原因，无论是`package-lock.json`(npm 5.x才出现)还是`yarn.lock`，都是为了保证 install 之后都产生确定的 node_modules 的目录结构。**
## npm 5.x - package-lock.json
从`npm 5.x`开始，安装`node_modules`和`npm 3.x`一样采用了扁平化的方式。

最大的变化是增加了`package-lock.json`文件。`package-lock.json`的作用是锁定依赖结构，即只要目录下有`package-lock.json`文件，那么每次执行`npm install`后 **生成的`node_modules`目录结构一定是完全相同的**
> **包版本锁定文件保证了`node_modules`的目录结构。**

`npm`为了让开发者在安全的前提下使用最新的依赖包，在`package.json`中通常做了 **锁定大版本** 的操作。这样在每次`npm install`的时候都会拉取依赖包 **大版本下的最新的版本**。
### 缺点
- 当有依赖包有 **小版本更新** 时，可能会出现 **协同开发者的依赖包不一致的问题。**
- 扁平化算法复杂。
- package 非法访问，即项目内可以直接使用依赖包的依赖项。
###`package-lock.json`文件
`package-lock.json`文件精确描述了`node_modules`目录下所有的包的树状依赖结构，每个包的版本号都是完全精确的。以`sass-loader`在`package-lock.json`中为例：
```json
"dependencies": {
  "sass-loader": {
    "version": "7.1.0",
    "resolved": "http://registry.npm.taobao.org/sass-loader/download/sass-loader-7.1.0.tgz",
    "integrity": "sha1-Fv1ROMuLQkv4p1lSihly1yqtBp0=",
    "dev": true,
    "requires": {
      "clone-deep": "^2.0.1",
      "loader-utils": "^1.0.1",
      "lodash.tail": "^4.1.1",
      "neo-async": "^2.5.0",
      "pify": "^3.0.0",
      "semver": "^5.5.0"
    },
    "dependencies": {
      "pify": {
        "version": "3.0.0",
        "resolved": "http://registry.npm.taobao.org/pify/download/pify-3.0.0.tgz",
        "integrity": "sha1-5aSs0sEB/fPZpNB/DbxNtJ3SgXY=",
        "dev": true
      }
    }
  }
}
```
`package-lock.json`的详细描述主要由下面几个字段构成：
-`version`：包唯一的版本号
-`resolved`：安装源
-`integrity`：表明包完整性的`hash`值（验证包是否已失效）
-`dev`：如果依赖项在`devDependencies`中声明，其本身以及子依赖都会被设置为`dev: true`
-`requires`：依赖包中`package.json`文件中的`dependencies`列表，版本号也一致
-`dependencies`：如果根目录`node_modules`中的大版本与依赖包所需大版本不同时，会将依赖包的`dependencies`中的依赖项安装到依赖包的`node_modules`中，而`dependencies`属性就是存储安装在依赖包的`node_modules`中的所有子依赖
   - 这里注意，并不是所有的子依赖都有`dependencies`属性，只有子依赖包的依赖和当前已安装在根目录的`node_modules`中的依赖包冲突之后，才会有这个属性。

`package-lock.json`文件和`node_modules`目录结构是一一对应的，即项目目录下存在`package-lock.json`可以让每次安装生成的 **依赖目录结构保持相同**。
### 使用建议
- 在开发一个应用时，建议把`package-lock.json`文件提交到代码版本仓库。
- 在开发一个库时，则不应把`package-lock.json`文件发布到仓库中。

实际上，`npm`也默认不会把`package-lock.json`文件发布出去。之所以这么做，是因为库项目一般是被其他项目依赖的，在不写死的情况下，就可以复用主项目已经加载过的包，而一旦库依赖的是精确的版本号那么可能会造成包的冗余。
### 关于不同开发者安装依赖导致package-lock.json发生变化的原因
`npm 2.x/3.x`已成为过去式，在`npm 5.x`以上环境下（版本最好在`5.6`以上，因为在`5.0 ~ 5.6`中间对`package-lock.json`的处理逻辑更新过几个版本，`5.6`以上才开始稳定），以`^`版本为例，其他类型版本按版本限制规则参照即可：
#### 在大版本相同的前提下
如果一个模块在`package.json`中的小版本、补丁版本大于`package-lock.json`中的小版本、补丁版本时：
```json
// package.json
"clipboard": "^1.5.12"

// package-lock.json
"clipboard": {
  "version": "1.5.10"
}
```
在执行`npm install`时，会将该模块更新到大版本下的最新的版本，并将版本号更新至`package-lock.json`，且`package.json`中的版本号保持不变。
```json
// 执行完 npm install 后：
// package-lock.json 中 version 更新到大版本下的最新版本，变为 "1.7.1"
// package.json 保持不变，但实际安装的包版本是 "1.7.1"
```
如果小于，则会沿用`package-lock.json`中的版本。
```javascript
// package-lock.json
"vue": {
  "version": "2.6.10",
}
// package.json
"dependencies": {
  "vue": "^2.5.6"
}

// 执行完 npm install 后：
// package-lock.json 中版本没发生改变，依然是 "2.6.10"
// package.json 保持不变，但实际安装的包版本是 "2.6.10"
```
#### 在大版本不同的情况下
在执行`npm install`时，都将根据`package.json`中大版本下的最新版本进行更新，并将版本号更新至`package-lock.json`
```javascript
// package-lock.json
"clipboard": {
  "version": "2.0.4",
}

// package.json
"dependencies": {
  "clipboard": "^1.6.1"
}

// 执行完 npm install 后，package-lock.json 中 
"clipboard": {
  "version": "1.7.1", // 更新到大版本下的最新版本
}
```
#### 在package.json中有记录，而在package-lock.json中无记录
执行`npm install`后，则会在`package-lock.json`生成该模块的详细记录。

同理，一个模块在`package.json`中无记录，而在`package-lock.json`中有记录，执行`npm install`后，会在`package-lock.json`删除该模块的详细记录。
## 依赖包安装原理
从一幅图入手

<img src="https://github.com/zygg1512/myBlog/raw/master/images/Node/依赖包安装流程.jpeg" height="400px" />

- 执行`npm install`
- 检查`.npmrc`文件；优先级为：
   - 项目级的`.npmrc`文件
   - 用户级的`.npmrc`文件
   - 全局级的`.npmrc`文件
   - npm 内置的`.npmrc`文件
- 检查项目中有无`lock`文件
- 无`lock`文件 
   - 从`npm`远程仓库获取包信息
   - 根据`package.json`构建依赖树，构建过程： 
      - 构建依赖树时，不管其是直接依赖还是子依赖的依赖，优先将其放置在`node_modules`根目录。
      - 当遇到相同模块时，判断已放置在依赖树的模块版本是否符合新模块的版本范围，如果符合则跳过，不符合则在当前模块的`node_modules`下放置该模块。
      - 注意这一步只是确定逻辑上的依赖树，**并非真正的安装**，后面会根据这个依赖结构去下载或拿到缓存中的依赖包。
   - 在缓存中依次查找依赖树中的每个包：
     - 存在缓存：将缓存按照依赖结构解压到`node_modules`。
     - 如果不存在缓存：从`npm`远程仓库下载包，并校验包的完整性；如果校验不通过则重新下载；反之将下载的包复制到`npm`缓存目录并按照依赖结构解压到`node_modules`。
   - 此时包已经解压到`node_modules`，并生成`lock`文件。
- 有`lock`文件，检查`package.json`中的依赖版本是否和`package-lock.json`中的依赖有冲突：
   - 如果没有冲突，跳过构建包信息和构建依赖树过程，直接在缓存中查找包信息。然后继续图中流程。
   - 如果有冲突则和上述一致，依次走每个流程。
### 缓存依赖包
在执行`npm install`或`npm update`命令下载依赖后，除了将依赖包安装在`node_modules`目录下外，还会在本地的缓存目录缓存一份。通过`npm config get cache`命令可以查询到：
-`Mac`默认是用户主目录下的`.npm/_cacache`目录。在这个目录下又存在两个目录：`content-v2`、`index-v5`
  -`content-v2`目录用于存储`tar`包的缓存
  -`index-v5`目录用于存储`tar`包的`hash`
```bash
├── .npm
│   ├── _cacache
│   │   ├── content-v2
│   │   └── index-v5
```
npm 在执行安装时，可以根据`package-lock.json`中存储的`integrity、version、name`生成一个唯一的`key`对应到`index-v5`目录下的缓存记录，从而找到`tar`包的`hash`，然后根据`hash`再去找缓存的`tar`包。可以直接使用`npm`提供了几个命令来管理缓存数据：
-`npm cache add`：官方解释说这个命令主要是`npm`内部使用，但是也可以用来手动给一个指定的 package 添加缓存。
-`npm cache clean`：删除缓存目录下的所有数据，为了保证缓存数据的完整性，需要加上`--force`参数。
-`npm cache verify`：验证缓存数据的有效性和完整性，清理垃圾数据。

基于缓存数据，npm 提供了离线安装模式，分别有以下几种：
-`--prefer-offline`：优先使用缓存数据，如果没有匹配的缓存数据，则从远程仓库下载。
-`--prefer-online`：优先使用网络数据，如果网络数据请求失败，再去请求缓存数据，这种模式可以及时获取最新的模块。
-`--offline`：不请求网络，直接使用缓存数据，一旦缓存数据不存在，则安装失败。
### 校验文件完整性
在下载依赖包之前，一般就能拿到`npm`对该依赖包计算的`hash`值，例如执行`npm info`命令，可以看到有一个`shasum`字段，这个字段就是依赖包的`hash`值。

当用户下载依赖包到本地后，需要确定在下载过程中没有出现错误，所以在下载完成之后会在本地再计算一次文件的`hash`值，如果两个`hash`值是相同的，说明下载的依赖是完整的，如果不同，则进行重新下载。
## 总结
- npm2.x：递归下载，会造成包重复下载和结构嵌套太深。
- npm3.x：扁平化，由于按照`package.json`里依赖的顺序依次解析，而在`package.json`通常只会锁定大版本，这意味着在某些依赖包小版本更新后，同样可能造成依赖结构的改动，依赖结构的不确定性可能会给程序带来不可预知的问题。
- npm5.x：新增了`package-lock.json`文件，而安装方式还沿用扁平化的方式。保证`node_modules`目录结构是完全相同。但是当小版本不同时，会出现协同开发者的依赖包不一致的问题。而且还有一个问题就是`package 非法访问`和`扁平化算法复杂`。
