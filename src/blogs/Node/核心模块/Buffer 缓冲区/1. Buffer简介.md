# 前言
JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。

但在处理像 TCP 流或文件流时，必须使用到二进制数据。因此在 Node.js 中，定义了一个 Buffer 类，该类用来创建一个**专门存放二进制数据的缓冲区**。

在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理 I/O 操作中移动的数据时，就有可能使用 Buffer 库。
## bit 与 Byte

1. bit 是我们常说的比特。bit 是二进制的最小信息单位，1 bit 就是我们说的 1 位，64 位操作系统的 CPU 一次能处理![](https://cdn.nlark.com/yuque/__latex/5212463e37406b73b693fe832f7bc8c2.svg#card=math&code=2%5E%7B64%7D&height=16&id=PJrGP)位数据
2. Byte 被翻译为字节，是计量存储或者传输流量的单位。硬盘容量、网速等说的都是字节，一个英文字符是一个字节，也就是我们说的 1B，中文字符通常是两个字节（Node.js 中使用三个字节）
```javascript
1 byte = 8 bit
```
而 Buffer 处理的是字节，比如
```javascript
// 创建一个长度为 8 的 Buffer 实例
const buffer = Buffer.alloc(8)
```
关系如下图

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26943751/1675772499177-4e75649d-f5e9-4e80-befc-1dfd384adff2.png#averageHue=%23fefefe&clientId=u3b0de0b2-3997-4&from=paste&height=603&id=u29a8dbe2&originHeight=1206&originWidth=3482&originalType=binary&ratio=1&rotation=0&showTitle=false&size=208629&status=done&style=none&taskId=uaa960173-1b22-49bd-9560-1c33904d7b4&title=&width=1741)

上图中每一个小块代表一个位，8位组成一个字节。每一个存在间隔的长块表示一个字节，8 个字节组成了创建的 Buffer 对象
## Buffer 特性

- **Buffer的结构和数组很像，操作的方法也和数组类似**
- **数组中不能存储二进制的文件，而 Buffer 就是专门用来存储二进制数据**
- **Buffer 对象实在过于常用，被直接内置到全局变量中，使用时候无需 require 引入**
- **在 Buffer 中存储的都是二进制数据，直接打印Buffer显示的是两位的16进制，打印某一个元素默认显示的是10进制**
   - 在二进制中每个元素最大为8个1，最小为8个0。自然转化为10进制后每个元素范围为0～255
```javascript
const buf = Buffer.alloc(1)
buf[0] = 11111111
console.log(buf) // <Buffer c7>
console.log(buf[0]) // 199
```

- **缓冲区的大小在创建时确定，不能调整**
   - **Buffer 实际上是对底层内存的直接操作**。
   - 即创建 Buffer 的时候实际上是为 Buffer 分配内存连续的空间，如果在运行的时候再添加空间就不一定是连续空间了，这样 Buffer 就不好维护了
- **Buffer 是申请的内存，不受 V8 内存的限制，但是物理内存依然是有限的**
   - Buffer 是 V8 堆内存之外的一块原始内存
   - Buffer 是一个 JavaScript 和 C++ 结合的模块，对象内存不经 V8 分配，而是由 C++ 申请、JavaScript 分配
   - 性能相关部分使用C++实现，将非性能相关的部分用JavaScript实现
### 编码
Buffer 目前支持以下几种编码格式
```bash
ascii | utf8 | utf16le | base64 | binary | hex
```
# Buffer 内存分配原理
Node.js 中采用了 **slab 机制进行预先申请、事后分配。**slab 是一种动态的内存管理机制，它就是一块申请好的固定大小的内存区域，有 3 种状态

- full: 完全分配
- partial: 部分分配
- empty: 没有被分配

这种机制以 8KB（Buffer.poolSize = 8 * 1024） 为界限决定当前分配的对象是大对象还是小对象。
## 内存分配流程

- 在初次加载时就会初始化 1 个 8KB 的内存空间，同时还用偏移量 poolOffset 来记录使用了多少字节
- 根据申请的内存大小分为 小 Buffer 对象 和 大 Buffer 对象
   - 小 Buffer （小于 4KB ）情况，判断这个 slab 剩余空间是否足够容纳
      - 若足够就去使用剩余空间分配，偏移量会增加
      - 若不足，就调用 createPool 方法创建一个新的 slab 空间用来分配
- 大 Buffer （大于 4KB ）情况，直接 createUnsafeBuffer(size) 方法创建
```javascript
const buf1 = Buffer.from('Hello')
console.log(buf1.length) // 5
// buf1的buffer属性会指向其底层的ArrayBuffer对象对应的内存
console.log(buf1.buffer.byteLength) // 8192


const buf2 = Buffer.from('World')
console.log(buf2.length) // 5
console.log(buf2.buffer.byteLength) // 8192


console.log(buf2.buffer === buf1.buffer) // true
```
在上面的例子中，buf1和buf2对象由于长度都比较小所以会直接使用预创建的8KB内存池。其在内存的大概表示如图：

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26943751/1675842554548-09efee2c-c689-47db-aa59-748153efc83c.png#averageHue=%23bac5c5&clientId=u407e3c64-7d42-4&from=paste&height=255&id=u49af6ac7&originHeight=510&originWidth=1570&originalType=binary&ratio=1&rotation=0&showTitle=false&size=50673&status=done&style=none&taskId=u15cb5108-de95-4ab3-930c-06c4f8aa39e&title=&width=785)

只有当需要分配的内存区域小于4KB并且现有的 Buffer 池子还够用的时候，新建的 Buffer 才会直接使用当前的池子，否则 Node 会新建一个新的 8KB 的池子或者直接在内存里面分配一个区域(FastBuffer)。
# Buffer对象的垃圾回收
Node 所有的 Buffer 对象分配的内存区域都是独立于 V8 堆空间的，属于**堆外内存**。那么是否这就意味着 Buffer 对象不受 V8 垃圾回收机制的影响需要我们手动管理内存了呢？

其实不是的，我们每次使用 Node 的 API 创建一个新的 Buffer 对象的时候，每个 Buffer 对象都在 JavaScript 的空间对应着一个对象( Buffer 内存的引用)，这个对象是受 V8 垃圾回收控制的，而 Node 只需要在这个引用被垃圾回收的时候挂一些钩子来释放掉 Buffer 指向的堆外内存就可以了。简单来说 Buffer 分配的空间我们不需要操心，V8 的垃圾回收机制会帮我们回收掉没用的内存。
# Buffer 常用 API

- [创建缓冲区](https://www.yuque.com/zygg/bemfxw/gkb1i2g3zcmc8in6)
- [操作缓冲区](https://www.yuque.com/zygg/bemfxw/kb9egi8vyc57de2k)
- `Buffer.isBuffer(obj)`：判断对象是否为 Buffer
- `Buffer.isEncoding(obj)`：判断 Buffer 对象编码
- `buf.indexOf(string | Buffer | integer)`：和数组的 indexOf 类似，返回某字符串、acsii 码或者某 buffer 实例在该 buffer 实例中的位置
- `buf.buffer`获取 Buffer 的 ArrayBuffer 实例，指向其底层的ArrayBuffer对象对应的内存
- `Buffer.poolSize`表示Node会为我们预创建的Buffer池子有多大，它的默认值是8192，也就是8KB。Node在启动的时候，它会为我们预创建一个8KB大小的内存池，当用户用某些API(例如Buffer.alloc)创建Buffer实例的时候可能会用到这个预创建的内存池以提高效率
# 常见问题
## 中文乱码
在 NodeJS 中一个汉字由三个字节表示，如果某中文字符不是3的倍数的字节数，就会造成字符拼接乱码问题
```javascript
const buf = Buffer.from('中文字符串！')

for(let i = 0; i < buf.length; i += 5){
  var b = Buffer.allocUnsafe(5)
  buf.copy(b, 0, i)
  console.log(b.toString())
}
```
结果如下：

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26943751/1675684099660-4f47e6fd-e639-4487-a19e-fb94dc0c9831.png#averageHue=%23181819&clientId=uc5102c80-43e6-4&from=paste&height=93&id=u712cdf75&originHeight=186&originWidth=264&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13140&status=done&style=none&taskId=u0e0d5e27-c9d8-456e-8b03-8cb8f2ca7a3&title=&width=132)

使用`string_decoder`模块可以解决这个问题
```javascript
const StringDecoder = require('string_decoder').StringDecoder
const decoder = new StringDecoder('utf8')
const buf = Buffer.from('中文字符串！')
for (let i = 0; i < buf.length; i += 5) {
    var b = Buffer.allocUnsafe(5)
    buf.copy(b, 0, i)
  	// 这里
    console.log(decoder.write(b))
}
```
结果如下：

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26943751/1675684229637-e24bdc83-54f5-4158-b08a-132ee7cea3b8.png#averageHue=%23161516&clientId=uc5102c80-43e6-4&from=paste&height=90&id=uf582c667&originHeight=180&originWidth=316&originalType=binary&ratio=1&rotation=0&showTitle=false&size=13309&status=done&style=none&taskId=u1f664746-8c3b-47f3-90b0-66d8717d8ce&title=&width=158)

StringDecoder 在得到编码后会知道宽字节在 utf-8 下占 3 个字节。所以在处理末尾不全的字节时，会保留到第二次`write()`

目前只能处理`UTF-8`、`Base64`、`UCS-2`和`UTF-16LE`
