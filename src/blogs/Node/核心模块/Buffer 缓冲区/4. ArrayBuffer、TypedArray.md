# 二进制数组
- **二进制数组是什么：**用于处理二进制数据的类
- **为什么存在：**javaScript与显卡通信的时候，大量的实时的数据交互，用文本格式需要进行格式转化，二进制则省去转化时间
- **和数组的关系：**Buffer 的实例类似于整数数组，但是 Buffer 的大小是固定不变的
- **怎么创建二进制数组：**通过 ArrayBuffer 或 Buffer 创建
## ArrayBuffer 是什么
ArrayBuffer 对象代表储存二进制数据的一段内存，它不能直接读写，只能通过视图进行操作。“视图”部署了数组接口，这意味着，可以用数组的方法操作内存。<br />ArrayBuffer也是一个构造函数，可以分配一段可以存放数据的连续内存
## 如何使用ArrayBuffer
```javascript
// 生成一个可以12个字节的连续内存，每个字节的默认值是0
const buffer = new ArrayBuffer(12)
```
ArrayBuffer对象还拥有`byteLength`属性和`slice`方法（此方法是ArrayBuffer对象上唯一可以读写内存的方法）
### `byteLength`属性
该属性用于获取二进制数组长度
```javascript
const buffer = new ArrayBuffer(12);
buffer.byteLength; // 12
```
### `slice`方法
截取指定长度的二进制数组，并返回一个新的二进制数组
```javascript
const buffer = new ArrayBuffer(12)
// 用法和数组一致，拷贝 buffer 的前三个字节生成一个新的ArrayBuffer对象
buffer.slice(0, 3)
```
明确了二进制数组和 ArrayBuffer 的使用方式后，接下来需要了解下怎么读取二进制数组。读取二进制数组需要使用**视图**。**视图**会将缓冲区中的数据表示为特定的格式，并通过这些格式来读写缓冲区的内容。
# 视图

- **视图是什么：**ArrayBuffer 对象可以存储多种类型的数据。不同类型的数据有不同的解读方式，这就叫视图
- **视图的作用：**以指定格式解读二进制数据
- **视图种类：**
   - **TypedArray视图：**共包括 9 种类型的视图，每种类型的视图只能把二进制数组解读成同类型的数据
   - DataView视图：可以自定义复合格式的视图
      - 比如第一个字节是 Uint8（无符号 8 位整数）、第二、三个字节是 Int16（16 位整数）、第四个字节开始是 Float32（32 位浮点数）等等，此外还可以自定义字节序

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26943751/1675838274803-1dcf8d0d-15ca-4478-9508-2bcde1aea681.png#averageHue=%23fcfcfc&clientId=u7ed2e8dd-a6c6-4&from=paste&height=524&id=uc4e05d30&originHeight=1092&originWidth=2514&originalType=binary&ratio=1&rotation=0&showTitle=false&size=593881&status=done&style=none&taskId=uaac07ccf-fde6-409f-b070-61c11be7aac&title=&width=1206)
## TypedArray
TypedArray一共包含九种类型，每一种都是一个构造函数。（DataView视图支持除Uint8ClampedArray以外的八种）

| **名称** | **单个元素值的范围** | **占用字节** | **描述** |
| --- | --- | --- | --- |
| Int8Array | -128 到 127 | 1 | 8 位二进制有符号整数 |
| Uint8Array | 0 到 255 | 1 | 8 位无符号整数（超出范围后从另一边界循环） |
| Uint8ClampedArray | 0 到 255 | 1 | 8 位无符号整数（超出范围后为边界值） |
| Int16Array | -32768 到 32767 | 2 | 16 位二进制有符号整数 |
| Uint16Array | 0 到 65535 | 2 | 16 位无符号整数 |
| Int32Array | -2147483648 到 2147483647 | 4 | 32 位二进制有符号整数 |
| Uint32Array | 0 到 4294967295 | 4 | 32 位无符号整数 |
| Float32Array | -3.4E38 到 3.4E38 最小正数为：1.2E-38 | 4 | 32 位 IEEE 浮点数（7 位有效数字，如 1.1234567） |
| Float64Array | -1.8E308 到 1.8E308 最小正数为：5E-324 | 8 | 64 位 IEEE 浮点数（16 有效数字，如 1.123...15) |
| BigInt64Array | -2^63 到 2^63-1 | 8 | 64 位二进制有符号整数 |
| BigUint64Array | 0 到 2^64 - 1 | 8 | 64 位无符号整数 |

### 可接受的参数

- 视图的构造函数接受三个参数
   - 第一个ArrayBuffer对象
      - 接受**ArrayBuffer**实例作为参数，以指定格式读出二进制数据
      - 可接受**普通数组**作为参数，直接分配内存生成 ArrayBuffer 实例，并同时对这段内存进行赋值，再根据这段内存生成视图
      - 可接受**视图**做为参数，生成的新数组复制了参数视图的值，生成新的数组和视图。（想基于同一内存生成新视图，需要传入`视图.buffer`）
   - 第二个视图开始的字节号（默认 0）
   - 第三个视图结束的字节号（默认直到本段内存区域结束）
### 类型介绍
#### Uint8Array
乍一看特别多对吧，其实它们的用法是类似的。这里以 Int8Array 和 Unint8Array 来举一个简单的例子：
```javascript
// 创建8个字节长度的缓冲区
const buffer = new ArrayBuffer(8)

// 将buffer 转化为 Uint8Array
// Uint8Array 中每一个元素表示一个字节（8位）
const uint8Array = new Uint8Array(buffer)

// Uint8Array(8) [0, 0, 0, 0, 0, 0, 0, 0]
console.log(uint8Array)

// 8
console.log(uint8Array.length)
```

- 上述代码首先通过 new ArrayBuffer(8) 创建了 8 个字节大小的缓冲区
- 之后通过 new Uint8Array(buffer) 创建了一个 Unint8Array

用一张图来解释下对应的 Unint8Array 的含义：<br />![](https://cdn.nlark.com/yuque/0/2023/webp/26943751/1675778702392-00477335-ce90-482e-be13-38b3d37a862f.webp#averageHue=%23f6f6f6&clientId=u7ed2e8dd-a6c6-4&from=paste&height=1237&id=ufdde391b&originHeight=1398&originWidth=2192&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=ufb485297-ad7e-4947-8744-c56d6a93421&title=&width=1939)<br />Unint8Array 中每个元素代表 8 位（一个字节）大小，可以通过 Unint8Array 来操控刚才创建的 ArrayBuffer<br />之后打印了，unint8Array 的长度，因为 Buffer 大小为 8 个字节，共计 64 位，所以创建的 unit8Array 大小为 64/8 = 8 个长度<br />Uint8Array 意味无符号整形数组，故而在二进制中每个元素最大为8个1，最小为8个0。自然转化为10进制后每个元素范围为0～255<br />同理 Int8Array 表示有符号的整形数组，每个位首代表正负符号。故而 Int8Array 每个元素大小范围为-128～127
#### Uint16Array
无论是 Uint16Array 、 Uint8Array 还是其他类似 API 本质上用法都是一样的。它们统一被归类为 TypedArray
```javascript
// 创建8个字节长度的缓冲区
const buffer = new ArrayBuffer(8)

// 将 Buffer 转化为 Uint16Array
// Uint16Array 中每一个元素表示两个字节（16位）
const uint8Array = new Uint16Array(buffer)

// Uint16Array(4) [ 0, 0, 0, 0 ]
console.log(uint8Array)

// 64位 8字节 -> 4个元素（打印 4）
console.log(uint8Array.length)
```
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26943751/1675779041081-fac8ccfb-8eb1-4ccf-92d1-1b1ac1785579.png#averageHue=%23f5f5f5&clientId=u7ed2e8dd-a6c6-4&from=paste&height=475&id=u9fc51b36&originHeight=982&originWidth=2578&originalType=binary&ratio=1&rotation=0&showTitle=false&size=195216&status=done&style=none&taskId=u4693cbd2-cfb3-4395-920b-3156bee8cd2&title=&width=1248)<br />同样，Uint16Array 代表 16 位无符号整数，Uint16Array 中每个元素存储 16 位（2个字节）<br />自然，输出它的长度位 4。Int16Array 每个元素存储为有符号 16 位整数，每个元素位首位置表示正负数<br />换算为10进制，Uint16Array 中每个元素大小范围为 0 ～ 2^16 也就是 0 ～ 65536
### Buffer 与 TypedArray

- Buffer继承自 Uint8Array，大部分跟 Unit8Array 一致，其中有一些不同的点比如
   - 构造函数 Buffer() 已经废弃了，要获得一个 Buffer 实例需要用到 Buffer 的静态方法 from
## DataView
### 复合视图
由于视图的构造函数可以指定起始位置和长度，所以在同一段内存之中，可以依次存放不同类型的数据，这叫做“复合视图”<br />如果一段数据包含多种类型的数据，可以使用 TypedArray 的不同类型分别读取
```javascript
const buffer = new ArrayBuffer(12)
const a = new Uint8Array(buffer, 0, 1) // 以Uint8Array读取第一个字节
a[0] = 1
const b = new Int32Array(buffer, 1, 2) // 以Int32Array读取第二个字节
b[0] = 2
```
### DataView 概念
如果一段数据包含多种类型的数据，除了使用复合视图的方式读取之外，还可以使用DataView视图读取。<br />相较于 TypedArray，DataView 对于 ArrayBuffer 的操作更加灵活。<br />我们可以发现在 TypedArray 中操作二进制 ArrayBuffer 时每个元素占用的字节大小是固定的，要么每个元素占用8位、16位或者32位。<br />**而 DataView 对于 ArrayBuffer 的操作就显得更加灵活了，我们可以通过 DataView 从 ArrayBuffer 中自由的读写多种数据类型，从而控制字节顺序。**
### 创建 DataView
```javascript
new DataView(buffer [, byteOffset [, byteLength]])
```
创建 DataView 支持传入三个参数：

- 第一个参数 Buffer 为必填，它支持传入一个 ArrayBuffer 表示 DataView 中的源数据
- 第二个参数 byteOffset 选填，它表示创建 DataView 时从 Buffer 的哪个字节开始，可以作为启始偏移量。未指定时，默认从第一个字节开始
- 第三个参数 btyeLength 选填，它表示创建该 DataView 时的长度，当不传递时表示匹配 Buffer 的长度
```javascript
// 创建8个字节长度的缓存区
const buffer = new ArrayBuffer(8)

// 根据传入的 Buffer 从第一个字节开始，并且字节长度为匹配 Buffer 的长度
const dataView = new DataView(buffer)

/**
 * DataView {
 *     byteLength: 8,
 *     byteOffset: 0,
 *     buffer: ArrayBuffer {
 *         [Uint8Contents]: <00 00 00 00 00 00 00 00>,
 *         byteLength: 8
 *     }
 * }
 */
console.log(dataView)

// 8
console.log(dataView.byteLength)
```
比如上述的代码通过 new DataView 创建了对应 buffer 的 DataView

接下来看看如何利用 DataView 来操作 ArrayBuffer
### 操作 ArrayBuffer
#### setUint8
setUint8() 表示从 DataView 起始位置以字节为计数的指定偏移量(byteOffset)处写入一个8-bit数(无符号字节)<br />setUint8 支持传入两个参数，分别表示：

- 第一参数为 byteOffset，它表示设置的字节偏移量，偏移量单位为字节
- 第二个参数 value，它表示设置的值。为 10 进制表示法
```javascript
// 创建8个字节长度的缓冲区
const buffer = new ArrayBuffer(8)

// 根据传入的 Buffer 从第一个字节开始，并且字节长度为匹配buffer的长度
const dataView = new DataView(buffer)

// 将DataView中偏移量为0个字节的字节，也就是第一个字节设置为十进制的1
dataView.setUint8(0, 1)
// 将DataView中偏移量为1个字节的字节，也就是第二个字节设置为十进制的2
dataView.setUint8(1, 2)
```
代码中通过 setUint8 来操纵创建好的 ArrayBuffer ，当首次创建 ArrayBuffer 时内部所有位全部为空，也就是：<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/26943751/1675780215615-b20546e3-d8c8-4837-9cc2-45d6593e7c1c.png#averageHue=%23f1f1f1&clientId=u7ed2e8dd-a6c6-4&from=paste&height=418&id=u31da7690&originHeight=836&originWidth=2142&originalType=binary&ratio=1&rotation=0&showTitle=false&size=147347&status=done&style=none&taskId=ubfc93937-ff5e-4696-b344-c47e9185339&title=&width=1071)<br />当代码执行到`dataView.setUint8(0, 1)`时，表示将要给 dataView 中设置偏移量为 0 值为 1（10进制）的二进制数据<br />此时，dataView 中的 ArrayBuffer 如下图所示：<br />![](https://cdn.nlark.com/yuque/0/2023/webp/26943751/1675780295636-fdb084e8-1fa7-428e-bc71-2449865bea18.webp#averageHue=%23f4f4f4&clientId=u7ed2e8dd-a6c6-4&from=paste&height=1084&id=u2d08b2b6&originHeight=1084&originWidth=2186&originalType=url&ratio=1&rotation=0&showTitle=false&status=done&style=none&taskId=u66be2726-f2b4-4997-958d-2a8775bd1a7&title=&width=2186)<br />最终将第一个字节(8位)的值变为二进制的 1，将第二个字节变为二进制的 2
#### getUint8
getUint8() 方法从 DataView 相对于起始位置偏移 n 个字节处开始，获取一个无符号的8-bit整数(一个字节)<br />getUint8 的用法和 setUint8 的用法类似，只不过一个是作为获取另一个是作为设置来说的
```javascript
// 创建 8 个字节长度的缓冲区
const buffer = new ArrayBuffer(8)

// 根据传入的 Buffer 从第一个字节开始，并且字节长度为匹配 Buffer 的长度
const dataView = new DataView(buffer)

// 将 DataView 中偏移量为 0 个字节的字节，也就是第一个字节设置为十进制的 1
dataView.setUint8(0, 1)
// 将DataView中偏移量为 1 个字节的字节，也就是第二个字节设置为十进制的 2
dataView.setUint8(1, 2)

// 从dataView 中偏移第 0 个字节，也就是第一个字节，获取 8 位，并输出 10 进制
// 1
dataView.getUint8(0)

// 从 dataView 中偏移第一个字节获取 8 位，也就是获取第二个字节的值，并输出 10 进制
// 2
dataView.getUint8(1)

console.log(dataView.getUint8(0))
console.log(dataView.getUint8(1))
```
#### setUint16 & getUint16
setUint16()从DataView起始位置以字节为计数的指定偏移量(byteOffset)处写入一个16-bit数(无符号短整型)<br />setUint16 和 setUint8 用法是完全一致的，唯一的区别就是 setUint16 设置的是后续 16 位也就是两个字节的值，而 setUint8 设置的仅仅是后续 8 位也就是一个字节的值。同理，getUnit16 和 getUint8 也是同样
```javascript
// 创建 8 个字节长度的缓冲区
const buffer = new ArrayBuffer(8)

// 根据传入的 Buffer 从第一个字节开始，并且字节长度为匹配 Buffer 的长度
const dataView = new DataView(buffer)

// 将DataView中偏移量为 0 个字节的字节，也就是第一个字节设置为十进制的 1
dataView.setUint8(0, 1)
// 将DataView中偏移量为1个字节的字节，也就是第二个字节设置为十进制的 2
dataView.setUint8(1, 2)

// 从 dataView 中偏移第 0 个字节，也就是第一个字节，获取 8 位
// 1
dataView.getUint8(0)

// 从 dataView 中偏移第一个字节获取八位，也就是获取第二个字节的值
// 2
dataView.getUint8(1)

// 偏移量为 0 个字节，获取后续 16 位大小（也就是获取前两个字节大小）
// 258
dataView.getUint16(0)

// 偏移量为 2 个字节，设置后 16 位大小为 256（也就是设置第三个字节和第四个字节大小和为 256）
dataView.setUint16(2, 256)

// 偏移量为 2 个字节，获取后 16 位大小
// 256
dataView.getUint16(2)
```
结合图示来理解上述的代码就会容易许多，相对 int8 来说，int16 与它不同仅仅是 8 位和 16 位的区别<br />![image.png](https://cdn.nlark.com/yuque/0/2023/png/26943751/1675780777158-49ce0fc9-fd0a-431b-bf15-3a8a855f90d6.png#averageHue=%23f1f1f1&clientId=u7ed2e8dd-a6c6-4&from=paste&height=442&id=u5b925740&originHeight=892&originWidth=2090&originalType=binary&ratio=1&rotation=0&showTitle=false&size=165028&status=done&style=none&taskId=u82b86f11-809a-4d3c-8b76-0f347c7f58a&title=&width=1035)
