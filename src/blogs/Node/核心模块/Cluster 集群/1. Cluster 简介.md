# 前言
Node.js默认单进程运行，对于32位系统最高可以使用512MB内存，对于64位最高可以使用1GB内存。对于多核CPU的计算机来说，这样做效率很低，因为只有一个核在运行，其他核都在闲置。cluster模块就是为了解决这个问题而提出的。

- **cluster模块允许设立一个主进程和若干个Worker进程，由主进程监控和协调Worker进程的运行。**
- Worker之间采用**IPC(进程间通信)交换消息**，cluster模块内置一个负载均衡器，采用Round-robin算法协调各个Worker进程之间的负载。
- 运行时，所有新建立的连接都由主进程完成，然后主进程再把TCP连接分配给指定的Worker进程。
# 进程间通信
Master 进程、Worker 通过 IPC（进程间通信）通道进行通信。

主进程可以通过`worker.send`向子进程发送消息，底层使用的是`child_process.send()`，同时可以通过监听`messsage`事件接收子进程消息。

子进程通过`process.send`向主进程发送消息，同时可以通过监听`messsage`事件接收主进程消息。
```javascript
const cluster = require('cluster')
const http = require('http')
const os = require('os')
// 获取 CPU 个数
const countOfCPU = os.cpus().length
if (cluster.isMaster) {
  // 主进程 -> 子进程，方法一
  const worker =  cluster.fork()
  worker.send({ message: 'from Master' })
  
  // 监听子进程消息
  for (const id in cluster.workers) {
    cluster.workers[id].on('message', data => {
      console.log('子进程传过来的消息：', data)
    })
  }
} else {
    // 给主进程发消息
    process.send({ message: 'from message' })
    // 接收主进程消息
    process.on('message', data => {
        console.log('主进程传过来的消息：', data)
    })
}
```
![image.png](https://cdn.nlark.com/yuque/0/2022/png/26943751/1657443557942-9e485ebb-9152-48d7-8af3-b027532b46b7.png#averageHue=%23e9e9e8&clientId=uab134f8e-f1b8-4&from=paste&height=213&id=ub4db9623&originHeight=350&originWidth=810&originalType=binary&ratio=1&rotation=0&showTitle=false&size=140358&status=done&style=none&taskId=u80e1e146-e119-4b85-ad51-058f2d8b0bc&title=&width=493)

**需要注意的是 Worker 之间不共享内存，每个进程都有自己的内存空间**
# 集群模式

- 方案一：一个 Node 实例开启多个端口，通过反向代理服务器向各端口服务进行转发
- 方案二：一个 Node 实例开启多个进程监听同一个端口，通过负载均衡技术分配请求（Master->Worker）

首先第一种方案存在的一个问题是占用多个端口，造成资源浪费，由于多个实例是独立运行的，进程间通信不太好做，好处是稳定性高，各实例之间无影响。

第二个方案多个 Node 进程去监听同一个端口，好处是进程间通信相对简单、减少了端口的资源浪费，但是这个时候就要保证服务进程的稳定性了，特别是对 Master 进程稳定性要求会更高，编码也会复杂。

**在 Nodejs 中自带的 Cluster 模块正是采用的第二种方案。**
# 端口共享
## 为什么共享端口会报错
在操作系统中，不同的进程去共享相同的端口是不允许的。因为在独立启动的多个进程中，每一个进程所创建的TCP Server的文件描述符是不一样的，因此当这些不同的TCP Server的句柄去监听同一个端口时，就会抛出异常。但通过cluster模块就可以实现端口共享
## 句柄传递实现端口共享
Node中包括cluster模块在内，涉及到进程间通信的情形，IPC通道除了发送数据或者文件描述符之外，还可以发送句柄，这个句柄可能指向的是一个服务端或者客户端的socket对象或者一个管道等

举个例子，当主进程与子进程的连接建立之后，主进程会创建一个TCP Server，当主进程监听3000时，主进程会让自身的TCP Server与3000端口绑定，并将TCP Server的句柄传递给子进程，这就相当于子进程接管了TCP Server。并且由于在句柄传递之前，该TCP Server已经与3000端口进行了绑定，因此句柄传递给子进程之后，子进程就绕开了主进程，直接与3000端口进行通信并处理来自该端口的请求

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26943751/1676194782825-7e6a0654-c364-452b-8047-8f813396428f.png#averageHue=%23fcfcfc&clientId=u4d6b1afb-05a6-4&from=paste&height=287&id=u10a07c1a&originHeight=431&originWidth=539&originalType=binary&ratio=2&rotation=0&showTitle=false&size=80638&status=done&style=none&taskId=u28d8d04e-f933-4c83-98ea-7de293a0842&title=&width=359.5)

主进程将TCP Server句柄传递给子进程，因此不论怎么传递，不论是哪个子进程抢到了句柄，该句柄或者说文件描述符始终指向当初主进程所创建的那个TCP Server，那么其句柄在传递过程中仍然保持不变，因此不管是哪个子进程抢到了句柄并接管了对端口的监听，都是相同的句柄去监听端口，所以不会抛出异常。
```javascript
// master.js 
const fork = require('child_process').fork
const cpus = require('os').cpus()
const server = require('net').createServer()
server.listen(3000)
process.title = 'node-master'
for (let i = 0; i < cpus.length; i++) {
    const worker = fork('worker.js')
    // 句柄传递
    worker.send('server', server)
    console.log('worker process created, pid: %s ppid: %s', worker.pid, process.pid)
}
```
```javascript
// worker.js
let worker
process.title = 'node-worker'
process.on('message', function (message, sendHandle) {
  if (message === 'server') {
    worker = sendHandle
    worker.on('connection', function (socket) {
      console.log('I am worker, pid: ' + process.pid + ', ppid: ' + process.ppid)
    })
  }
})
```
验证一番

- 控制台执行 node master.js
- 然后执行 curl http://0.0.0.0:3000
- 输出：`I am worker, pid: xxx, ppid: yyy`
# 子进程的调度策略
当 Worker 进程创建 Server 实例来监听请求，都会通过IPC通道，在 Master 上进行注册。当客户端请求到达，Master 会负责将请求转发给对应的 Worker

请求被 Master 进程转发到 Worker 进程也有两种方法：

- **第一种方法是**`**round-robin**`，简称RR（**除 Windows 外所有平台的默认方法**）
   - 由主进程负责监听端口，接收新连接后再将连接**循环分发**给工作进程，在分发中使用了一些内置技巧防止工作进程任务过载
   - 下文中设置时要用`cluster.SCHED_RR`，如果通过环境变量设置要用`rr`，如果用 cluster 对象获取 schedulingPolicy 数字表示为 2
- **第二种方法是 Shared Socket 的轮询策略**，简称SS
   - 主进程创建监听 socket 后，由操作系统的内核来调度由哪个进程处理请求。理论上第二种方法应该是效率最佳的，但在实际情况下，由于操作系统调度机制的难以捉摸，会使分发变的不稳定
   - 下文中设置时要用`cluster.SCHED_NONE`，如果通过环境变量设置要用`none`，如果用 cluster 对象获取 schedulingPolicy 数字表示为 1
## 调整调度策略
通过`cluster.schedulingPolicy`调整调度策略
```javascript
const cluster = require('cluster');
 
// 策略一：一种轮询的策略，默认值
cluster.schedulingPolicy = cluster.SCHED_RR
 
// 策略二：由操作系统调度的策略
cluster.schedulingPolicy = cluster.SCHED_NONE
 
cluster.fork()
```
通过环境变量设置
```javascript
env NODE_CLUSTER_SCHED_POLICY="none" node app.js // 有效值包括 rr、none
```
## Node为什么选择自己实现 cluster 模块
了解 cluster 的话会知道，子进程是通过 cluster.fork() 创建的。在 linux 中，系统原生提供了 fork 方法，那么为什么 Node 选择自己实现 cluster 模块 ，而不是直接使用系统原生 fork 的方法？主要的原因是以下两点：

- 原生fork方法的进程监听同一端口会导致端口占用错误
- 原生fork方法的进程之间没有负载均衡，容易导致**惊群现象**

在cluster模块中，针对第一个问题，通过判断当前进程是否为 master 进程，若是则监听端口，若不是则表示为 fork 的 worker 进程，不监听端口。

针对第二个问题，cluster模块内置了负载均衡功能， master进程负责监听端口接收请求，然后通过调度算法分配给对应的 worker 进程
### 惊群现象
如今网络编程中经常用到多进程或多线程模型，大概的思路是父进程创建socket，bind、listen后，通过fork创建多个子进程，每个子进程继承了父进程的socket，调用accpet开始监听等待网络连接。这个时候有多个进程同时等待网络的连接事件，当这个事件发生时，这些进程被同时唤醒，就是“惊群”。

**这样会导致什么问题呢？**我们知道进程被唤醒，需要进行内核重新调度，这样每个进程同时去响应这一个事件，而最终只有一个进程能处理事件成功，其他的进程在处理该事件失败后重新休眠或其他。网络模型如下图所示：

![](https://cdn.nlark.com/yuque/0/2023/png/26943751/1676193026509-ca665caa-4618-4f7d-819c-d2044b1a8e78.png#averageHue=%23ede7b3&clientId=u4d6b1afb-05a6-4&from=paste&id=ue927e4c9&originHeight=391&originWidth=604&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=uf305f0e1-a8ed-4d42-b497-86ccdc90a94&title=)

简而言之，**惊群现象（thundering herd）就是当多个进程和线程在同时阻塞等待同一个事件时，如果这个事件发生，会唤醒所有的进程，但最终只可能有一个进程/线程对该事件进行处理，其他进程/线程会在失败后重新休眠，这种性能浪费就是惊群。**
# Node应用的优雅退出
## 暂停、停止服务的场景

- Node 应用发布，新功能上线
- 系统服务紧急下线
- 系统异常，服务没有捕获到错误

当遇到上述问题时，都会导致服务器暂停或停止，但是如果是粗暴退出应用会导致下面这几种问题：

- 旧的请求未处理完，如果服务端进程直接退出，会造成客户端连接中断
- 新请求打过来，服务还没重启完毕，造成 connection refused

最终会导致有一段时间不能给用户提供正常服务，同时粗鲁关闭服务，也可能会对业务依赖的数据库等状态服务造成污染。所以在高可用的Node应用中要避免这种粗暴退出的情况。
## 优雅退出概念
优雅退出（Graceful exit）或适度处理是程序设计概念。

程序出现严重错误时，结果以受控的方式处理，避免产生糟糕的用户体验。应用通常会向终端或日志打印一个退出的错误消息。

**通常情况下，优雅退出会导致一种问题：错误被掩盖，未及时处理。**

这种情况可能会产生更严重的问题，调试起来更加困难。因此一旦出现需要优雅退出的场景，需要做一些额外处理，比如关闭正在打开的连接等，以便现场不会受到污染。而系统彻底崩溃可以让开发人员有机会debug或者收集重要信息。例如核心转储、堆栈跟踪，以诊断错误根本原因。

在支持异常处理的语言中，优雅退出一般是处理异常的最后一步。在其他语言中，可以在可能出现错误的位置使用附加语法来实现优雅退出。
### 优雅退出目标

- 从前端来讲，是给用户一个比较好的体验，避免用户对系统的异常手足无措。
- 从后端来讲，避免在用户请求未处理完前退出，避免系统出现脏数据或者业务逻辑问题。
- 对于负载均衡来讲，可以更好的适配发布系统，让发布更加平滑。

就像处理错误一样，识别到退出的行为，并针对性的进行处理（比如让 HTTP 请求处理完毕后再退出），就可以达到优雅退出的目的。
## 如何优雅处理HTTP请求
对HTTP服务来说，一般的思路就是停止监听端口，确保不会有新的请求进来的情况下处理完已经进入的请求，然后退出。

Node.js 的 HTTP 模块带有一个 close方法，可以在处理完所有请求后停止响应新的连接，并触发回调函数。这个方法来自 NET 模块，因此对于所有类型的 TCP 连接都可以使用这个方法。

**最简单的优雅退出的流程：监听用户的退出信号之后手动关闭HTTP连接。**
### 例子
```javascript
const process = require('process');
const http = require('http');
const server = http.createServer((req, res) => {
    setTimeout(() => {
        res.writeHead(200, { 'Content-Type': 'text/plain' });
        res.end('Hello World');
    }, 4000);
});
server.listen(8080, (err) => {
    console.log('listening <http://localhost:8080/>');
    console.log('pid is ' + process.pid);
});
process.on('SIGTERM', () => {
  // 关闭 http 连接
  server.close(() => {
    // 退出 node 进程
    process.exit(0)
  })
});
```
启动上述代码，并访问`lovalhost:8080`。在服务没返回之前终端执行`kill 【pid】`。当服务停止后前端页面不会报错而是正常返回。如下图

![image.png](https://cdn.nlark.com/yuque/0/2022/png/26943751/1658042926225-368b18c2-33d8-467a-bf08-c4d305b440f9.png#averageHue=%230a0a0a&clientId=u6bedbf4f-b28f-4&from=paste&height=133&id=u3f7735fc&originHeight=266&originWidth=548&originalType=binary&ratio=1&rotation=0&showTitle=false&size=14860&status=done&style=none&taskId=ucd53d175-bca5-474b-b40e-e428a18f0c8&title=&width=274)

当再次请求后才会显示访问失败的页面，下图是再次访问的结果

![image.png](https://cdn.nlark.com/yuque/0/2022/png/26943751/1658042959861-0b3c46a7-2eec-4e15-b995-d6d62e538ab7.png#averageHue=%23191b1d&clientId=u6bedbf4f-b28f-4&from=paste&height=522&id=udc8434fd&originHeight=1044&originWidth=1988&originalType=binary&ratio=1&rotation=0&showTitle=false&size=116093&status=done&style=none&taskId=u67df3d40-6b62-4638-a506-5f11a709979&title=&width=994)
## 集群方式下的优雅退出

- Worker 异常退出后需要 refork
- 监听 Master 退出信号
- Master 退出前 kill 所有 Worker
- Worker 退出前 close server 和 Worker 的子进程
### Worker 异常退出
当 Worker 异常退出时，需要移除当前 Worker 的所有事件监听，并 refork
> **移除当前 Worker 的所有事件监听是为了防止内存泄漏，worker 在异常挂掉后，一定要清理事件绑定**

```javascript
// code <number> 如果其正常退出，则为退出码
// signal <string> 造成进程被终止的信号的名称（例如 'SIGHUP'）
cluster.on('exit', function(worker, code, signal) {
  console.log('Worker ' + worker.process.pid + ' died with code: ' + code + ', and signal: ' + signal)
  // 移除当前 Worker 的所有事件监听
  worker.removeAllListeners()
  console.log('Starting a new worker')
  cluster.fork()
})
```
### 监听 Master 退出信号
```javascript
async function onMasterSignal() {
    const killsCall = Object.keys(cluster.workers).map((id) => {
        const worker = cluster.workers[id];
        const pid = worker.process.pid;
        return process.kill(parseInt(pid, 10), 'SIGTERM');
    });
    await Promise.all(killsCall);
}

// kill(2) Ctrl + C
// kill(3) Ctrl + \
// kill(15) default
['SIGINT', 'SIGQUIT', 'SIGTERM'].forEach((signal) => {
    process.once(signal, onMasterSignal);
});
```
上述代码步骤如下

1. 监听`'SIGINT', 'SIGQUIT', 'SIGTERM'`三个信号
2. `process.once`监听，只需要监听一次
3. `processs.kill`来杀进程。更准确点说是向子进程发送关闭信号

而 Worker 需要监听信号，以便接收 Master 的退出信号
```javascript
process.on('SIGTERM', () => {
    console.log(`Only graceful shutdown, worker ${process.pid}`);
    close();
});

function close() {
    const worker = cluster.worker;
    if (worker) {
        try {
            server.close(() => {
                try {
                    worker.send({ message: 'disconnect' });
                    worker.disconnect();
                } catch (e) {
                    console.error('Error on worker disconnect');
                }
            });
        } catch (e) {
            console.log('error on server close');
        }
    }
}
```

4. Worker 监听 SIGTERM 即可，因为`process.kill`发送 SIGTERM 信号
5. Worker 内使用`net.close()`方法，可以确保 HTTP 连接关闭后不接受新连接
6. `worker.disconnect`让 Worker 不再接收 Master 的连接。当所有连接关闭后，Worker 自己就挂掉了
# PM2
PM2模块是cluster模块的一个包装层。它的作用是尽量将cluster模块抽象掉，让用户像使用单进程一样，部署多进程Node应用。

# 知识拓展
## IPC
IPC (Inter-process communication) 即**进程间通信**，由于每个进程创建之后都有自己的独立地址空间，实现 IPC 的目的就是为了进程之间资源共享访问。

实现 IPC 的方式有多种：管道（pipe）、消息队列、信号量、Domain Socket。在Node中，IPC主要由libuv来实现。libuv是一个事件驱动的I/O库，在Windows中，其底层由命名管道技术实现，在*nix中，其底层由Domain Socket技术实现

![](https://cdn.nlark.com/yuque/0/2023/png/26943751/1676191966833-a7b84e37-7168-4635-b3e2-cde363503680.png#averageHue=%23f6f6f6&clientId=u53de2467-eca5-4&from=paste&height=458&id=u8deabe36&originHeight=618&originWidth=782&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u259a7da4-3263-413a-82a2-1c422e63bc0&title=&width=580)

实际上，父进程在创建子进程之前，会先创建 IPC 通道并监听这个 IPC，然后再创建子进程，通过环境变量（NODE_CHANNEL_FD）告诉子进程和 IPC 通道相关的文件描述符，子进程启动的时候根据文件描述符连接 IPC 通道，从而和父进程建立连接

在主进程与子进程通信时，IPC通道所扮演的角色其实更像是一个中转者，其实质是内存中临时开辟的一段内存空间。当主进程在创建子进程之前，先创建IPC通道，也就是向操作系统申请一段临时的内存空间，然后创建出子进程。随后主进程告诉子进程该IPC通道的文件描述符，可以理解为传给子进程指向这段内存空间的指针，子进程通过该文件描述符同时也去监听该IPC通道。当进程间通信发生消息传递时，主进程往IPC通道，也就是临时开辟的内存空间写入信息，随后子进程再从该段内存中取出信息，完成进程间信息的传递。
## 句柄传递
句柄可以用来标识资源引用，它的内部包含了指向对象的文件资源描述符。

一般情况下，当我们想要将多个进程监听到一个端口下，可能会考虑使用主进程代理的方式处理：

![](https://cdn.nlark.com/yuque/0/2023/png/26943751/1676192096458-aaed9633-af7d-45e7-ab7a-a1795a0d7176.png#averageHue=%23f7f7f7&clientId=u4d6b1afb-05a6-4&from=paste&id=u12a1497e&originHeight=550&originWidth=948&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=ue24395b2-31dc-4e11-aba7-13b09204289&title=)

然而，这种代理方案会导致每次请求的接收和代理转发用掉两个文件描述符，而系统的文件描述符是有限的，这种方式会影响系统的扩展能力。

所以，为什么要使用句柄？原因是在实际应用场景下，建立 IPC 通信后可能会涉及到比较复杂的数据处理场景，句柄可以作为 send() 方法的第二个可选参数传入，也就是说可以直接将资源的标识通过 IPC 传输，避免了上面所说的代理转发造成的文件描述符浪费的情况。

![](https://cdn.nlark.com/yuque/0/2023/png/26943751/1676192096467-a532a5b1-2a13-48ef-af61-5fac1fb3ab44.png#averageHue=%23f9f9f9&clientId=u4d6b1afb-05a6-4&from=paste&id=u68945af2&originHeight=668&originWidth=1172&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u55ace67a-20d8-46e9-b6a6-948ae659cc4&title=)

以下是支持发送的句柄类型：

- net.Socket
- net.Server
- net.Native
- dgram.Socket
- dgram.Native
## 孤儿进程
父进程创建子进程之后，父进程退出了，但是父进程对应的一个或多个子进程还在运行，这些子进程会被系统的 init 进程收养，对应的进程 ppid 为 1，这就是孤儿进程。通过以下代码示例说明。
```javascript
//  worker.js
const http = require('http');
const server = http.createServer((req, res) => {
    // 记录当前工作进程 pid 及父进程 ppid
    res.end('I am worker, pid: ' + process.pid + ', ppid: ' + process.ppid); 
});

let worker;
process.on('message', function (message, sendHandle) {
    if (message === 'server') {
        worker = sendHandle;
        worker.on('connection', function(socket) {
            server.emit('connection', socket);
        });
    }
});
```
```javascript
// master.js
const fork = require('child_process').fork;
const server = require('net').createServer();
server.listen(3000);
const worker = fork('worker.js');

worker.send('server', server);
console.log('worker process created, pid: %s ppid: %s', worker.pid, process.pid);
// 创建子进程之后，主进程退出，此时创建的 worker 进程会成为孤儿进程
process.exit(0); 
```
控制台进行测试，输出当前工作进程 pid 和 父进程 ppid

![](https://cdn.nlark.com/yuque/0/2023/png/26943751/1676192471966-849989c6-6c85-4f6e-aadd-3d49b0bf037e.png#averageHue=%23a7a817&clientId=u4d6b1afb-05a6-4&from=paste&id=u66b8f7af&originHeight=114&originWidth=1678&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=ub6f0c270-5583-4ff0-8edf-6a7575d2abd&title=)

再次验证，打开控制台调用接口，可以看到工作进程 5611 对应的 ppid 为 1（为 init 进程），此时已经成为了孤儿进程

![](https://cdn.nlark.com/yuque/0/2023/png/26943751/1676192490507-d568a0e7-7131-412d-8ebc-9c1d2d401012.png#averageHue=%239e9f1a&clientId=u4d6b1afb-05a6-4&from=paste&id=ub8f6103b&originHeight=93&originWidth=1643&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u3d6a53bb-afac-4846-bb66-5b54d141141&title=)
## 进程的当前工作目录
进程的当前工作目录可以通过 process.cwd() 命令获取，默认为当前启动的目录，如果是创建子进程则继承于父进程的目录，可通过 process.chdir() 命令重置，例如通过 spawn 命令创建的子进程可以指定 cwd 选项设置子进程的工作目录。
```javascript
// 示例
process.chdir('/Users/may/Documents/test/') // 设置当前进程目录
console.log(process.cwd()) // 获取当前进程目录
```
**有什么作用?**

例如，通过 fs 读取文件，如果设置为相对路径则相对于当前进程启动的目录进行查找，所以，启动目录设置有误的情况下将无法得到正确的结果。还有一种情况程序里引用第三方模块也是根据当前进程启动的目录来进行查找的。

