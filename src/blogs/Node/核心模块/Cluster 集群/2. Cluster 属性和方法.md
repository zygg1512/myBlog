# Cluster 属性
## isMaster，isWorker，isPrimary

- `isMaster`属性返回一个布尔值，表示当前进程是否为主进程， Node < 16
- `isPrimary`属性返回一个布尔值，表示当前进程是否为主进程， Node > 16

这个属性由`process.env.NODE_UNIQUE_ID`决定，如果`process.env.NODE_UNIQUE_ID`为未定义，就表示该进程是主进程。

- `isWorker`属性返回一个布尔值，表示当前进程是否为 Worker 进程。它与`isMaster`属性的值正好相反
```javascript
var cluster = require('cluster');
if(cluster.isMaster) {
  // Master 进程 
}else {
  // Worker 进程
}

if(cluster.isWorker) {
  // Worker 进程
}else {
  // Master 进程 
}

```
## cluster.workers
主进程才有的对象，包含了所有 Worker 进程。

- 键名是 Worker进程的`worker.id`
- 键值就是`worker.id`对应的Worker进程对象
```javascript
function eachWorker(callback) {
  for (var id in cluster.workers) {
    callback(cluster.workers[id])
  }
}
eachWorker(function(worker) {
  worker.send('big announcement to all workers')
})
```
> **工作进程在已断开连接并退出后，会从 cluster.workers 中移除。这两个事件之间的顺序不能预先确定。然而，它可以保证在 'disconnect' 或 'exit' 事件触发前从 cluster.workers 列表中除去。**

## cluster.worker
指向当前的工作进程对象，在主进程中不可用。
## cluster.schedulingPolicy
[调度策略](https://www.yuque.com/zygg/bemfxw/xycrl6ge8x9ku2d6#nCCDd)，这是一个全局设置，并且一旦你派生了第一个工作进程或调用了 cluster.setupMaster() 后便不可更改。
```javascript
const cluster = require('cluster');
 
// 策略一：一种轮询的策略，默认值
cluster.schedulingPolicy = cluster.SCHED_RR
 
// 策略二：由操作系统调度的策略
cluster.schedulingPolicy = cluster.SCHED_NONE
 
cluster.fork()

// 同样也可以通过 NODE_CLUSTER_SCHED_POLICY 环境变量进行设置
// 有效值为 "rr" 和 "none"
env NODE_CLUSTER_SCHED_POLICY="none" node app.js
```
## cluster.settings
只读， cluster配置项。在调用setupPrimary()或fork()方法之前，为空对象。调用后此 settings 对象将包含内容，包括默认值

- execArgv {Array} 传递给 Node.js 的可执行字符串参数列表。（默认 = process.execArgv）
- exec {String} 工作进程文件的路径。（默认 = process.argv[1]）
- args {Array} 传递给工作进程的字符串参数。（默认 = process.argv.slice(2)）
- silent {Boolean} 是否将输出发送到父进程的 stdio。（默认 = false）
- uid {Number} 设置进程的用户 id
- gid {Number} 设置进程的组 id
- [其他配置](https://nodejs.org/dist/latest-v19.x/docs/api/cluster.html#clustersettings)
# Cluster 方法
## cluster.setupMaster([settings])

- Node < 16 使用 cluster.setupMaster([settings])
- Node < 16 使用 cluster.setupPrimary([settings])

setupMaster 被用于改变 'fork' 的默认行为。**只能由主进程调用。**

一旦调用，该设置会成为当前的 cluster.settings 中相关的值

- 接受一个settings对象，包含如下属性：
   - exec {String} 工作进程文件的路径（默认 = process.argv[1]）
   - args {Array} 传递给工作进程的字符串参数（默认 = process.argv.slice(2)）
   - silent {Boolean} 是否将输出发送到父进程的 stdio（默认 = false）

注意：

- 任何的设置变更只影响之后调用的`fork()`并且不影响已经运行的工作进程
- settings对象属性的默认值只适用于第一次调用；后续的settings对象属性是当前值
```javascript
const cluster = require('cluster')
cluster.setupMaster({
    exec: 'worker.js',
    args: ['--use', 'https'],
    silent: true
});
cluster.fork() // https worker
cluster.setupMaster({
    exec: 'worker.js',
    args: ['--use', 'http']
})
cluster.fork() // http worker
```
## cluster.fork([env])
`fork`方法用于新建一个 Worker 进程，上下文都复制主进程。只有主进程才能调用这个方法。接受env 对象，用于向工作进程环境中添加键值对。该方法返回一个Worker对象
```javascript
var cluster = require('cluster')
var os = require('os')

if (cluster.isMaster){
  const n =  os.cpus().length
  for (var i = 0, i < n; i++){
    // 创建子进程
    cluster.fork()
  }
}
```
## cluster.disconnect([callback])
该方法接受一个可选的回调参数，会调用每个工作进程中的worker.disconnect()方法。这只能在主进程中调用。

- callback {Function} 当所有的工作进程断开并关闭句柄时调用。

当他们断开所有内部句柄时会被关闭，如果不需要等待其他事件时，可以让主进程优雅地退出。
# cluster监听事件
## ‘setup’ 事件
每次调用 setupMaster() 时都会触发

在调用 setupMaster() 时，cluster.settings 对象就是当时的 settings 对象并且仅供参考，因为可以在单个时钟周期内多次调用 setupMaster()

如果非常注重精度，请使用 cluster.settings
```javascript
cluster.on('setup', (settings) => {
})
```
## ‘fork’ 事件
当派生一个新的工作进程时，cluster会触发一个 'fork' 事件。这可以用来记录工作进程的活动，并创建自己的超时时间。
```javascript
var timeouts = [];
function errorMsg() {
    console.error('Something must be wrong with the connection ...');
}
cluster.on('fork', (worker) => {
    timeouts[worker.id] = setTimeout(errorMsg, 2000);
});
cluster.on('listening', (worker, address) => {
    clearTimeout(timeouts[worker.id]);
});
cluster.on('exit', (worker, code, signal) => {
    clearTimeout(timeouts[worker.id]);
    errorMsg();
});
```
## ‘online’ 事件
当新建一个工作进程后，工作进程响应一个online消息给主进程。当主进程收到online消息后触发这个事件
```javascript
cluster.fork()
cluster.on('online', (worker) => {
  // 工作进程在线
})
```
在派生一个新的工作进程后，该工作进程应该用一个 online 信息作为回应。当主机收到了 online 信息，它会触发此事件

'fork' 和 'online' 的区别是：当主机派生了一个工作进程时，触发 'fork'；当工作进程运行时，触发 'online'
## ‘listening’ 事件
工作进程调用 listen() 后，当服务器上触发 'listening' 事件时，则主进程中的 cluster 也将触发 'listening' 事件。

该事件的回调函数接受两个参数，一个是当前Worker对象，另一个是地址对象，包含

- 网址：address
- 端口： port
- 地址类型：addressType
   - 4（TCPv4）
   - 6（TCPv6）
   - -1（unix domain socket）
   - "udp4" 或 "udp6"（UDP v4 或 v6）

这对于那些服务多个网址的Node应用程序非常有用。
```javascript
cluster.on('listening', function(worker, address) {
  console.log("A worker is now connected to " + address.address + ":" + address.port);
})
```
## ‘message’ 事件
当任何工作进程收到消息时触发。接受两个参数：

- worker 工作进程对象
- message 消息对象
## ‘disconnect’ 事件
在工作进程 IPC 通道断开后触发。它可以在工作进程正常退出、杀死或手动断开（如使用 worker.disconnect()）时发生。

在 'disconnect' 和 'exit' 事件之间可能有延迟。这些事件可以被用于检测进程是否卡在清理或处于长连接状态。
```javascript
cluster.on('disconnect', (worker) => {
  console.log(`The worker #${worker.id} has disconnected`);
});
```
## ‘exit’ 事件
当 Worker 进程退出时，触发此回调
```javascript
// code <number> 如果其正常退出，则为退出码
// signal <string> 造成进程被终止的信号的名称（例如 'SIGHUP'）
cluster.on('exit', function(worker, code, signal) {
  console.log('Worker ' + worker.process.pid + ' died with code: ' + code + ', and signal: ' + signal)
  console.log('Starting a new worker')
  cluster.fork()
})
```
一旦Worker进程挂了，主进程无法知道。所以一般主进程监听到Worker进程的`exit`事件后，就会重启一个Worker进程。Worker进程一旦启动成功，可以正常运行了，就会发出`online`事件
