- `Readable Stream`可读数据流
- `Writeable Stream`可写数据流
- `Duplex Stream`双向数据流，可以同时读和写
- `Transform Stream`转换数据流，可读可写，同时可以转换（处理）数据(不常用)
# 可读流 Readable Streams
可读流是对源头(source)的抽象

所有的 Readable 都实现了`stream.Readable`类定义的接口
```javascript
const stream = require('stream')
const Readable = stream.Readable
```
比如创建读取文件流
```javascript
const fs = require('fs')

const rs = fs.createReadStream('./data.txt', {
  start: 30
})

rs.pipe(process.stdout)
```
## 创建可读流
```javascript
stream.createReadStream(path,[options])
```

- path 读取文件的路径
- options
   - flags 表示打开文件的模式，默认为'r'
   - mode 设置文件的访问模式，默认 0o666
   - autoClose：是否自动关闭文件，默认为 true
   - encoding，默认为 null
      - 可以是 ‘utf8′, ‘ascii', 或 ‘base64′三种格式
      - 读取文件的数据在不指定 encoding 时，默认为 Buffer
   - start 开始读取的索引位置
   - end 结束读取的索引位置(包括结束位置)
   - highWaterMark 读取缓存区默认的大小64kb
      - 一旦开始读取文件，会按照 highWaterMark 的值一次一次读取，直到读完为止
## 读取模式
可读流有两种模式，决定了 chunk 数据的流动方式：自动流动和手工流动

- 流动模式(flowing mode)
- 暂停模式(pause mode)

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26943751/1676693854736-a8e00076-676c-4e05-a536-099b623e040d.png#averageHue=%23bbbbbb&clientId=u75110326-8328-4&from=paste&height=216&id=uc7033b83&originHeight=432&originWidth=1174&originalType=binary&ratio=2&rotation=0&showTitle=false&size=73107&status=done&style=none&taskId=u9f48f4aa-3649-466d-89f9-fc1a0c711ae&title=&width=587)

可以使用热水器模型来模拟数据的流动。热水器(buffer 缓存区)存储着热水(需要的数据)，当我们打开花洒的时候，热水就会从水箱中不断流出来，并且自来水也会不断的流入水箱，这就是流动模式。当我们关闭花洒时，水箱会暂停进水，花洒则会暂停出水，这就是暂停模式。
### 流动模式
流动模式的意思是，一旦开始读取文件，会按照 highWaterMark 的值一次一次读取，直到读完为止，就像一个打开的水龙头，水不断的流出，直到流干，需要通过监听 data 事件触发。

需要注意的是**所有的可读流一开始都处于暂停模式**
#### 举例
假如现在`1.txt`文件中的内容为`0~9`十个数字，我们现在创建可读流并用流动状态读取
```javascript
const fs = require("fs");

let rs = fs.createReadStream("1.txt", {
    start: 0,
    end: 3,
    highWaterMark: 2
});

// 读取文件
rs.on("data", data => {
    console.log(data);
});

// 监听读取结束
rs.on("end", () => {
    console.log("读完了");
});

// <Buffer 30 31>
// <Buffer 32 33>
// 读完了
```
在上面代码中，返回的 rs 对象监听了两个事件：

- data：每次读取 highWaterMark 个字节，触发一次 data 事件，直到读取完成，回调的参数为每次读取的 Buffer；
- end：当读取完成时触发并执行回调函数。

我们希望最后读到的结果是完整的，所以我们需要把每一次读到的结果在 data 事件触发时进行拼接，以前我们可能使用下面这种错误拼接数据的方式
```javascript
const fs = require("fs");

let rs = fs.createReadStream("1.txt", {
    start: 0,
    end: 3,
    highWaterMark: 2
});

let str = "";

rs.on("data", data => {
    str += data;
});

rs.on("end", () => {
    console.log(str);
});

// 0123
```
在上面代码中如果读取的文件内容是中文，每次读取的 highWaterMark 为两个字节，不能组成一个完整的汉字，在每次读取时进行`+=`操作会默认调用 toString 方法，这样会导致最后读取的结果是乱码。

在以后通过流操作文件时，大部分情况下都是在操作 Buffer，所以应该用下面这种方式来获取最后读取到的结果。
```javascript
const fs = require("fs");

let rs = fs.createReadStream("1.txt", {
    start: 0,
    end: 3,
    highWaterMark: 2
});

// 存储每次读取回来的 Buffer
let bufArr = [];

rs.on("data", data => {
    bufArr.push(data);
});

rs.on("end", () => {
    console.log(Buffer.concat(bufArr).toString());
});

// 0123
```
### 暂停模式
在流动模式中，一旦开始读取文件，会不断的触发 data 事件，直到读完，暂停模式是我们每读取一次就直接暂停，不再继续读取，即不再触发 data 事件，除非我们主动控制继续读取，就像水龙头打开放水一次后马上关上水龙头，下次使用时再打开。

类似于开关水龙头的动作，也就是暂停和恢复读取的动作
#### 举例
在下面的场景中我们把创建可读流的结尾位置更改成 9，在每次读两个字节并暂停一秒后恢复读取，直到读完 0~9 十个数字。
```javascript
const fs = require("fs");

let rs = fs.createReadStream("1.txt", {
    start: 0,
    end: 9,
    highWaterMark: 2
});

let bufArr = [];

rs.on("data", data => {
    bufArr.push(data);
  	// 转为暂停模式
    rs.pause(); // 暂停读取
    console.log("暂停", new Date());

    setTimeout(() => {
        rs.resume(); // 恢复读取
    }, 1000)
});

rs.on("end", () => {
    console.log(Buffer.concat(bufArr).toString());
});

// 暂停 2018-07-03T23:52:52.436Z
// 暂停 2018-07-03T23:52:53.439Z
// 暂停 2018-07-03T23:52:54.440Z
// 暂停 2018-07-03T23:52:55.442Z
// 暂停 2018-07-03T23:52:56.443Z
// 0123456789
```
#### readable监听
暂停模式也是流一开始时所处的模式，该模式下会触发 'readable' 事件，readable 事件表明流有新的动态：

- 要么有新的数据，要么流已经读取所有数据

需要不断调用`read()`方法拉取数据，直到返回`null`，表示缓冲区中的数据已被耗尽，在`read()`返回 null 后，会再次触发  'readable' 事件

`stream.read(size)`方法从流缓冲区拉取数据，每次返回指定 size 大小的数据，如果不指定 size 则返回内部所有缓冲的数据
```javascript
const http = require('http');
http.createServer((req, res) => {
  let data = '';
  let chunk;
  req.on('readable', () => {
    chunk = req.read()
    while (chunk !== null) {
      data += chunk.toString();
    }
  })
  req.on('end', () => {
    res.end(data);
  });
}).listen(3000);
```
### 暂停模式切换到流动模式
要切换为流动模式，可通过以下几种方式实现：

1. 注册`data`事件
2. `stream.pipe()`方法
3. `stream.resume`方法
4. 异步迭代
#### 一、注册`data`事件
为可读流对象注册一个 'data' 事件，传入事件处理函数，会把流切换为流动模式，在数据可用时会立即把数据块传送给回调函数
```javascript
req.on('data', chunk => {
  data += chunk.toString()
})
```
如果注释掉`data`事件监听，`end`事件就收不到了，进而永远也不会执行`res.end()`，请求会被一直挂着
#### 二：`stream.pipe()`方法 
调用`stream.pipe`方法将数据发送到可写流
```javascript
readable.pipe(writeable)
```
可读流的`pipe()`方法实现中也是注册了 'data' 事件，一边读取数据一边写入数据至可写流
```javascript
Readable.prototype.pipe = function(dest, options) {
  const src = this;
  src.on('data', ondata);
  function ondata(chunk) {
    const ret = dest.write(chunk);
    if (ret === false) {
      ...
      src.pause();
    }
  }
  ...
};
```
#### 三、`stream.resume`方法
`stream.resume()`将处于暂停模式的可读流，恢复触发 'data' 事件，切换为流动模式

例子：先调用`stream.resume()`用来耗尽流中的数据，但此时没有做任何的数据处理，之后会收到 end 事件
```javascript
const http = require('http');
http.createServer((req, res) => {
  req.resume();
  req.on('end', () => {
    res.end('Ok!');
  });
}).listen(3000);
```
#### 四：异步迭代
无需注册事件监听函数，使用 for...await of 遍历可读流，写法上也很简单
```javascript
// app.mjs
import { createServer as server } from 'http'
import { on } from 'events'
const ee = on(server().listen(3000), 'request')
for await (const [{ url }, res] of ee) {
 res.end('OK!')
}
```
### 流动模式切换到暂停模式

- 移除`data`事件
- 调用`stream.pause`方法
- 调用`stream.unpipe`移除管道目标
### 判断当前所处模式
在 ReadableStream 中有一个`_readableState`对象，对象内有一个`flowing`用来判断流的模式，有三种状态值：

- `ture`：表示为流动模式
- `false`：表示为暂停模式
- `null`：初始状态

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26943751/1676711196937-192d466f-7ada-43da-9610-99673f8babbf.png#averageHue=%232f343c&clientId=u75110326-8328-4&from=paste&height=289&id=QEwPh&originHeight=578&originWidth=1720&originalType=binary&ratio=2&rotation=0&showTitle=false&size=395785&status=done&style=none&taskId=u969c535e-d82f-4f36-bd8f-1752dbcb3a0&title=&width=860)
## 监听
`stream`对象可以监听下面几种类型的事件：

- `data`：有数据流入时触发
   - `stream.on('data', (chunk) => {})`接收一个参数，表示流入的数据
- `end`
- `open`：监听文件的打开，回调函数在打开文件后执行
- `close`：监听文件的关闭，如果创建的可读流的 autoClose 为 true，在自动关闭文件时触发，回调函数在关闭文件后执行
   - **end 事件的触发要早于 close**
- `error`：监听异常

Node 中监听自定义事件使用`on`方法，例如

- `process.stdin.on(‘data’,…)`
- `req.on(‘data’,…)`

通过这种方式，能很直观的监听到`stream`数据的传入和结束
### 错误监听
在通过可读流读取文件时都是异步读取，在异步读取中如果遇到错误也可以通过异步监听到，可读流返回值 rs对象可以通过 error 事件来监听错误，在读取文件出错时触发回调函数，回调函数参数为 err，即错误对象。
```javascript
const fs = require("fs");

// 读取一个不存在的文件
let rs = fs.createReadStream("xxx.js", {
    highWarterMark: 2
});

let bufArr = [];

rs.on("data", data => {
    bufArr.push(data);
});

rs.on("error", err => {
    console.log(err);
});

rs.on("end", () => {
    console.log(Buffer.concat(bufArr).toString());
});

// { Error: ENOENT: no such file or directory, open '......xxx.js' ......}
```
### 打开和关闭文件的监听
流的适用性非常广，不只是文件读写，也可以用在 http 中数据的请求和响应上，但是在针对文件读取返回的 rs 上有两个专有的事件用来监听文件的打开与关闭。

- open 事件用来监听文件的打开，回调函数在打开文件后执行
- close 事件用来监听文件的关闭，如果创建的可读流的 autoClose 为 true，在自动关闭文件时触发，回调函数在关闭文件后执行
```javascript
const fs = require("fs");

let rs = fs.createReadStream("1.txt", {
    start: 0,
    end: 3,
    highWaterMark: 2
});

rs.on("open", () => {
    console.log("open");
});

rs.on("close", () => {
    console.log("close");
});

// open
```
在上面代码我们看出只要创建了可读流就会打开文件触发 open 事件，因为默认为暂停状态，没有对文件进行读取，所以不会关闭文件，即不会触发 close 事件。
```javascript
const fs = require("fs");

let rs = fs.createReadStream("1.txt", {
    start: 0,
    end: 3,
    hithWaterMark: 2
});

rs.on("open", () => {
    console.log("open");
});

rs.on("data", data => {
    console.log(data);
});

rs.on("end", () => {
    console.log("end");
});

rs.on("close", () => {
    console.log("close");
});

// open
// <Buffer 30 31>
// <Buffer 32 33>
// end
// close
```
从上面例子执行的打印结果可以看出只有开始读取文件并读完后，才会关闭文件并触发 close 事件，**end 事件的触发要早于 close**
## 可读流实现原理
所有的 Readable 都实现了 stream.Readable 类定义的接口

只需要实现`_read`方法就能够读取数据，执行流程如下

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26943751/1676719533792-91070a39-6c6b-49ed-9650-218ddd276215.png#averageHue=%23e1e1e1&clientId=u1f82be45-9a7b-4&from=paste&height=510&id=u5a37678d&originHeight=1020&originWidth=2312&originalType=binary&ratio=2&rotation=0&showTitle=false&size=311898&status=done&style=none&taskId=u3702fbdf-52b0-4842-8139-fcd02cd6856&title=&width=1156)

流中维护了一个缓存，当调用 read 方法的时候来判断是否需要向底层请求数据，当缓存区长度为0或者小于 highWaterMark 这个值得时候就会调用`_read`去底层获取数据；反之不会调用`_read`方法
# 可写流 Writeable Stream
可写流 是对数据写入目的地的一种抽象，是用来消费上游流过来的数据，通过可写流把数据写入设备，常见的写入流就是本地磁盘的写入
## 创建可写流
```javascript
stream.createWriteStream(path,[options]);
```

- path 读取文件的路径
- options
   - encoding：字符编码，默认为 utf8；
   - fd：文件描述符，默认为 null；
   - mode：权限位，默认为 0o666；
   - autoClose：是否自动关闭文件，默认为 true；
   - start：写入文件的起始位置；
   - highWaterMark：一个对比写入字节数的标识，默认 16 * 1024

## 可写流常用API
### 通过 write 写入数据
在可写流中将内容写入文件需要使用 ws 的 write 方法，参数为写入的内容

返回值是一个布尔值，代表 highWaterMark 的值是否足够当前的写入，如果足够，返回 true，否则返回 false，换种说法就是写入内容的长度是否超出了 highWaterMark，超出返回 false。
```javascript
const fs = require("fs");
let ws = fs.createWriteSteam("2.txt", {
    start: 0,
    highWaterMark: 3
});
let flag1 = ws.write("1");
console.log(flag1);
let flag2 = ws.write("2");
console.log(flag2);
let flag3 = ws.write("3");
console.log(flag3);
// true
// true
// false
```
写入不存在的文件时会自动创建文件，如果 start 的值不是 0，在写入不存在的文件时默认找不到写入的位置。
### 可写流的 end 方法
通过 end 写数据并且关闭流，end = write + close

end 方法传入的参数为最后写入的内容，end 会将缓存未写入的内容清空写入文件，并关闭文件。
```javascript
const fs = require("fs");

let ws = fs.createWriteStream("2.txt", {
    start: 0,
    highWaterMark: 3
});

let flag1 = ws.write("1");
console.log(flag1);

let flag2 = ws.write("2");
console.log(flag2);

let flag3 = ws.write("3");
console.log(flag3);

ws.on("drain", () => {
    console.log("吸干");
});

ws.end("写完了");

// true
// true
// false
```
在调用 end 方法后，即使再次写入的值超出了 highWaterMark 也不会再触发 drain 事件了，此时打开 2.txt 后发现文件中的内容为 “123写完了”。
#### 常见报错
在调用 end 方法后，不可以再调用 write 方法写入，否则会报一个很常见的错误 write after end，文件原有内容会被清空，而且不会被写入新内容。
```javascript
const fs = require("fs");

let ws = fs.createWriteStream("2.txt", {
    start: 0,
    highWaterMark: 3
});

ws.write("1");
ws.end("写完了");
ws.write("2");

// Error [ERR_STREAM_WRITE_AFTER_END]: write after end...
```
### 可写流的 drain 事件
调用`ws.write(chunk)`返回 false，表示当前缓冲区数据大于或等于 highWaterMark 的值，就会触发 drain 事件，当内容全部从缓存写入文件后，会执行回调函数。
```javascript
const fs = require("fs");

let ws = fs.createWriteStream("2.txt", {
    start: 0,
    highWaterMark: 3
});

let flag1 = ws.write("1");
console.log(flag1);

let flag2 = ws.write("2");
console.log(flag2);

let flag3 = ws.write("3");
console.log(flag3);


ws.on("drain", () => {
    console.log("吸干");
});

// true
// true
// false
```
起到一个警示作用，我们依旧可以写入数据，只是未处理的数据会一直积压在可写流的**内部缓冲区**中，直到积压沾满 Node.js 缓冲区后，才会被强行中断
## 自定义可写流
所有的 Writeable 都实现了 stream.Writeable 类定义的接口

只需要实现`_write`方法就能够将数据写入底层
```javascript
const Writable = require('stream').Writable
class MyWritable extends Writable{
    constructor(){
        super()
    }
    _write(data, enc, next){
        process.stdout.write(data.toString().toUpperCase())
        // 写入完成时，调用 next 方法通知流传入下一个数据
        next()
    }
}

const writable = new MyWritable()

// 将一个数据写入流中
writable.write('f')
writable.write('b')
writable.write('b' + '\n')

// 数据写入完成后，需调用 end 方法
writable.end()

// 在end方法调用后，当所有底层的写操作均完成时，会触发finish事件
writable.on('finish', () => process.stdout.write('DONE'))

// 执行后控制台输出：
// FBB
// DONE
```

- 通过调用`writable.write`方法将数据写入流中，会调用`_write`方法将数据写入底层
- 当`_write`数据成功后，需要调用`next`方法去处理下一个数据
- **必须**调用`writable.end(data)`来结束可写流，`data`是可选的。此后，不能再调用`write`新增数据，否则会报错
- 在`end`方法调用后，当所有底层的写操作均完成时，会触发`finish`事件
# 双工流 Duplex Stream
双工流，既可读，也可写。实际上继承了 Readable 和 Writable 的一种流，那它既可以当做可读流来用又可以当做可写流来用

自定义的双工流需要实现 Readable 的 _read 方法和 Writable 的 _write 方法
```javascript
const Duplex = require('stream').Duplex
class MyDuplex extends Duplex {
    constructor(){
        super()
        this.readNum = 0
    }
    _read(){
        this._readNum = this._readNum || 0
        if(this._readNum > 2) {
            this.push(null)
        }else {
            this.push('' + this._readNum++)
        }
    }
    _write(buf, enc, next){
        process.stdout.write('write data ' + buf.toString() + '\n')
        next()
    }
}

const duplex = new MyDuplex()

duplex.on('data', chunk => {
    process.stdout.write('read data ' + chunk.toString() + '\n')
})

duplex.write('F')
duplex.write('B')
duplex.write('B')

duplex.end()

// 打印
// write data F
// write data B
// write data B
// read data 0
// read data 1
// read data 2
```
net 模块可以用来创建 socket，socket 在 NodeJS 中是一个典型的 Duplex，看一个 TCP 客户端的例子
```javascript
const net = require('net');
// 创建客户端
const client = net.connect({ prot: 1234 }, function(){
    console.log('已链接服务器')
    client.write('Hi')
});

// data 事件监听，收到数据后断开连接
client.on('data', (data) => {
    console.log(data.toString())
    client.end()
})
client.on('end', () => {
    console.log('连接已断开')
})
```
client 就是一个 Duplex，可写流用于向服务器发送消息，可读流用于接受服务器消息，两个流内的数据并没有直接的关系
# 转换流 Transform Stream
上述的例子中，可读流中的数据(0/1)和可写流中的数据(’F’,’B’,’B’)是隔离的，两者并没有产生关系，但对于 Transform 来说在可写端写入的数据经过变换后会自动添加到可读端

Transform 继承于 Duplex，并且已经实现了 _write 和 _read 方法，只需要实现 _tranform 方法即可
```javascript
const Transform = require('stream').Transform;

class MyTransform extends Transform {
    constructor() {
        super();
    }
    _transform(data, enc, next) {
        const res = '123'+ data.toString();
        console.log('写入的内容是：', res)
        this.push(res);
        next();
    }
}

const transform = new MyTransform();

process.stdin
    .pipe(transform).on('data', chunk => {
        console.log('data事件：', chunk.toString())
    })
// 执行代码
// 输入：ABCDEF
// 回车
// 打印：写入的内容是： 123ABCDEF
// 打印：data事件： 123ABCDEF

// 输入：456   
// 回车
// 打印：写入的内容是： 123456
// 打印：data事件： 123456
```
gulp 基于 Stream 的自动化构建工具，看一段官网的示例代码

![](https://cdn.nlark.com/yuque/0/2023/webp/26943751/1676717432709-30f601f0-81c4-4cac-a2e3-4df638252856.webp#averageHue=%2331353d&clientId=u75110326-8328-4&from=paste&id=u6b1f2d8f&originHeight=392&originWidth=1720&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=ue5759157-30e3-4026-ad7f-d84e514fe7a&title=)

less → less 转为 css → 执行 css 压缩 → 压缩后的 css

其实 less() 和 minifyCss() 都是对输入的数据做了一些处理，然后交给了输出数据
## Duplex 和 Transform 的选择
和上面的示例对比起来，我们发现一个流同时面向生产者和消费者服务的时候我们会选择 Duplex，当只是对数据做一些转换工作的时候我们便会选择使用 Tranform


