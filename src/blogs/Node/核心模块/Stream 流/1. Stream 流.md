# Stream 定义
流（Stream）是一个抽象的数据接口，是EventEmitter对象的一个实例

总之它是会冒数据（以 Buffer 为单位），或者能够吸收数据的东西，它的本质就是让数据流动起来。 可能看一张图会更直观：

![image.png](https://cdn.nlark.com/yuque/0/2023/png/26943751/1676690284637-183b42b4-0516-46e1-8070-e71c588b95db.png#averageHue=%23fbfbfb&clientId=u5f14786e-e1bf-4&from=paste&height=196&id=u3fb5df91&originHeight=556&originWidth=1242&originalType=binary&ratio=2&rotation=0&showTitle=false&size=58138&status=done&style=none&taskId=ude0ea507-70be-4e5c-bcf3-efca1491eff&title=&width=438)

流不是 Node 中独有的概念，是操作系统最基本的操作方式，在 Linux 中 | 就是 Stream，只是 Node 层面对其做了封装，提供了对应的 API
```bash
# 筛选当前目录下的 js 文件
$ ls | grep *.js
```
使用 `|` 连接两条命令，把前一个命令的结果作为后一个命令的参数传入，这样数据像是水流在管道中传递，每个命令类似一个处理器，对数据做一些加工，因此 `|` 被称为“管道符”，这个处理过程就是流
## 常见的 Stream 对象

- 标准输入`process.stdin`
- 标准输出`process.stdout`
- `http`请求中的`response`和`resquest`
   - `request`是 source，是图中的源头
   - `response`是 dest，是图中的目的地
```javascript
const http = require('http')
// req 和 res 都是 Stream 对象
const server = http.createServer(function (req, res) {})
server.listen(8000)
```
# 为什么要使用 Stream
## 视频播放
比如在线看电影，`source`就是服务器端的视频，`dest`就是播放器。看电影的方式就如同上图管道换水一样，一点点从服务端将视频流动到本地播放器，一边流动一边播放，最后流动完了也就播放完了。

视频播放的这个例子，如果不使用管道和流动的方式，直接先从服务端加载完视频文件，然后再播放。会造成很多问题

1. 因内存占有太多而导致系统卡顿或者崩溃
2. 因为网速、内存、cpu运算速度都是有限的，而且还要有多个程序共享使用，一个视频文件加载完可能有几个g那么大
## 大文件读取
假设有一个400M大文件需要读取
### 使用 readFile 读取
```javascript
const http = require('http');
const fs = require('fs');
const path = require('path');

const server = http.createServer(function (req, res) {
    const fileName = path.resolve(__dirname, 'data.txt');
    fs.readFile(fileName, function (err, data) {
        res.end(data);
    });
});
server.listen(8000);
```
使用`curl http://127.0.0.1:8000`发起请求时，内存变为了 420MB 左右，和文件大小差不多

在响应大量用户并发请求的时候，程序可能会消耗大量的内存，这样可能造成用户连接缓慢的问题。而且并发请求过大的话，服务器内存开销也会很大
### 使用 Stream 读取
```javascript
const http = require('http');
const fs = require('fs');
const path = require('path');

const server = http.createServer(function (req, res) {
    const fileName = path.resolve(__dirname, 'data.txt');
    const stream = fs.createReadStream(fileName);  // 这一行有改动
    stream.pipe(res); // 这一行有改动
});
server.listen(8000);
```
使用 Stream 就可以不需要把文件全部读取了再返回，而是一边读取一边返回，数据通过管道流动给客户端，真的减轻了服务器的压力

再次发起请求时，发现内存只占用了 35MB 左右，相比 readFile 大幅减少
# 数据的流转过程
![image.png](https://cdn.nlark.com/yuque/0/2023/png/26943751/1676691543140-2ff96f21-27b2-468a-8c1c-873666d10396.png#averageHue=%23fbfbfb&clientId=u5f14786e-e1bf-4&from=paste&height=185&id=u3e72f4fd&originHeight=556&originWidth=1242&originalType=binary&ratio=2&rotation=0&showTitle=false&size=58138&status=done&style=none&taskId=uc543d855-4663-4dd5-a6e1-53ca2626e3e&title=&width=413)

图中可以看出，stream 整个流转过程包括`source`、`dest`以及连接二者的管道`pipe`
## 数据从哪里来—source
stream的常见来源方式有三种：

1. 从控制台输入`process.stdin`
2. `http`请求中的`request`
3. 读取文件`createReadStream`
### 从控制台输入
```javascript
// 运行代码，从控制台输入任何内容都会被 data 事件监听到
process.stdin.on('data', function (chunk) {
    console.log('stream by stdin', chunk)
    console.log('stream by stdin', chunk.toString())
})
//控制台输入koalakoala后输出结果
// stream by stdin <Buffer 6b 6f 61 6c 61 6b 6f 61 6c 61 0a>
// stream by stdin koalakoala
```
`process.stdin`就是一个`stream`对象，`data`是`stream`对象用来监听数据传入的一个自定义函数，通过输出结果可看出`process.stdin`是一个`stream`对象
### `http`请求中的`request`
```javascript
const http = require('http');
const fs = require('fs');
const path = require('path');

const server = http.createServer(function (req, res) {
    const method = req.method; // 获取请求方法
    if (method === 'GET') { // get 请求
        const fileName = path.resolve(__dirname, 'data.txt');
        let stream = fs.createReadStream(fileName);
        stream.pipe(res); // 将 res 作为 stream 的 dest
    }
});
server.listen(8000);
```
### 读取文件`createReadStream`
比如文件拷贝
```javascript
const fs = require('fs')
const path = require('path')

// 两个文件名
const fileName1 = path.resolve(__dirname, 'data.txt')
const fileName2 = path.resolve(__dirname, 'data-bak.txt')
// 读取文件的 stream 对象
const readStream = fs.createReadStream(fileName1)
// 写入文件的 stream 对象
const writeStream = fs.createWriteStream(fileName2)
// 通过 pipe执行拷贝，数据流转
readStream.pipe(writeStream)
// 数据读取完成监听，即拷贝完成
readStream.on('end', function () {
    console.log('拷贝完成')
})
```
## 连接的管道—pipe
在 source 和 dest 中有一个连接的管道 pipe，基本语法为`source.pipe(dest)` 

source 和 dest 通过 pipe 连接，让数据从 source 流向 dest

pipe 使用时有严格的要求，source 必须是一个可读流，dest 必须是一个可写流
## 到哪里去—dest
stream的常见输出方式有三种：

1. 输出控制台`process.stdout`
2. `http`请求中的`response`
3. 写入文件`createWriteStream`
### 输出控制台
标准输出`process.stdout`
```javascript
process.stdin.pipe(process.stdout)
```
# Stream弊端

- 用`rs.pipe(ws)`的方式来写文件并不是把 rs 的内容 append 到 ws 后面，而是直接用 rs 的内容覆盖 ws 原有的内容
- 已结束/关闭的流不能重复使用，必须重新创建数据流
- `pipe`方法返回的是目标数据流，如`a.pipe(b)`返回的是`b`，因此监听事件的时候请注意你监听的对象是否正确
- 如果你要监听多个数据流，同时你又使用了`pipe`方法来串联数据流的话，你就要写成：
```javascript
data.on('end', function () {
    console.log('data end');
})
    .pipe(a)
    .on('end', function () {
        console.log('a end');
    })
    .pipe(b)
    .on('end', function () {
        console.log('b end');
    });
```
# 背压问题
## 什么是背压问题
背压问题来源于生产者消费者模式中，消费者处理速度过慢

比如说，我们下载过程，处理速度为3Mb/s，而压缩过程，处理速度为1Mb/s，这样的话，很快缓冲区队列就会形成堆积

要么导致整个过程内存消耗增加，要么导致整个缓冲区慢，部分数据丢失

![](https://cdn.nlark.com/yuque/0/2023/webp/26943751/1676717676679-4a2b93e7-0e72-4ecf-b121-3e51dfc8fda8.webp#averageHue=%23f9f9f9&clientId=u6db92a13-cc88-4&from=paste&id=u836b27fc&originHeight=462&originWidth=1622&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u2f442eea-0964-4b41-a50e-325575988ee&title=)
## 什么是背压处理
背压处理可以理解为一个向上”喊话”的过程

当压缩处理发现自己的缓冲区数据挤压超过阈值的时候，就对下载处理“喊话”，我忙不过来了，不要再发了

下载处理收到消息就暂停向下发送数据

![](https://cdn.nlark.com/yuque/0/2023/webp/26943751/1676717676696-08c8816b-3ee1-4971-81d5-b2fc9aecec29.webp#averageHue=%23f8f8f8&clientId=u6db92a13-cc88-4&from=paste&id=u06a5f946&originHeight=472&originWidth=1740&originalType=url&ratio=2&rotation=0&showTitle=false&status=done&style=none&taskId=u748d4e5e-f7b9-4a6b-b8a8-627b440f9ce&title=)
## 如何处理背压
**pipe 的背压处理：**

- 将数据按照chunk进行划分，写入
- 当chunk过大，或者队列忙碌时，暂停读取
- 当队列为空时，继续读取数据

当`pipe()`被源头调用之后，它通知消费者有数据需要传输。管道函数为事件触发建立了合适的积压封装，在数据缓存超出了`highWaterMark`或者写入的列队处于繁忙状态，`write()`会返回`false`。当`false`返回之后，积压系统介入了。它将暂停数据流进入。一旦数据流清空了，`drain`事件将被触发。一旦队列全部处理完毕，积压机制将允许数据再次发送。在使用中的内存空间将自我释放，同时准备接收下一次的批量数据

