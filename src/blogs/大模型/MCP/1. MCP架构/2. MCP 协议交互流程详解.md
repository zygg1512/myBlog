# MCP 协议交互流程详解

## 阶段一：初次连接与握手 (Handshake)

这是所有交互的起点。Client 和 Server 必须互相交换“名片”，确认对方支持哪些协议版本和功能特性。

### 1、Client 发送初始化请求

Client 启动后，首先发送`initialize`请求。注意`capabilities`字段，Client 在这里声明自己的身份和支持的能力。

```json
// Client -> Server
{
    "jsonrpc": "2.0",
    "id": 1,
    "method": "initialize",
    "params": {
        // [必填] 客户端当前使用的 MCP 协议版本
        "protocolVersion": "2025-11-25",

        // [必填] 客户端信息描述
        "clientInfo": {
            "name": "Claude Desktop", // 客户端名称
            "version": "1.0.0" // 客户端版本号
        },

        // [必填] 客户端能力声明 (ClientCapabilities)
        // 告诉 Server 我支持哪些高级特性，如果为空对象 {} 则表示仅支持基础请求
        "capabilities": {
            // 声明支持“根目录管理”
            // 允许 Server 请求列出或监听 Client 开放的文件系统根目录
            "roots": {
                "listChanged": true // 如果为 true，表示当根目录列表发生变化时，Client 会主动通知 Server
            },

            // 声明支持“采样 (Sampling)”
            // 允许 Server 反向请求 Client 使用 LLM 处理复杂的推理任务
            "sampling": {},

            // [可选] 声明支持“实验性功能”
            "experimental": {
                // key-value 结构，用于非标准协议扩展
                "customFeature": true
            }
        }
    }
}
```

### 2、Server 返回初始化结果

Server 确认协议版本，并回传它所提供的三大核心能力：Resources, Tools, Prompts。

```json
// Server -> Client
{
    "jsonrpc": "2.0",
    "id": 1,
    "result": {
        // [必填] 双方协商确认使用的协议版本
        "protocolVersion": "2025-11-25",

        // [必填] 服务端信息描述
        "serverInfo": {
            "name": "my-complex-server", // 服务端名称
            "version": "2.1.0" // 服务端版本号
        },

        // [可选] 给 Client/User 的展示性指令，通常用于引导用户如何配置
        "instructions": "请确保已在环境变量中配置 API_KEY",

        // [必填] 服务端能力声明 (ServerCapabilities)
        "capabilities": {
            // 1. 日志能力：Server 可以向 Client 控制台发送日志
            "logging": {},

            // 2. 资源能力：Server 提供类似文件的只读数据
            "resources": {
                "subscribe": true, // 是否支持 Client 订阅资源更新
                "listChanged": true // 资源列表变化时是否发送通知
            },

            // 3. 工具能力：Server 提供可执行函数
            "tools": {
                "listChanged": true // 工具列表变化时是否发送通知
            },

            // 4. 提示词能力：Server 提供预设 Prompt 模板
            "prompts": {
                "listChanged": true // 提示词列表变化时是否发送通知
            }
        }
    }
}
```

### 3、Client 发送初始化完成通知

Client 收到 Server 的回应后，发送一个没有 ID 的通知消息，标志着握手结束。此时双方可以开始发送实际的业务请求。

```json
// Client -> Server
{
    "jsonrpc": "2.0",
    "method": "notifications/initialized",
    "params": {} // 该通知通常没有额外的参数，保留为空对象
}
```

## 阶段二：能力发现与使用 (Client 调用 Server)

握手完成后，Client 通常会立即查询 Server 到底提供了哪些具体的功能。

### 场景 A： 发现并调用工具 (Tools)

#### A.1 获取工具列表

```json
// Client -> Server
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "tools/list",
  "params": {
    // [可选] 分页游标。如果工具列表很长，Server 会分批返回。
    // 初次请求不带 cursor，后续请求带上 Server 返回的 nextCursor
    "cursor": "eyJ..."
  }
}

// Server -> Client (Response)
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    // [必填] 工具定义列表
    "tools": [
      {
        "name": "calculate_sum", // [必填] 工具唯一标识符
        "description": "计算两个数字的和", // [可选] 给 LLM 看的工具描述

        // [必填] 输入参数的 JSON Schema 定义
        // 必须严格符合 JSON Schema Draft 7 标准
        "inputSchema": {
          "type": "object",
          "properties": {
            "a": {
              "type": "number",
              "description": "第一个加数"
            },
            "b": {
              "type": "number",
              "description": "第二个加数"
            }
          },
          "required": ["a", "b"] // 必填字段列表
        }
      }
    ],
    // [可选] 如果还有更多数据，返回下一页的游标
    "nextCursor": null
  }
}
```

#### A.2 调用工具

当用户问“100 加 200 等于多少”时，Client 发起调用：

```json
// Client -> Server
{
  "jsonrpc": "2.0",
  "id": 3,
  "method": "tools/call",
  "params": {
    "name": "calculate_sum", // [必填] 要调用的工具名称

    // [必填] 传递给工具的参数，必须符合 inputSchema
    "arguments": {
      "a": 100,
      "b": 200
    },

    // [可选] 元数据，用于传递额外的非功能性信息
    "_meta": {
      "progressToken": "tx-123" // 用于进度报告的 Token
    }
  }
}

// Server -> Client (Response)
{
  "jsonrpc": "2.0",
  "id": 3,
  "result": {
    // [必填] 工具执行结果的内容列表
    // 这是一个数组，可以包含文本、图像或资源引用
    "content": [
      {
        "type": "text", // 内容类型：text | image | resource
        "text": "300"   // 具体的文本结果
      }
      // 如果有图片结果：
      // { "type": "image", "data": "base64...", "mimeType": "image/png" }
    ],

    // [可选] 标记执行是否出错。如果为 true，LLM 会知道工具调用失败了。
    // 注意：即使 isError 为 true，也可以返回 content 来解释错误原因。
    "isError": false
  }
}
```

### 场景 B: 发现并读取资源 (Resources)

#### B.1 获取静态资源列表

Client 请求`resources/list`来发现有哪些可用的资源。Host 通常会根据这个列表在 UI 上显示“可附加资源”的菜单。

```json
// Client -> Server
{
  "jsonrpc": "2.0",
  "id": 4,
  "method": "resources/list",
  "params": {
    // [可选] 分页游标
    "cursor": null
  }
}

// Server -> Client (Response)
{
  "jsonrpc": "2.0",
  "id": 4,
  "result": {
    // [必填] 资源列表
    "resources": [
      {
        "uri": "file:///logs/system.log", // [必填] 资源的唯一标识符
        "name": "System Logs",            // [必填] 人类可读的名称
        "description": "最新的系统运行日志", // [可选] 描述
        "mimeType": "text/plain",         // [可选] MIME 类型，提示 Client 如何渲染，建议必填

        // [可选] 资源大小（字节），用于进度条显示
        "size": 1024
      },
      {
        "uri": "postgres://db/users/schema",
        "name": "Users Table Schema",
        "mimeType": "application/json"
      }
    ],
    // [可选] 下一页游标
    "nextCursor": null
  }
}
```

在 MCP 协议规范中，`resources/list`或`resources/read`返回的 Resource 对象中，mimeType 字段是可选的（Optional），协议本身没有规定一个强制的“默认值”。但是，在实际开发和交互中，如果 Server 不提供`mimeType`，Client（如 Claude Desktop）通常会采取以下兜底策略：

1. 根据 URI 后缀推断：Client 会尝试解析 uri 字段的扩展名（例如`.json`,`.png`,`.py`）来猜测 MIME 类型。
2. 默认为纯文本：如果无法推断，且内容是`text`字段返回的，Client 通常会默认将其视为`text/plain`进行展示。
3. 二进制数据风险：如果返回的是`blob`(二进制) 且没有提供`mimeType`，Client 可能无法正确渲染图片或文件，可能会显示为乱码或“未知文件”。

最佳实践建议： 为了确保 Host 能正确渲染数据（特别是图片、JSON 或特定格式的代码文件），强烈建议显式提供`mimeType`。例如：

-   纯文本日志：`"mimeType": "text/plain"`
-   Python 代码：`"mimeType": "text/x-python"`
-   JSON 数据：`"mimeType": "application/json"`
-   PNG 图片：`"mimeType": "image/png"`

#### B.2 获取动态资源列表

当 Server 管理大量数据（如数据库 ID 或动态路径）时，它不可能把几百万条记录都通过`resources/list`列出来。

相反，它会提供一个 URI 模板（如`postgres://users/{id}`），让 Client 根据需要动态构造 URI 来读取数据。

```json
// Client -> Server
{
  "jsonrpc": "2.0",
  "id": 6,
  "method": "resources/templates/list", // 请求列出资源模板
  "params": {
    "cursor": null
  }
}

// Server -> Client (Response)
{
  "jsonrpc": "2.0",
  "id": 6,
  "result": {
    "resourceTemplates": [
      {
        // [必填] URI 模板，遵循 RFC 6570 标准
        // {userId} 是一个变量，Client 可以根据上下文填充它
        "uriTemplate": "postgres://db/users/{userId}/profile",

        // [必填] 模板名称
        "name": "User Profile",

        // [可选] 模板描述
        "description": "根据用户 ID 获取用户画像信息",

        // [可选] 返回的数据类型
        "mimeType": "application/json"
      }
    ]
  }
}
```

使用方式： Client（或 LLM）通过补全模板构造出一个具体的 URI（例如`postgres://db/users/123/profile`），然后使用标准的`resources/read`接口读取该 URI。

#### B.3 读取资源

用户想要查看某个文件的内容。

```json
// Client -> Server
{
  "jsonrpc": "2.0",
  "id": 4,
  "method": "resources/read",
  "params": {
    "uri": "file:///logs/system.log" // [必填] 资源的唯一 URI
  }
}

// Server -> Client
{
  "jsonrpc": "2.0",
  "id": 4,
  "result": {
    // [必填] 返回的内容列表（一个 URI 可能对应多个内容块）
    "contents": [
      {
        "uri": "file:///logs/system.log", // 对应请求的 URI
        "mimeType": "text/plain",       // MIME 类型

        // 文本内容使用 "text" 字段
        "text": "[INFO] System started successfully.\n[WARN] Low memory."

        // 如果是二进制文件（如图片），则使用 "blob" 字段
        // "blob": "base64_encoded_string..."
      }
    ]
  }
}
```

### 场景 C: 发现并读取提示词模板 (Prompts)

#### C.1 获取提示词列表

Client 请求`prompts/list`来获取 Server 提供的所有 Prompt 模板。Host 通常会将其显示为`/slash-command`菜单。

```json
// Client -> Server
{
  "jsonrpc": "2.0",
  "id": 6,
  "method": "prompts/list",
  "params": {
    // [可选] 分页游标
    "cursor": null
  }
}

// Server -> Client (Response)
{
  "jsonrpc": "2.0",
  "id": 6,
  "result": {
    // [必填] 提示词列表
    "prompts": [
      {
        "name": "git_commit_helper", // [必填] 提示词内部名称（用于调用）
        "description": "生成符合规范的 Git 提交信息", // [可选] 描述

        // [可选] 该提示词需要的参数列表
        "arguments": [
          {
            "name": "branch",       // [必填] 参数名
            "description": "分支名", // [可选] 参数描述
            "required": true        // [可选] 是否必填，默认为 false
          }
        ]
      },
      {
        "name": "explain_code",
        "description": "解释选中的代码片段"
      }
    ],
    "nextCursor": null
  }
}
```

#### C.2 获取提示词内容

用户点击界面上的 “Git Commit 助手” 按钮。

```json
// Client -> Server
{
  "jsonrpc": "2.0",
  "id": 5,
  "method": "prompts/get",
  "params": {
    "name": "git_commit_helper", // [必填] Prompt 名称

    // [可选] 传递给 Prompt 模板的参数
    "arguments": {
      "branch": "main"
    }
  }
}

// Server -> Client
{
  "jsonrpc": "2.0",
  "id": 5,
  "result": {
    // [可选] Prompt 的详细描述
    "description": "生成符合规范的 Git 提交信息",

    // [必填] 预设的消息列表，Client 会将这些消息直接填入对话框
    "messages": [
      {
        "role": "user", // 角色：user | assistant
        "content": {
          "type": "text",
          "text": "请根据以下的 git diff 内容生成 commit message：\n..." // Server 动态填充的内容
        }
      }
    ]
  }
}
```

## 阶段三：反向能力调用 (Server 调用 Client)

这是 MCP 的强大之处。Server 不仅仅是被动响应者，它也可以主动向 Client 请求数据或能力。

### 场景 A: Sampling (Server 使用 Client 的 LLM)

情景： Server 抓取了一段复杂的 Python 代码，它自己没有能力分析，于是请求 Client（Host）的 LLM 进行总结。

```json
// Server -> Client (Server 主动发起请求)
{
  "jsonrpc": "2.0",
  "id": 99,
  "method": "sampling/createMessage",
  "params": {
    // [必填] 发送给 LLM 的上下文消息历史
    "messages": [
      {
        "role": "user",
        "content": {
          "type": "text",
          "text": "请简要总结这段代码的功能：def foo(x): return x * 2"
        }
      }
    ],

    // [可选] 系统提示词，用于设定 AI 人设
    "systemPrompt": "你是一个代码专家，请用简洁的语言回答。",

    // [可选] 是否包含 Host 当前的上下文（如用户选中的文件）
    // includeContext 允许 Server 请求 Client 将当前的上下文信息（如 IDE 中打开的文件）也一起发给 LLM
    "includeContext": "none", // none | thisServer | allServers

    // [可选] 模型推理参数
    "temperature": 0.7,      // 随机性 (0.0 - 1.0)
    "maxTokens": 100,        // 最大生成长度
    "stopSequences": ["\n"], // 停止词列表

    // [可选] 模型偏好设置
    "modelPreferences": {
        "hints": [
            { "name": "claude-3-5-sonnet" }, // 优先建议使用的模型
            { "name": "claude-3-opus" }
        ],
        "costPriority": 0.5, // 成本优先权重 (0-1)
        "speedPriority": 0.5 // 速度优先权重 (0-1)
    }
  }
}

// Client -> Server (Host 调用 LLM 后返回结果)
{
  "jsonrpc": "2.0",
  "id": 99,
  "result": {
    // [必填] 生成的角色
    "role": "assistant",

    // [必填] 生成的内容
    "content": {
      "type": "text",
      "text": "这段代码定义了一个函数 foo，它接收一个参数 x 并返回其两倍的值。"
    },

    // [必填] 实际使用的模型名称
    "model": "claude-3-5-sonnet-20240620",

    // [可选] 停止原因
    "stopReason": "end_turn" // end_turn | max_tokens | stop_sequence
  }
}
```

### 场景 B: Roots (Server 询问文件权限)

情景： Server 想要新建一个文件，但不知道用户允许它访问哪些目录。它需要询问 Client 的 roots 列表。

```json
// Server -> Client
{
  "jsonrpc": "2.0",
  "id": 100,
  "method": "roots/list",
  "params": {} // 无参数
}

// Client -> Server
{
  "jsonrpc": "2.0",
  "id": 100,
  "result": {
    // [必填] 根目录列表
    "roots": [
      {
        "uri": "file:///Users/username/project", // [必填] 目录 URI
        "name": "My Project"                     // [可选] 显示名称
      }
    ]
  }
}
```

## 阶段四：动态通知 (Notifications)

### 场景 A: Server 通知 Client (资源/工具变更)

当后台数据发生变化时，Server 可以主动通知 Client，而不需要 Client 轮询。

```json
// Server -> Client (无 ID 的通知)
{
    "jsonrpc": "2.0",
    "method": "notifications/resources/list_changed",
    "params": {} // 资源列表已变更，Client 应重新调用 resources/list
}
// 类似的还有：
// notifications/tools/list_changed
// notifications/prompts/list_changed
// notifications/message (用于发送日志)
```

后续动作： Client 收到这个通知后，通常会重新发起 resources/list 请求，以刷新界面上的资源列表。

### 场景 B: Client 通知 Server (根目录变更)

情景： 用户在 Client 端（比如 VS Code 或 Cursor）打开了新的文件夹或关闭了现有文件夹，Client 会发送通知给 Server。

```json
// Client -> Server (无 ID 的通知)
{
    "jsonrpc": "2.0",
    "method": "notifications/roots/list_changed",
    "params": {}
}
```

后续动作： Server 收到这个通知后，应该重新发起 roots/list (参见 第三阶段-场景 B) 请求，以获取最新的允许访问目录列表，从而更新其内部的索引或权限缓存。
