# Resources

资源是MCP服务器提供给AI客户端的数据或内容，AI可以读取这些资源来获取信息，但通常不能修改。资源系统支持静态和动态内容，通过URI进行标识和访问。

参考：[Resources](https://modelcontextprotocol.io/specification/2025-11-25/server/resources)

## 资源注册

静态资源具有固定的URI和内容，适合提供配置信息、文档等不变的数据。

可以通过`registerResource`方法注册一个静态资源，供客户端访问。

```typescript
// 静态资源（固定URI）
registerResource(
    name: string,
    uriOrTemplate: string,
    config: ResourceMetadata,
    readCallback: ReadResourceCallback
): RegisteredResource;

// 动态资源（URI模板）
registerResource(
    name: string,
    uriOrTemplate: ResourceTemplate,
    config: ResourceMetadata,
    readCallback: ReadResourceTemplateCallback
): RegisteredResourceTemplate;
```

**参数**

| 参数名          | 类型                                      | 必填 | 描述                                                                 |
| --------------- | ----------------------------------------- | ---- | -------------------------------------------------------------------- |
| `name`          | `string`                                  | 是   | 资源名称，必须唯一的字符串标识符                                     |
| `uriOrTemplate` | `string \| ResourceTemplate`              | 是   | 资源URI（静态资源）或URI模板（动态资源）                             |
| `config`        | `ResourceMetadata`                        | 是   | 资源配置元数据对象                                                   |
| `readCallback`  | `ReadResourceCallback \| ReadResourceTemplateCallback` | 是   | 资源读取回调函数，根据资源类型选择对应的回调类型                     |

**config (ResourceMetadata) 详细字段：**

`ResourceMetadata` 类型是 `Omit<Resource, 'uri' | 'name'>`，包含以下可选字段：

| 字段名        | 类型               | 必填 | 描述                                                                 |
| ------------- | ------------------ | ---- | -------------------------------------------------------------------- |
| `title`       | `string`           | 否   | 资源显示标题，用于UI展示                                             |
| `icons`       | `Icon[]`           | 否   | 可选图标数组，用于UI展示                                             |
| `description` | `string`           | 否   | 资源功能的详细描述                                                   |
| `mimeType`    | `string`           | 否   | 资源的MIME类型，如 'application/json', 'text/markdown'               |
| `annotations` | `Annotations`      | 否   | 可选注解信息，可用于分类、标签、缓存提示等（任意对象，可自由定义）   |
| `size`        | `number`           | 否   | 资源大小（字节）                                                     |
| `_meta`       | `object`           | 否   | 自定义元数据信息（任意对象，可自由定义）                             |

> **注意：** `annotations` 和 `_meta` 字段是任意对象，可以包含任何自定义数据。上述表格中的示例仅供参考，实际使用时可以根据需要自由定义字段。

**annotations作用**：提供结构化语义提示，帮助客户端理解资源用途。使用通用`Annotations`接口，包含`audience`（目标受众：'user'/'assistant'）、`priority`（优先级：0-1）、`lastModified`（最后修改时间戳）字段。这些是协议定义的字段，客户端应该理解并据此调整资源显示和访问逻辑。

**_meta作用**：灵活元数据字段，用于存储任意自定义数据。类型为`Record<string, unknown>`，可以包含版本信息、作者、分类标签、文档链接等。这些数据不参与协议语义，客户端不保证理解或使用。

**readCallback 回调函数类型：**

根据资源类型，需要使用不同的回调函数：

**1. ReadResourceCallback（静态资源）**
```typescript
type ReadResourceCallback = (
    uri: URL,
    extra: RequestHandlerExtra<ServerRequest, ServerNotification>
) => ReadResourceResult | Promise<ReadResourceResult>;
```

**2. ReadResourceTemplateCallback（动态资源）**
```typescript
type ReadResourceTemplateCallback = (
    uri: URL,
    variables: Variables,
    extra: RequestHandlerExtra<ServerRequest, ServerNotification>
) => ReadResourceResult | Promise<ReadResourceResult>;
```

> **注意：** `extra` 参数包含请求处理相关的额外信息，如会话ID、认证信息等。动态资源的回调函数还会接收 `variables` 参数，包含URI模板中提取的变量值。

**ReadResourceResult 字段详解：**

`ReadResourceResult` 是资源读取请求的返回结果类型。

| 字段名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
| `contents` | `(TextResourceContents \| BlobResourceContents)[]` | 是 | 资源内容数组，包含一个或多个资源内容对象 |
| `_meta` | `object` | 否 | 自定义元数据信息 |

**ResourceContents 基类字段：**
所有资源内容类型都继承自 `ResourceContents` 基类，包含以下字段：

| 字段名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
| `uri` | `string` | 是 | 资源URI地址 |
| `mimeType` | `string` | 否 | 资源的MIME类型 |
| `_meta` | `object` | 否 | 资源特定的元数据 |

**TextResourceContents 字段：**
用于文本内容，继承自 `ResourceContents`：

| 字段名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
| `text` | `string` | 是 | 资源的文本内容，必须是有效的UTF-8字符串 |

**BlobResourceContents 字段：**
用于二进制内容，继承自 `ResourceContents`：

| 字段名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
| `blob` | `string` | 是 | Base64编码的二进制数据字符串 |

**使用注意事项：**
1. `TextResourceContents` 只能用于纯文本内容，不能包含二进制数据
2. `BlobResourceContents` 必须使用Base64编码，用于图片、PDF、音频等二进制资源
3. `contents` 数组可以包含多个资源内容，支持分片或分层资源表示

**示例**

```typescript
server.registerResource(
    'advanced-resource',
    'data://advanced/info',
    {
        title: '高级资源',
        description: '具有丰富元数据的资源示例',
        mimeType: 'application/json',
        annotations: {
            category: 'data',
            tags: ['system', 'monitoring'],
            readOnlyHint: true,
            cacheable: true,
            sensitive: false
        },
        _meta: {
            version: '1.2.0',
            author: 'System Administrator',
            documentation: 'https://docs.example.com/resources/advanced',
            examples: [
                {
                    title: '基础查询',
                    uri: 'data://advanced/info',
                    description: '获取基础系统信息'
                }
            ],
            performance: {
                averageResponseTime: '50ms',
                cacheTimeout: '5m',
                updateFrequency: 'real-time'
            },
            dependencies: ['os', 'process'],
            changelog: [
                { version: '1.2.0', changes: ['添加了内存使用详情', '优化了响应时间'] },
                { version: '1.1.0', changes: ['添加了CPU使用率', '改进了数据格式'] }
            ]
        }
    },
    async uri => {
        return {
            contents: [
                {
                    uri: uri.toString(),
                    mimeType: 'application/json',
                    text: JSON.stringify(
                        {
                            system: {
                                platform: os.platform(),
                                arch: os.arch(),
                                release: os.release(),
                                hostname: os.hostname()
                            },
                            process: {
                                pid: process.pid,
                                version: process.version,
                                uptime: process.uptime(),
                                cwd: process.cwd()
                            },
                            memory: {
                                total: os.totalmem(),
                                free: os.freemem(),
                                used: os.totalmem() - os.freemem(),
                                process: process.memoryUsage()
                            },
                            network: {
                                interfaces: os.networkInterfaces()
                            }
                        },
                        null,
                        2
                    )
                }
            ]
        };
    }
);
```

### 返回值

| 类型                 | 描述                                   |
| -------------------- | -------------------------------------- |
| `RegisteredResource` | 注册的资源对象，提供资源控制和管理方法 |

**示例**

```typescript
// 基本静态资源注册
const configResource = server.registerResource(
    'app-config',
    'config://app/settings',
    {
        title: '应用配置',
        description: '应用程序配置信息',
        mimeType: 'application/json'
    },
    async uri => {
        return {
            contents: [
                {
                    uri: uri.toString(),
                    mimeType: 'application/json',
                    text: JSON.stringify(
                        {
                            name: 'My MCP Server',
                            version: '1.0.0',
                            environment: process.env.NODE_ENV || 'development',
                            features: {
                                tools: true,
                                resources: true,
                                prompts: true,
                                auth: false
                            },
                            limits: {
                                maxFileSize: '10MB',
                                maxConnections: 100,
                                requestTimeout: 30000
                            }
                        },
                        null,
                        2
                    )
                }
            ]
        };
    }
);

// 文本资源示例
server.registerResource(
    'readme',
    'doc://readme',
    {
        title: 'README文档',
        description: '项目说明文档',
        mimeType: 'text/markdown'
    },
    async uri => {
        return {
            contents: [
                {
                    uri: uri.toString(),
                    mimeType: 'text/markdown',
                    text: `# MCP服务器

这是一个示例MCP服务器，提供以下功能：

## 功能特性

- **工具系统**：提供可执行的功能
- **资源系统**：提供可访问的数据
- **提示系统**：提供可复用的模板

## 使用方法

1. 连接到服务器
2. 列出可用资源
3. 读取所需资源内容

## 联系方式

如有问题，请联系开发团队。
`
                }
            ]
        };
    }
);

// 二进制资源示例
server.registerResource(
    'logo',
    'asset://logo.png',
    {
        title: '公司Logo',
        description: '公司标识图片',
        mimeType: 'image/png'
    },
    async uri => {
        // 读取图片文件
        const logoBuffer = await readFile('./assets/logo.png');

        return {
            contents: [
                {
                    uri: uri.toString(),
                    mimeType: 'image/png',
                    blob: logoBuffer.toString('base64')
                }
            ]
        };
    }
);
```

#### RegisteredResource 和 RegisteredResourceTemplate

`registerResource` 方法根据资源类型返回不同的对象：
- **静态资源**（固定URI）：返回 `RegisteredResource` 对象
- **动态资源**（URI模板）：返回 `RegisteredResourceTemplate` 对象

两种类型都提供资源控制和管理方法，具有相似的接口。

**RegisteredResource 属性**

| 属性名         | 类型                  | 只读 | 描述                     |
| -------------- | --------------------- | ---- | ------------------------ |
| `name`         | `string`              | 是   | 资源名称                 |
| `title`        | `string`              | 否   | 资源标题（可选）         |
| `metadata`     | `ResourceMetadata`    | 否   | 资源元数据（可选）       |
| `readCallback` | `ReadResourceCallback` | 是   | 资源读取回调函数         |
| `enabled`      | `boolean`             | 是   | 当前是否启用状态         |

**RegisteredResource 方法**

| 方法名                     | 参数 | 返回值 | 描述                         |
| -------------------------- | ---- | ------ | ---------------------------- |
| `enable()`                 | 无   | `void` | 启用资源                     |
| `disable()`                | 无   | `void` | 禁用资源                     |
| `update(updates: object)`  | 对象 | `void` | 更新资源配置（名称、URI、元数据等） |
| `remove()`                 | 无   | `void` | 从服务器中完全移除资源       |

**RegisteredResourceTemplate 额外属性**

`RegisteredResourceTemplate` 包含 `RegisteredResource` 的所有属性，还有：

| 属性名             | 类型                  | 只读 | 描述                     |
| ------------------ | --------------------- | ---- | ------------------------ |
| `resourceTemplate` | `ResourceTemplate`    | 是   | 关联的URI模板对象        |

**RegisteredResourceTemplate 额外方法**

与 `RegisteredResource` 相同的方法，但 `update()` 方法接受 `template?: ResourceTemplate` 参数。

**使用示例**

```typescript
// 资源控制方法
const resource = server.registerResource('my-resource', 'res://data', config, readCallback);

// 访问资源属性
console.log(resource.name);      // 资源名称
console.log(resource.enabled);   // 当前启用状态（注意：属性名为 enabled，不是 isEnabled）
console.log(resource.title);     // 资源标题（如果设置了的话）
console.log(resource.metadata);  // 资源元数据

// 条件性启用/禁用
if (process.env.NODE_ENV === 'production') {
    resource.enable();
} else {
    resource.disable();
}

// 动态资源管理
const resources = new Map<string, RegisteredResource>();
resources.set('config', server.registerResource('config', 'config://app', configDef, readCallback1));
resources.set('docs', server.registerResource('docs', 'doc://api', docsDef, readCallback2));

// 批量操作
function enableAllResources() {
    resources.forEach(resource => resource.enable());
}

function removeAllResources() {
    resources.forEach(resource => resource.remove());
    resources.clear();
}

// 使用 update() 方法更新资源配置
resource.update({
    title: '新的资源标题',
    metadata: { description: '更新后的描述' }
});
```

## 动态资源和URI模板

### ResourceTemplate 构造函数

动态资源使用URI模板支持参数化访问，适合提供大量相关数据。

```typescript
new ResourceTemplate(
    uriTemplate: string | UriTemplate,
    callbacks: {
        /**
         * 列出所有匹配此模板的资源的回调函数
         * 必须指定，即使为 undefined，以避免意外忘记资源列表
         */
        list: ListResourcesCallback | undefined;

        /**
         * 可选的回调函数用于自动完成URI模板内的变量
         * 对客户端和用户发现可能的值很有用
         */
        complete?: {
            [variable: string]: CompleteResourceTemplateCallback;
        };
    }
)
```

**参数**

| 参数名        | 类型                                      | 必填 | 描述                                  |
| ------------- | ----------------------------------------- | ---- | ------------------------------------- |
| `uriTemplate` | `string \| UriTemplate`                   | 是   | URI模板字符串或UriTemplate对象        |
| `callbacks`   | `object`                                  | 是   | 回调函数配置对象                      |

**callbacks 对象字段：**

| 字段名     | 类型                                      | 必填 | 描述                                 |
| ---------- | ----------------------------------------- | ---- | ------------------------------------ |
| `list`     | `ListResourcesCallback \| undefined`      | 是   | 列出匹配资源的回调函数（可为undefined） |
| `complete` | `{ [variable: string]: CompleteResourceTemplateCallback }` | 否 | 变量自动完成回调函数映射              |

`UriTemplate` 支持RFC 6570标准定义的URI模板操作符，用于控制变量扩展方式：

| 操作符   | 描述                   | 示例          |
| -------- | ---------------------- | ------------- |
| 无操作符 | 简单字符串扩展         | `{variable}`  |
| `+`      | 保留字符不编码         | `{+path}`     |
| `#`      | 片段标识符             | `{#fragment}` |
| `.`      | 点分隔扩展             | `{.domain}`   |
| `/`      | 路径段扩展             | `{/path}`     |
| `?`      | 查询参数扩展           | `{?query}`    |
| `&`      | 查询参数续扩           | `{&query}`    |
| `*`      | 爆炸修饰符（数组展开） | `{*list}`     |

**ListResourcesCallback 函数签名：**
```typescript
type ListResourcesCallback = (
    extra: RequestHandlerExtra<ServerRequest, ServerNotification>
) => ListResourcesResult | Promise<ListResourcesResult>;
```

**CompleteResourceTemplateCallback 函数签名：**
```typescript
type CompleteResourceTemplateCallback = (
    value: string,
    context?: {
        arguments?: Record<string, string>;
    }
) => string[] | Promise<string[]>;
```

> **注意：** `list` 回调函数必须指定（即使是 `undefined`），这是为了避免意外忘记提供资源列表。`complete` 回调是可选的，用于提供URI模板变量的自动完成建议。

**ListResourcesResult 字段详解：**

`ListResourcesResult` 是 `list` 回调函数的返回类型，用于列出模板匹配的所有资源。

| 字段名       | 类型          | 必填 | 描述                                 |
| ------------ | ------------- | ---- | ------------------------------------ |
| `resources`  | `Resource[]`  | 是   | 资源数组，包含每个匹配资源的详细信息 |
| `nextCursor` | `Cursor`      | 否   | 分页游标，用于继续获取更多结果       |
| `_meta`      | `RequestMeta` | 否   | 元数据信息                           |

**Resource 字段详解：**

每个 `Resource` 对象代表一个具体的资源实例，包含以下字段：

| 字段名        | 类型                      | 必填 | 描述                             |
| ------------- | ------------------------- | ---- | -------------------------------- |
| `name`        | `string`                  | 是   | 资源名称，必须唯一的字符串标识符 |
| `title`       | `string`                  | 否   | 资源显示标题，用于UI展示         |
| `uri`         | `string`                  | 是   | 资源的完整URI地址                |
| `description` | `string`                  | 否   | 资源功能的详细描述               |
| `mimeType`    | `string`                  | 否   | 资源的MIME类型                   |
| `icons`       | `Icon[]`                  | 否   | 可选图标数组，用于UI展示         |
| `annotations` | `Annotations`             | 否   | 可选注解信息                     |
| `_meta`       | `object` | 否   | 自定义元数据信息                 |

**Annotations 字段详解：**

| 字段名         | 类型     | 必填 | 描述                                  |
| -------------- | -------- | ---- | ------------------------------------- |
| `audience`     | `Role[]` | 否   | 目标受众数组（'user' 或 'assistant'） |
| `priority`     | `number` | 否   | 重要性提示，范围0-1                   |
| `lastModified` | `string` | 否   | ISO 8601时间戳，最后修改时间          |

**使用示例**

```typescript
import { ResourceTemplate } from '@modelcontextprotocol/server';

// 创建URI模板
const fileTemplate = new ResourceTemplate(
    'file:///{path}', // URI模板，{path}是变量
    {
        list: async () => {
            // 可选：列出可用资源
            const files = await listFiles('./data');
            return {
                resources: files.map(file => ({
                    uri: `file:///${file.path}`,
                    name: file.name,
                    description: `文件：${file.name}`,
                    mimeType: getMimeType(file.extension)
                }))
            };
        }
    }
);

// 注册动态资源
server.registerResource(
    'file-system',
    fileTemplate,
    {
        title: '文件系统',
        description: '访问文件系统中的文件',
        mimeType: 'text/plain' // 默认MIME类型
    },
    async (uri, variables) => {
        // variables包含模板变量
        const filePath = variables.path;

        try {
            // 安全检查：防止路径遍历攻击
            if (filePath.includes('..') || filePath.startsWith('/')) {
                throw new Error('不安全的文件路径');
            }

            const fullPath = path.join('./data', filePath);
            const content = await readFile(fullPath, 'utf-8');
            const stats = await stat(fullPath);

            return {
                contents: [
                    {
                        uri: uri.toString(),
                        mimeType: getMimeType(path.extname(filePath)),
                        text: content,
                        size: stats.size,
                        lastModified: stats.mtime.toISOString()
                    }
                ]
            };
        } catch (error) {
            throw new Error(`无法读取文件 ${filePath}: ${error.message}`);
        }
    }
);
```

### 复杂URI模板示例

```typescript
// 数据库记录访问模板
const dbRecordTemplate = new ResourceTemplate('db://{table}/{id}', {
    list: async () => {
        // 列出所有表和部分记录作为示例
        const tables = await db.listTables();
        const resources: any[] = [];

        for (const table of tables) {
            const sampleRecords = await db.query(`SELECT id FROM ${table} LIMIT 10`);

            for (const record of sampleRecords) {
                resources.push({
                    uri: `db://${table}/${record.id}`,
                    name: `${table} - ${record.id}`,
                    description: `${table}表中的记录 ${record.id}`,
                    mimeType: 'application/json'
                });
            }
        }

        return { resources };
    }
});

server.registerResource(
    'database-records',
    dbRecordTemplate,
    {
        title: '数据库记录',
        description: '访问数据库中的记录',
        mimeType: 'application/json'
    },
    async (uri, variables) => {
        const { table, id } = variables;

        // 验证表名（防止SQL注入）
        const allowedTables = ['users', 'products', 'orders'];
        if (!allowedTables.includes(table)) {
            throw new Error(`不允许访问表: ${table}`);
        }

        // 验证ID格式
        if (!/^\d+$/.test(id)) {
            throw new Error(`无效的记录ID: ${id}`);
        }

        try {
            const record = await db.queryOne(`SELECT * FROM ${table} WHERE id = ?`, [parseInt(id)]);

            if (!record) {
                throw new Error(`记录不存在: ${table}/${id}`);
            }

            return {
                contents: [
                    {
                        uri: uri.toString(),
                        mimeType: 'application/json',
                        text: JSON.stringify(record, null, 2)
                    }
                ]
            };
        } catch (error) {
            throw new Error(`数据库查询失败: ${error.message}`);
        }
    }
);

// API数据访问模板
const apiDataTemplate = new ResourceTemplate('api://{service}/{endpoint}', {
    list: async () => {
        return {
            resources: [
                {
                    uri: 'api://github/user',
                    name: 'GitHub用户信息',
                    description: '获取GitHub用户信息',
                    mimeType: 'application/json'
                },
                {
                    uri: 'api://weather/current',
                    name: '当前天气',
                    description: '获取当前天气信息',
                    mimeType: 'application/json'
                }
            ]
        };
    }
});

server.registerResource(
    'api-data',
    apiDataTemplate,
    {
        title: 'API数据',
        description: '访问外部API数据',
        mimeType: 'application/json'
    },
    async (uri, variables) => {
        const { service, endpoint } = variables;

        const apiHandlers = {
            github: {
                user: async () => {
                    const response = await fetch('https://api.github.com/user', {
                        headers: {
                            Authorization: `token ${process.env.GITHUB_TOKEN}`,
                            'User-Agent': 'MCP-Server'
                        }
                    });

                    if (!response.ok) {
                        throw new Error(`GitHub API错误: ${response.statusText}`);
                    }

                    return await response.json();
                }
            },
            weather: {
                current: async () => {
                    const response = await fetch(`https://api.openweathermap.org/data/2.5/weather?q=Beijing&appid=${process.env.WEATHER_API_KEY}`);

                    if (!response.ok) {
                        throw new Error(`天气API错误: ${response.statusText}`);
                    }

                    return await response.json();
                }
            }
        };

        const serviceHandler = apiHandlers[service];
        if (!serviceHandler) {
            throw new Error(`不支持的服务: ${service}`);
        }

        const endpointHandler = serviceHandler[endpoint];
        if (!endpointHandler) {
            throw new Error(`不支持的端点: ${service}/${endpoint}`);
        }

        try {
            const data = await endpointHandler();

            return {
                contents: [
                    {
                        uri: uri.toString(),
                        mimeType: 'application/json',
                        text: JSON.stringify(data, null, 2)
                    }
                ]
            };
        } catch (error) {
            throw new Error(`API调用失败: ${error.message}`);
        }
    }
);
```

## 资源变更通知

### 资源列表变更通知

当资源列表发生变化时，服务器可以主动通知客户端：

```typescript
// 资源管理器类
class ResourceManager {
    private server: McpServer;
    private watchedDirectories = new Set<string>();
    private watchers = new Map<string, any>();

    constructor(server: McpServer) {
        this.server = server;
    }

    // 添加目录监控
    watchDirectory(dirPath: string) {
        if (this.watchedDirectories.has(dirPath)) {
            return;
        }

        this.watchedDirectories.add(dirPath);

        // 使用文件系统监控
        const watcher = fs.watch(dirPath, { recursive: true }, (eventType, filename) => {
            if (filename) {
                console.log(`文件变更: ${eventType} - ${filename}`);
                // 发送资源列表变更通知
                this.server.sendResourceListChanged();
            }
        });

        this.watchers.set(dirPath, watcher);
    }

    // 停止监控
    unwatchDirectory(dirPath: string) {
        const watcher = this.watchers.get(dirPath);
        if (watcher) {
            watcher.close();
            this.watchers.delete(dirPath);
            this.watchedDirectories.delete(dirPath);
        }
    }

    // 手动触发资源变更
    notifyResourceChanged(uri: string) {
        this.server.sendResourceUpdated({ uri });
    }

    // 清理所有监控
    cleanup() {
        for (const watcher of this.watchers.values()) {
            watcher.close();
        }
        this.watchers.clear();
        this.watchedDirectories.clear();
    }
}

// 使用示例
const resourceManager = new ResourceManager(server);

// 监控数据目录
resourceManager.watchDirectory('./data');

// 注册文件系统资源
const fileTemplate = new ResourceTemplate('file:///{path}', {
    list: async () => {
        const files = await listFilesRecursively('./data');
        return {
            resources: files.map(file => ({
                uri: `file:///${path.relative('./data', file)}`,
                name: path.basename(file),
                description: `文件: ${file}`,
                mimeType: getMimeType(path.extname(file))
            }))
        };
    }
});

server.registerResource(
    'files',
    fileTemplate,
    {
        title: '文件系统',
        description: '监控的文件系统资源'
    },
    async (uri, variables) => {
        const filePath = path.join('./data', variables.path);
        const content = await readFile(filePath, 'utf-8');

        return {
            contents: [
                {
                    uri: uri.toString(),
                    mimeType: getMimeType(path.extname(filePath)),
                    text: content
                }
            ]
        };
    }
);

// 进程退出时清理
process.on('SIGINT', () => {
    resourceManager.cleanup();
    process.exit(0);
});
```

### 资源订阅机制

对于需要实时更新的资源，可以实现订阅机制：

```typescript
// 资源订阅管理器
class ResourceSubscriptionManager {
    private server: McpServer;
    private subscriptions = new Map<string, Set<string>>(); // uri -> sessionIds
    private updateTimers = new Map<string, NodeJS.Timeout>();

    constructor(server: McpServer) {
        this.server = server;
    }

    // 订阅资源更新
    subscribe(uri: string, sessionId: string) {
        if (!this.subscriptions.has(uri)) {
            this.subscriptions.set(uri, new Set());
            this.startUpdates(uri);
        }

        this.subscriptions.get(uri)!.add(sessionId);
        console.log(`会话 ${sessionId} 订阅了资源 ${uri}`);
    }

    // 取消订阅
    unsubscribe(uri: string, sessionId: string) {
        const sessions = this.subscriptions.get(uri);
        if (sessions) {
            sessions.delete(sessionId);

            if (sessions.size === 0) {
                this.subscriptions.delete(uri);
                this.stopUpdates(uri);
            }
        }
    }

    // 开始资源更新
    private startUpdates(uri: string) {
        if (uri.startsWith('live://')) {
            // 实时数据更新
            const timer = setInterval(async () => {
                try {
                    await this.notifyResourceUpdate(uri);
                } catch (error) {
                    console.error(`资源更新失败 ${uri}:`, error);
                }
            }, 5000); // 每5秒更新一次

            this.updateTimers.set(uri, timer);
        }
    }

    // 停止资源更新
    private stopUpdates(uri: string) {
        const timer = this.updateTimers.get(uri);
        if (timer) {
            clearInterval(timer);
            this.updateTimers.delete(uri);
        }
    }

    // 通知资源更新
    private async notifyResourceUpdate(uri: string) {
        const sessions = this.subscriptions.get(uri);
        if (!sessions || sessions.size === 0) {
            return;
        }

        // 发送资源更新通知
        this.server.sendResourceUpdated({ uri });
    }

    // 清理所有订阅
    cleanup() {
        for (const timer of this.updateTimers.values()) {
            clearInterval(timer);
        }
        this.updateTimers.clear();
        this.subscriptions.clear();
    }
}

// 实时数据资源示例
const subscriptionManager = new ResourceSubscriptionManager(server);

server.registerResource(
    'system-stats',
    'live://system/stats',
    {
        title: '系统状态',
        description: '实时系统状态信息',
        mimeType: 'application/json'
    },
    async uri => {
        const stats = {
            timestamp: new Date().toISOString(),
            uptime: process.uptime(),
            memory: process.memoryUsage(),
            cpu: await getCpuUsage(),
            loadAverage: os.loadavg(),
            freeMemory: os.freemem(),
            totalMemory: os.totalmem(),
            platform: os.platform(),
            arch: os.arch()
        };

        return {
            contents: [
                {
                    uri: uri.toString(),
                    mimeType: 'application/json',
                    text: JSON.stringify(stats, null, 2)
                }
            ]
        };
    }
);

// CPU使用率计算函数
async function getCpuUsage(): Promise<number> {
    return new Promise(resolve => {
        const startTime = process.hrtime();
        const startUsage = process.cpuUsage();

        setTimeout(() => {
            const endTime = process.hrtime(startTime);
            const endUsage = process.cpuUsage(startUsage);

            const totalTime = endTime[0] * 1000000 + endTime[1] / 1000;
            const totalCpuTime = endUsage.user + endUsage.system;
            const cpuPercent = (totalCpuTime / totalTime) * 100;

            resolve(cpuPercent);
        }, 100);
    });
}
```

## 高级资源模式

### 分页资源访问

```typescript
// 分页资源模板
const paginatedTemplate = new ResourceTemplate('paginated://{collection}?page={page}&size={size}', {
    list: async () => {
        const collections = ['users', 'products', 'orders'];
        const resources: any[] = [];

        for (const collection of collections) {
            // 为每个集合生成分页资源示例
            for (let page = 1; page <= 3; page++) {
                resources.push({
                    uri: `paginated://${collection}?page=${page}&size=10`,
                    name: `${collection} - 第${page}页`,
                    description: `${collection}集合的第${page}页数据`,
                    mimeType: 'application/json'
                });
            }
        }

        return { resources };
    }
});

server.registerResource(
    'paginated-data',
    paginatedTemplate,
    {
        title: '分页数据',
        description: '支持分页的大数据集访问',
        mimeType: 'application/json'
    },
    async (uri, variables) => {
        const { collection, page = '1', size = '10' } = variables;

        const pageNum = parseInt(page);
        const pageSize = parseInt(size);

        if (pageNum < 1 || pageSize < 1 || pageSize > 100) {
            throw new Error('无效的分页参数');
        }

        const offset = (pageNum - 1) * pageSize;

        try {
            const { data, total } = await fetchPaginatedData(collection, offset, pageSize);
            const totalPages = Math.ceil(total / pageSize);

            return {
                contents: [
                    {
                        uri: uri.toString(),
                        mimeType: 'application/json',
                        text: JSON.stringify(
                            {
                                collection,
                                pagination: {
                                    page: pageNum,
                                    size: pageSize,
                                    total,
                                    totalPages,
                                    hasNext: pageNum < totalPages,
                                    hasPrev: pageNum > 1,
                                    nextPage: pageNum < totalPages ? pageNum + 1 : null,
                                    prevPage: pageNum > 1 ? pageNum - 1 : null
                                },
                                data
                            },
                            null,
                            2
                        )
                    }
                ]
            };
        } catch (error) {
            throw new Error(`分页数据获取失败: ${error.message}`);
        }
    }
);

// 模拟分页数据获取
async function fetchPaginatedData(collection: string, offset: number, limit: number) {
    // 这里应该是实际的数据库查询
    const mockData = Array.from({ length: 1000 }, (_, i) => ({
        id: i + 1,
        name: `${collection}-item-${i + 1}`,
        createdAt: new Date(Date.now() - Math.random() * 86400000 * 30).toISOString()
    }));

    const data = mockData.slice(offset, offset + limit);
    const total = mockData.length;

    return { data, total };
}
```

### 搜索资源

```typescript
// 搜索资源模板
const searchTemplate = new ResourceTemplate('search://{query}?type={type}&limit={limit}', {
    list: async () => {
        return {
            resources: [
                {
                    uri: 'search://example?type=all&limit=10',
                    name: '搜索示例',
                    description: '搜索功能使用示例',
                    mimeType: 'application/json'
                }
            ]
        };
    }
});

server.registerResource(
    'search',
    searchTemplate,
    {
        title: '搜索功能',
        description: '全文搜索和过滤功能',
        mimeType: 'application/json'
    },
    async (uri, variables) => {
        const { query, type = 'all', limit = '20' } = variables;

        if (!query || query.trim().length < 2) {
            throw new Error('搜索查询至少需要2个字符');
        }

        const searchLimit = Math.min(parseInt(limit), 100);

        try {
            const results = await performSearch(query, type, searchLimit);

            return {
                contents: [
                    {
                        uri: uri.toString(),
                        mimeType: 'application/json',
                        text: JSON.stringify(
                            {
                                query,
                                type,
                                limit: searchLimit,
                                results: {
                                    total: results.total,
                                    items: results.items,
                                    facets: results.facets,
                                    suggestions: results.suggestions
                                },
                                searchTime: results.searchTime
                            },
                            null,
                            2
                        )
                    }
                ]
            };
        } catch (error) {
            throw new Error(`搜索失败: ${error.message}`);
        }
    }
);

// 搜索实现
async function performSearch(query: string, type: string, limit: number) {
    const startTime = Date.now();

    // 模拟搜索逻辑
    const allData = [
        { id: 1, title: 'JavaScript基础教程', content: '学习JavaScript的基础知识', type: 'tutorial' },
        { id: 2, title: 'TypeScript高级特性', content: 'TypeScript的高级功能和特性', type: 'tutorial' },
        { id: 3, title: 'Node.js服务器开发', content: '使用Node.js开发服务器应用', type: 'guide' },
        { id: 4, title: 'React组件设计', content: 'React组件的设计原则和最佳实践', type: 'guide' },
        { id: 5, title: 'API文档规范', content: 'API文档的编写规范和标准', type: 'documentation' }
    ];

    // 过滤和搜索
    let filteredData = allData;

    if (type !== 'all') {
        filteredData = allData.filter(item => item.type === type);
    }

    const searchResults = filteredData.filter(item => item.title.toLowerCase().includes(query.toLowerCase()) || item.content.toLowerCase().includes(query.toLowerCase()));

    const items = searchResults.slice(0, limit);

    // 生成搜索建议
    const suggestions = generateSearchSuggestions(query, allData);

    // 生成分面信息
    const facets = generateFacets(searchResults);

    const searchTime = Date.now() - startTime;

    return {
        total: searchResults.length,
        items,
        facets,
        suggestions,
        searchTime
    };
}

function generateSearchSuggestions(query: string, data: any[]): string[] {
    const words = new Set<string>();

    data.forEach(item => {
        const text = `${item.title} ${item.content}`.toLowerCase();
        const matches = text.match(/\b\w+\b/g) || [];
        matches.forEach(word => {
            if (word.length > 3 && word.includes(query.toLowerCase())) {
                words.add(word);
            }
        });
    });

    return Array.from(words).slice(0, 5);
}

function generateFacets(results: any[]) {
    const typeCounts = new Map<string, number>();

    results.forEach(item => {
        typeCounts.set(item.type, (typeCounts.get(item.type) || 0) + 1);
    });

    return {
        types: Array.from(typeCounts.entries()).map(([type, count]) => ({
            value: type,
            count,
            label: type.charAt(0).toUpperCase() + type.slice(1)
        }))
    };
}
```
