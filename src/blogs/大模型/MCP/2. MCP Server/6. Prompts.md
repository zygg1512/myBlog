# Prompts

提示系统是MCP服务器的重要组成部分，提供可复用的提示模板，帮助AI生成一致和高质量的响应。提示可以参数化，支持不同的使用场景和复杂的参数验证。

## 提示注册基础

### `registerPrompt()`

注册一个提示模板，供客户端获取和使用。

```typescript
registerPrompt(name: string, config: PromptConfig, handler: PromptHandler): RegisteredPrompt
```

**参数**

| 参数名    | 类型            | 必填 | 描述                             |
| --------- | --------------- | ---- | -------------------------------- |
| `name`    | `string`        | 是   | 提示名称，必须唯一的字符串标识符 |
| `config`  | `PromptConfig`  | 是   | 提示配置信息对象                 |
| `handler` | `PromptHandler` | 是   | 提示处理函数                     |

**config (PromptConfig) 详细字段：**

| 字段名        | 类型                           | 必填 | 描述                                   |
| ------------- | ------------------------------ | ---- | -------------------------------------- |
| `title`       | `string`                       | 否   | 提示显示标题，用于UI展示               |
| `description` | `string`                       | 否   | 提示功能的详细描述                     |
| `argsSchema`  | `ZodRawShapeCompat \| AnySchema` | 否   | 输入参数的Zod Schema定义，用于参数验证 |


```typescript
server.registerPrompt(
    'advanced-prompt',
    {
        title: '高级提示模板',
        description: '具有完整元数据的高级提示示例',
        argsSchema: {
            topic: z.string().describe('讨论主题'),
            depth: z.enum(['overview', 'detailed', 'expert']).describe('讨论深度')
        },
        // 注意：annotations 和 _meta 是自定义扩展字段，非标准API部分
        annotations: {
            category: 'analysis',
            tags: ['research', 'academic'],
            difficulty: 'intermediate',
            estimatedTime: '10-15 minutes',
            language: 'chinese',
            version: '2.1.0'
        },
        _meta: {
            author: 'Prompt Engineering Team',
            createdAt: '2024-01-15',
            lastUpdated: '2024-03-20',
            documentation: 'https://docs.example.com/prompts/advanced',
            examples: [
                {
                    title: '科技分析',
                    args: { topic: '人工智能发展趋势', depth: 'detailed' },
                    description: '分析AI技术发展趋势'
                },
                {
                    title: '商业概览',
                    args: { topic: '电子商务市场', depth: 'overview' },
                    description: '电商市场概况分析'
                }
            ],
            usageGuidelines: ['适用于需要深度分析的场景', '建议配合专业背景知识使用', '可以根据受众调整深度参数'],
            relatedPrompts: ['research-assistant', 'data-analysis'],
            changelog: [
                { version: '2.1.0', changes: ['添加了专家级深度选项', '优化了输出结构'] },
                { version: '2.0.0', changes: ['重构了参数结构', '改进了提示逻辑'] }
            ]
        }
    },
    async ({ topic, depth }) => {
        const depthInstructions = {
            overview: '提供简洁的概览，重点突出关键信息',
            detailed: '进行详细分析，包含多个维度和具体例子',
            expert: '深入专业分析，包含前沿观点和技术细节'
        };

        return {
            messages: [
                {
                    role: 'system',
                    content: {
                        type: 'text',
                        text: `你是一位资深的研究分析专家，擅长对各种主题进行深入分析。
${depthInstructions[depth]}。请确保分析客观、准确、有洞察力。`
                    }
                },
                {
                    role: 'user',
                    content: {
                        type: 'text',
                        text: `请对"${topic}"进行${depth === 'overview' ? '概览性' : depth === 'detailed' ? '详细' : '专家级'}分析。

请从以下角度进行分析：
1. 现状和背景
2. 关键趋势和发展
3. 主要挑战和机遇
4. 未来展望和建议

请提供结构化、有深度的分析内容。`
                    }
                }
            ]
        };
    }
);
```

**annotations作用**：自定义扩展字段，可用于存储提示的分类、标签、难度等级等任意元数据。非标准API部分，客户端不保证理解。

**_meta作用**：灵活元数据字段，类型为`Record<string, unknown>`，用于存储任意自定义数据。在提示接口中定义为标准字段，可以包含作者、创建时间、文档链接、使用示例等。这些数据不参与协议语义，客户端不保证理解或使用。

**示例**

```typescript
import { McpServer } from '@modelcontextprotocol/server';
import * as z from 'zod/v4';

const server = new McpServer({
    name: 'prompt-example-server',
    version: '1.0.0'
});

// 基础提示注册
const codeReviewPrompt = server.registerPrompt(
    'code-review',
    {
        title: '代码审查',
        description: '生成代码审查提示',
        argsSchema: {
            language: z.enum(['javascript', 'typescript', 'python', 'java', 'go']).describe('编程语言'),
            codeType: z.enum(['function', 'class', 'module', 'component']).describe('代码类型'),
            focusArea: z
                .array(z.enum(['performance', 'security', 'maintainability', 'testing']))
                .min(1, '至少选择一个关注领域')
                .describe('审查重点'),
            strictness: z.enum(['relaxed', 'normal', 'strict']).default('normal').describe('审查严格程度')
        }
    },
    async ({ language, codeType, focusArea, strictness = 'normal' }) => {
        const focusText = focusArea.join('、');
        const strictnessText = {
            relaxed: '请给出建设性的建议',
            normal: '请提供详细的分析和改进建议',
            strict: '请进行严格的审查，指出所有潜在问题'
        }[strictness];

        return {
            messages: [
                {
                    role: 'system',
                    content: {
                        type: 'text',
                        text: `你是一位资深的${language}开发专家，专门负责代码审查。${strictnessText}，确保代码质量和最佳实践。`
                    }
                },
                {
                    role: 'user',
                    content: {
                        type: 'text',
                        text: `请审查以下${language} ${codeType}代码，重点关注${focusText}。`
                    }
                }
            ]
        };
    }
);

// 简单的文档生成提示
server.registerPrompt(
    'generate-docs',
    {
        title: '文档生成',
        description: '为代码生成文档',
        argsSchema: {
            docType: z.enum(['api', 'readme', 'changelog', 'tutorial']).describe('文档类型'),
            format: z.enum(['markdown', 'html', 'plain']).default('markdown').describe('输出格式'),
            audience: z.enum(['developer', 'user', 'admin']).describe('目标受众'),
            includeExamples: z.boolean().default(true).describe('是否包含示例')
        }
    },
    async ({ docType, format, audience, includeExamples = true }) => {
        const audienceText = {
            developer: '开发者',
            user: '最终用户',
            admin: '系统管理员'
        }[audience];

        const formatInstructions = {
            markdown: '使用Markdown格式，包含适当的标题、列表和代码块',
            html: '使用HTML格式，包含适当的标签和样式',
            plain: '使用纯文本格式，结构清晰易读'
        }[format];

        return {
            messages: [
                {
                    role: 'system',
                    content: {
                        type: 'text',
                        text: `你是一位专业的技术文档编写专家，擅长为${audienceText}编写清晰、准确的${docType}文档。`
                    }
                },
                {
                    role: 'user',
                    content: {
                        type: 'text',
                        text: `请为提供的代码生成${docType}文档。

要求：
- 目标受众：${audienceText}
- ${formatInstructions}
- ${includeExamples ? '包含实用的代码示例和使用场景' : '重点说明核心功能，无需详细示例'}
- 确保文档结构清晰，内容准确完整
- 使用专业但易懂的语言

请生成高质量的文档内容。`
                    }
                }
            ]
        };
    }
);
```

### 返回值 RegisteredPrompt

`registerPrompt` 返回一个 `RegisteredPrompt` 对象，提供提示控制和管理方法。

| 类型               | 描述                                   |
| ------------------ | -------------------------------------- |
| `RegisteredPrompt` | 注册的提示对象，提供提示控制和管理方法 |

**RegisteredPrompt 属性**

| 属性名        | 类型                           | 只读 | 描述                     |
| ------------- | ------------------------------ | ---- | ------------------------ |
| `title`       | `string`                       | 是   | 提示显示标题             |
| `description` | `string`                       | 是   | 提示功能描述             |
| `argsSchema`  | `AnyObjectSchema`              | 是   | 输入参数 Schema 对象     |
| `callback`    | `PromptCallback`               | 是   | 提示处理函数             |
| `enabled`     | `boolean`                      | 是   | 当前是否启用状态         |

**RegisteredPrompt 方法**

| 方法名      | 参数         | 返回值 | 描述                            |
| ----------- | ------------ | ------ | ------------------------------- |
| `enable()`  | 无           | `void` | 启用提示，设置 enabled 为 true  |
| `disable()` | 无           | `void` | 禁用提示，设置 enabled 为 false |
| `remove()`  | 无           | `void` | 从服务器中完全移除提示          |
| `update()`  | updates 对象 | `void` | 动态更新提示的各种属性          |

**使用示例**

```typescript
// 提示控制方法
const prompt = server.registerPrompt('my-prompt', config, handler);

// 访问提示属性
console.log(prompt.name); // 提示名称
console.log(prompt.isEnabled); // 当前启用状态

// 条件性启用/禁用
if (process.env.ENABLE_ADVANCED_PROMPTS === 'true') {
    prompt.enable();
} else {
    prompt.disable();
}

// 动态提示管理
const prompts = new Map<string, RegisteredPrompt>();
prompts.set('review', server.registerPrompt('code-review', reviewConfig, reviewHandler));
prompts.set('docs', server.registerPrompt('generate-docs', docsConfig, docsHandler));

// 批量操作
function enableAllPrompts() {
    prompts.forEach(prompt => prompt.enable());
}

function removeAllPrompts() {
    prompts.forEach(prompt => prompt.remove());
    prompts.clear();
}
```

### handler (PromptHandler) 函数签名

```typescript
type PromptHandler = (args: any, extra: RequestHandlerExtra) => Promise<GetPromptResult>;
// 实际类型为 PromptCallback，支持两种形式：
// 1. 有参数：(args: ShapeOutput<Args>, extra: RequestHandlerExtra) => GetPromptResult | Promise<GetPromptResult>
// 2. 无参数：(extra: RequestHandlerExtra) => GetPromptResult | Promise<GetPromptResult>
```

**GetPromptResult 类型定义**

`GetPromptResult` 是提示处理函数的返回值类型，包含生成的提示消息和其他元数据。

**GetPromptResult 字段**

| 字段名        | 类型              | 必填 | 描述                                 |
| ------------- | ----------------- | ---- | ------------------------------------ |
| `description` | `string`          | 否   | 可选的提示描述信息                   |
| `messages`    | `PromptMessage[]` | 是   | 提示消息数组，定义对话的上下文和内容 |
| `_meta`       | `object`          | 否   | 自定义元数据（从父类 `Result` 继承） |

**PromptMessage 字段**

| 字段名    | 类型           | 必填 | 描述                                                                             |
| --------- | -------------- | ---- | -------------------------------------------------------------------------------- |
| `role`    | `Role`         | 是   | 消息角色：`'system'`、`'user'`、`'assistant'`、`'developer'` 或 `'developer-bg'` |
| `content` | `ContentBlock` | 是   | 消息内容块，支持文本、图像、资源链接等多种类型                                   |

**Role 类型说明**

| 角色值           | 描述                                       |
| ---------------- | ------------------------------------------ |
| `'system'`       | 系统消息，定义AI的指令、角色和上下文       |
| `'user'`         | 用户消息，通常包含用户的输入或问题         |
| `'assistant'`    | AI助手消息，包含AI的回应                   |
| `'developer'`    | 开发者消息，用于调试或开发上下文           |
| `'developer-bg'` | 开发者背景消息，用于提供开发相关的背景信息 |

**ContentBlock 类型**

内容块支持多种格式，详见「Tools 介绍」中的 ContentBlock 类型说明。

**使用注意事项**

1. **消息顺序**：`messages` 数组中的消息顺序决定了对话的上下文流
2. **角色分配**：通常以 `system` 消息开头定义指令，后跟 `user` 消息提供具体任务
3. **内容类型**：支持文本、图片、资源链接等多种格式，但大多数提示使用纯文本
4. **参数化**：可以使用模板字符串或条件逻辑动态生成消息内容
5. **错误处理**：如果提示生成失败，应抛出异常而不是返回错误消息

## 对话式提示

```typescript
// 教学对话提示
server.registerPrompt(
    'teaching-dialogue',
    {
        title: '教学对话',
        description: '生成互动式教学对话',
        argsSchema: {
            subject: z.string().min(2, '学科名称至少2个字符').describe('学科或主题'),
            level: z.enum(['beginner', 'intermediate', 'advanced']).describe('学习水平'),
            teachingStyle: z.enum(['socratic', 'explanatory', 'practical', 'discovery']).describe('教学方式'),
            sessionDuration: z.enum(['short', 'medium', 'long']).default('medium').describe('教学时长'),
            includeExercises: z.boolean().default(true).describe('包含练习')
        }
    },
    async ({ subject, level, teachingStyle, sessionDuration, includeExercises }) => {
        const levelDescriptions = {
            beginner: '初学者，需要基础概念解释',
            intermediate: '有一定基础，可以讨论深入话题',
            advanced: '高级学习者，可以进行复杂分析'
        };

        const styleInstructions = {
            socratic: '使用苏格拉底式提问，引导学生思考',
            explanatory: '详细解释概念，提供清晰的说明',
            practical: '注重实际应用和案例分析',
            discovery: '引导学生自主发现和探索'
        };

        const durationSettings = {
            short: '简洁明了，重点突出',
            medium: '适中深度，平衡理论与实践',
            long: '深入详细，全面覆盖主题'
        };

        return {
            messages: [
                {
                    role: 'system',
                    content: {
                        type: 'text',
                        text: `你是一位经验丰富的${subject}教师，擅长与${levelDescriptions[level]}进行互动教学。
你的教学风格是${styleInstructions[teachingStyle]}。
本次教学session要求${durationSettings[sessionDuration]}。
${includeExercises ? '请在适当时候提供练习题目。' : '重点关注概念讲解。'}`
                    }
                },
                {
                    role: 'assistant',
                    content: {
                        type: 'text',
                        text: `你好！欢迎来到${subject}学习session。我注意到你是${level === 'beginner' ? '初学者' : level === 'intermediate' ? '中级学习者' : '高级学习者'}，我会根据你的水平来调整教学内容。

今天我们要学习什么具体的主题呢？请告诉我你最感兴趣的部分，或者你遇到的具体问题。`
                    }
                },
                {
                    role: 'user',
                    content: {
                        type: 'text',
                        text: `我想学习关于${subject}的内容。请开始教学，并根据我的回应调整教学方式。`
                    }
                }
            ]
        };
    }
);

// 调试对话提示
server.registerPrompt(
    'debug-assistant',
    {
        title: '调试助手',
        description: '帮助调试代码问题',
        argsSchema: {
            programmingLanguage: z.string().describe('编程语言'),
            errorType: z.enum(['syntax', 'runtime', 'logic', 'performance', 'unknown']).describe('错误类型'),
            debuggingLevel: z.enum(['basic', 'intermediate', 'advanced']).describe('调试深度'),
            includeSteps: z.boolean().default(true).describe('包含调试步骤'),
            provideAlternatives: z.boolean().default(false).describe('提供替代方案')
        }
    },
    async ({ programmingLanguage, errorType, debuggingLevel, includeSteps, provideAlternatives }) => {
        const errorTypeDescriptions = {
            syntax: '语法错误，代码无法编译或解析',
            runtime: '运行时错误，程序执行时出错',
            logic: '逻辑错误，程序运行但结果不正确',
            performance: '性能问题，程序运行缓慢或资源消耗过多',
            unknown: '未知问题，需要进一步诊断'
        };

        const debuggingApproaches = {
            basic: '基础调试，重点解决问题',
            intermediate: '中等深度，分析原因和解决方案',
            advanced: '深入分析，包含最佳实践和预防措施'
        };

        return {
            messages: [
                {
                    role: 'system',
                    content: {
                        type: 'text',
                        text: `你是一位经验丰富的${programmingLanguage}开发专家，专门帮助解决编程问题。
你擅长处理${errorTypeDescriptions[errorType]}。
你的调试方法是${debuggingApproaches[debuggingLevel]}。
${includeSteps ? '请提供清晰的调试步骤。' : ''}
${provideAlternatives ? '在解决问题后，请提供替代实现方案。' : ''}`
                    }
                },
                {
                    role: 'assistant',
                    content: {
                        type: 'text',
                        text: `我是你的${programmingLanguage}调试助手！我看到你遇到了${errorTypeDescriptions[errorType]}。

为了更好地帮助你，请提供以下信息：
1. 具体的错误信息或问题描述
2. 相关的代码片段
3. 你期望的行为
4. 你已经尝试过的解决方法

请分享你的代码和错误信息，我会帮你一步步解决问题。`
                    }
                },
                {
                    role: 'user',
                    content: {
                        type: 'text',
                        text: `我在${programmingLanguage}中遇到了${errorType}问题。请帮我调试并解决。`
                    }
                }
            ]
        };
    }
);
```

## 基于上下文生成提示

```typescript
// 智能提示生成器
class PromptGenerator {
    private server: McpServer;
    private templates = new Map<string, any>();

    constructor(server: McpServer) {
        this.server = server;
        this.initializeTemplates();
    }

    private initializeTemplates() {
        // 注册基础模板
        this.registerTemplate('analysis', {
            systemRole: '分析专家',
            userInstructions: '请分析以下内容',
            outputFormat: '结构化分析'
        });

        this.registerTemplate('creative', {
            systemRole: '创意写作专家',
            userInstructions: '请创作以下内容',
            outputFormat: '富有创意的内容'
        });

        this.registerTemplate('technical', {
            systemRole: '技术专家',
            userInstructions: '请提供技术解决方案',
            outputFormat: '详细的技术方案'
        });
    }

    private registerTemplate(name: string, template: any) {
        this.templates.set(name, template);
    }

    // 动态生成提示
    generatePrompt(context: { type: string; domain: string; complexity: string; audience: string; customInstructions?: string }) {
        const promptName = `dynamic-${context.type}-${Date.now()}`;

        return this.server.registerPrompt(
            promptName,
            {
                title: `动态${context.type}提示`,
                description: `为${context.domain}领域生成的动态提示`,
                argsSchema: {
                    content: z.string().describe('输入内容'),
                    additionalContext: z.string().optional().describe('额外上下文'),
                    outputLength: z.enum(['short', 'medium', 'long']).default('medium').describe('输出长度')
                }
            },
            async ({ content, additionalContext, outputLength }) => {
                const template = this.templates.get(context.type) || this.templates.get('analysis');

                const complexityInstructions = {
                    simple: '使用简单易懂的语言',
                    moderate: '保持适中的复杂度',
                    complex: '可以使用专业术语和复杂概念'
                };

                const audienceInstructions = {
                    general: '面向普通读者',
                    professional: '面向专业人士',
                    expert: '面向领域专家'
                };

                const lengthInstructions = {
                    short: '简洁明了，重点突出',
                    medium: '适中长度，平衡详细度',
                    long: '详细全面，深入分析'
                };

                let systemPrompt = `你是一位${context.domain}领域的${template.systemRole}。
你的回答应该${complexityInstructions[context.complexity]}，${audienceInstructions[context.audience]}。
输出要求：${lengthInstructions[outputLength]}。`;

                if (context.customInstructions) {
                    systemPrompt += `\n特殊要求：${context.customInstructions}`;
                }

                let userPrompt = `${template.userInstructions}：

${content}`;

                if (additionalContext) {
                    userPrompt += `\n\n额外上下文：${additionalContext}`;
                }

                userPrompt += `\n\n请提供${template.outputFormat}。`;

                return {
                    messages: [
                        {
                            role: 'system',
                            content: {
                                type: 'text',
                                text: systemPrompt
                            }
                        },
                        {
                            role: 'user',
                            content: {
                                type: 'text',
                                text: userPrompt
                            }
                        }
                    ]
                };
            }
        );
    }
}

// 使用动态提示生成器
const promptGenerator = new PromptGenerator(server);

// 注册动态提示创建工具
server.registerTool(
    'create-dynamic-prompt',
    {
        title: '创建动态提示',
        description: '根据需求动态创建提示模板',
        inputSchema: {
            type: z.enum(['analysis', 'creative', 'technical']).describe('提示类型'),
            domain: z.string().describe('专业领域'),
            complexity: z.enum(['simple', 'moderate', 'complex']).describe('复杂度'),
            audience: z.enum(['general', 'professional', 'expert']).describe('目标受众'),
            customInstructions: z.string().optional().describe('自定义指令')
        }
    },
    async ({ type, domain, complexity, audience, customInstructions }, extra) => {
        try {
            const prompt = promptGenerator.generatePrompt({
                type,
                domain,
                complexity,
                audience,
                customInstructions
            });

            return {
                content: [
                    {
                        type: 'text',
                        text: `动态提示 "${prompt.name}" 创建成功！

配置信息：
- 类型：${type}
- 领域：${domain}
- 复杂度：${complexity}
- 受众：${audience}
${customInstructions ? `- 自定义指令：${customInstructions}` : ''}

提示已注册并可以使用。`
                    }
                ],
                structuredContent: {
                    promptName: prompt.name,
                    configuration: {
                        type,
                        domain,
                        complexity,
                        audience,
                        customInstructions
                    }
                }
            };
        } catch (error) {
            return {
                content: [
                    {
                        type: 'text',
                        text: `动态提示创建失败：${error.message}`
                    }
                ]
            };
        }
    }
);
```
