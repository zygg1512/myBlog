# 传输层配置详解

## 传输层概述

传输层是 MCP（Model Context Protocol）SDK 的核心通信组件，负责在客户端和服务器之间传输 JSON-RPC 消息。它抽象了底层通信细节，让应用开发者能够专注于业务逻辑，而无需关心具体的通信机制。

TypeScript SDK 提供了多种传输层实现，以适应不同的部署场景和通信需求。所有传输层都遵循统一的 `Transport` 接口，该接口定义了消息发送、接收、连接启动和关闭等基本操作。

## 传输层选择指南

| 特性           | `StdioServerTransport`         | `StreamableHTTPServerTransport`           |
| -------------- | ------------------------------ | ----------------------------------------- |
| **通信方式**   | 标准输入输出（stdin/stdout）   | HTTP + SSE 流                             |
| **部署环境**   | Node.js 本地进程               | Node.js、Cloudflare Workers、Deno、Bun 等 |
| **会话管理**   | 无                             | 有状态/无状态可选                         |
| **可恢复性**   | 不支持                         | 支持（通过 `EventStore`）                 |
| **网络访问**   | 仅本地                         | 支持远程访问                              |
| **使用复杂度** | 简单                           | 中等                                      |
| **适用场景**   | CLI 工具、嵌入式应用、开发调试 | Web 服务、云函数、长连接应用              |

**选择建议：**

1. **本地开发/CLI 工具**：优先使用 `StdioServerTransport`，简单直接
2. **Web 服务/远程访问**：使用 `StreamableHTTPServerTransport`
3. **无服务器环境**：使用 `StreamableHTTPServerTransport` 无状态模式
4. **需要断线重连**：使用 `StreamableHTTPServerTransport` 并配置 `EventStore`

## `StdioServerTransport`（标准输入输出传输）

`StdioServerTransport` 是基于标准输入输出（stdin/stdout）的传输层实现，专门用于本地进程间通信。它允许 MCP 服务器作为子进程运行，通过管道与父进程交换 JSON-RPC 消息，适合命令行工具和本地集成场景。

### 适用场景

`StdioServerTransport` 主要适用于以下本地通信场景：

| 场景          | 适用性    | 说明                                                 |
| ------------- | --------- | ---------------------------------------------------- |
| 本地 CLI 工具 | ✅ 推荐   | 将 MCP 服务器集成到命令行工具中，通过子进程方式运行  |
| 开发调试      | ✅ 推荐   | 开发过程中快速测试服务器逻辑，无需启动 HTTP 服务     |
| 嵌入式应用    | ✅ 推荐   | 将 MCP 服务器嵌入到现有 Node.js 应用中，通过进程通信 |
| 远程部署      | ❌ 不适用 | 仅支持本地进程通信，无法通过网络访问                 |

### 配置选项

`StdioServerTransport` 构造函数支持两个可选参数，用于自定义输入输出流：

```typescript
const transport = new StdioServerTransport(stdin, stdout);
```

| 参数名   | 类型       | 必填 | 默认值           | 说明                                 |
| -------- | ---------- | ---- | ---------------- | ------------------------------------ |
| `stdin`  | `Readable` | 否   | `process.stdin`  | Node.js 可读流，用于接收客户端消息   |
| `stdout` | `Writable` | 否   | `process.stdout` | Node.js 可写流，用于向客户端发送消息 |

**重要说明：**

- **环境限制**：仅在 Node.js 环境下可用
- **消息处理**：内部使用 `ReadBuffer` 处理消息流，自动管理背压（backpressure）
- **资源管理**：传输层关闭时会暂停 stdin（如果是唯一监听器），避免影响应用其他部分

### 示例

#### 基础示例

```typescript
// 导入必要的模块
import { McpServer } from '@modelcontextprotocol/server';
import { StdioServerTransport } from '@modelcontextprotocol/server/stdio.js';

// 创建 MCP 服务器实例
const server = new McpServer({
    name: 'stdio-example-server',  // 服务器名称
    version: '1.0.0'               // 服务器版本
});

// 创建传输层实例（使用默认的 stdin/stdout）
// 不传递参数时，默认使用 process.stdin 和 process.stdout
const transport = new StdioServerTransport();

// 连接传输层到服务器
// 这一步会启动传输层，开始监听 stdin 上的消息
await server.connect(transport);

// 服务器现在通过 stdio 与客户端通信
// 客户端可以通过子进程的 stdin/stdout 与服务器交换 JSON-RPC 消息
```

#### 自定义流（高级用法）

在某些场景下，你可能需要自定义输入输出流，例如进行单元测试或集成到特殊环境中：

```typescript
// 导入 Node.js 流模块和传输层
import { Readable, Writable } from 'node:stream';
import { StdioServerTransport } from '@modelcontextprotocol/server/stdio.js';

// 创建模拟的 stdin 流（用于测试或自定义场景）
// Readable 流用于接收来自"客户端"的消息
const mockStdin = new Readable({
    read() {
        /* 自定义读取逻辑 */
        // 在实际使用中，这里可以模拟输入数据
        // 例如：this.push('{"jsonrpc":"2.0","method":"initialize","params":{}}');
    }
});

// 创建模拟的 stdout 流（用于测试或自定义场景）
// Writable 流用于向"客户端"发送消息
const mockStdout = new Writable({
    write(chunk, encoding, callback) {
        // 自定义写入逻辑，例如记录日志或转发到其他目的地
        console.log('发送消息:', chunk.toString());
        // 必须调用 callback() 通知流系统写入完成
        callback();
    }
});

// 使用自定义流创建传输层
// 这样可以完全控制输入输出的来源和目的地
const transport = new StdioServerTransport(mockStdin, mockStdout);
```

## `StreamableHTTPServerTransport`（流式 HTTP 传输）

`StreamableHTTPServerTransport` 是基于 HTTP 协议的传输层实现，支持 Server-Sent Events (SSE) 流式传输和传统的请求-响应模式。它具有完整的 Web 标准兼容性，可以在多种运行时环境中运行，包括 Node.js、Cloudflare Workers、Deno 和 Bun 等。

### 适用场景

`StreamableHTTPServerTransport` 适用于需要远程访问或流式通信的场景：

| 场景            | 适用性  | 说明                                                   |
| --------------- | ------- | ------------------------------------------------------ |
| Web 服务部署    | ✅ 推荐 | 将 MCP 服务器部署为 HTTP 服务，支持远程客户端访问      |
| 云函数/边缘计算 | ✅ 推荐 | 在 Cloudflare Workers、AWS Lambda 等无服务器环境中运行 |
| 长连接应用      | ✅ 推荐 | 支持 SSE 流式传输，适合实时通信和长时间任务处理        |
| 向后兼容        | ✅ 支持 | 提供 JSON 响应模式，兼容不支持 SSE 的客户端            |
| 本地开发        | ✅ 适用 | 可通过 HTTP 接口进行开发和测试                         |

### 配置选项

`StreamableHTTPServerTransport` 构造函数接受一个配置对象，用于定制传输行为：

```typescript
new StreamableHTTPServerTransport(options?: StreamableHTTPServerTransportOptions)
```

**配置字段说明：**

| 字段名                 | 类型                                           | 必填 | 默认值      | 说明                                           |
| ---------------------- | ---------------------------------------------- | ---- | ----------- | ---------------------------------------------- |
| `sessionIdGenerator`   | `() => string`                                 | 否   | `undefined` | 会话 ID 生成函数。未提供时为无状态模式         |
| `onsessioninitialized` | `(sessionId: string) => void \| Promise<void>` | 否   | `undefined` | 会话初始化回调，在新会话创建时调用             |
| `onsessionclosed`      | `(sessionId: string) => void \| Promise<void>` | 否   | `undefined` | 会话关闭回调，在会话终止时调用                 |
| `enableJsonResponse`   | `boolean`                                      | 否   | `false`     | 启用 JSON 响应模式（禁用 SSE 流）              |
| `eventStore`           | `EventStore`                                   | 否   | `undefined` | 事件存储接口，用于支持可恢复性（resumability） |
| `retryInterval`        | `number`                                       | 否   | `undefined` | SSE 重试间隔（毫秒），控制客户端重连时机       |

#### `EventStore`（可恢复性支持）

`EventStore` 接口用于支持**可恢复性（Resumability）**功能，允许客户端在网络中断后重新连接并恢复错过的消息。该功能通过存储和重放 Server-Sent Events (SSE) 事件来实现。

**工作原理：**

1. **事件存储**：服务器发送消息时，调用 `storeEvent()` 方法生成唯一事件 ID 并存储消息
2. **客户端重连**：客户端断开连接后，重新连接时在 `Last-Event-ID` 头部携带最后收到的事件 ID
3. **事件重放**：服务器调用 `replayEventsAfter()` 方法，重放该事件 ID 之后的所有消息
4. **恢复通信**：重放完成后，客户端恢复正常通信，不会错过任何消息

**内存实现示例：**

```typescript
import type { EventStore, JSONRPCMessage } from '@modelcontextprotocol/server';

export class InMemoryEventStore implements EventStore {
    private events = new Map<string, { streamId: string; message: JSONRPCMessage }>();

    async storeEvent(streamId: string, message: JSONRPCMessage): Promise<string> {
        const eventId = `${streamId}_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
        this.events.set(eventId, { streamId, message });
        return eventId;
    }

    async replayEventsAfter(lastEventId: string, { send }: { send: (eventId: string, message: JSONRPCMessage) => Promise<void> }): Promise<string> {
        // 从事件 ID 中提取流 ID
        const streamId = lastEventId.split('_')[0] || '';

        // 按时间顺序重放事件
        const sortedEvents = [...this.events.entries()].sort((a, b) => a[0].localeCompare(b[0]));
        let foundLastEvent = false;

        for (const [eventId, { streamId: eventStreamId, message }] of sortedEvents) {
            if (eventStreamId !== streamId) continue;

            if (eventId === lastEventId) {
                foundLastEvent = true;
                continue;
            }

            if (foundLastEvent) {
                await send(eventId, message);
            }
        }
        return streamId;
    }
}
```

**使用注意事项：**

- **内存存储**：`InMemoryEventStore` 适合开发和测试，生产环境应使用持久化存储（如 Redis、数据库）
- **存储清理**：需要定期清理旧事件，避免内存泄漏
- **事件 ID 格式**：事件 ID 应包含足够信息以确定事件顺序和所属流
- **并发安全**：多会话环境下需要确保存储和检索操作的线程安全

**配置示例：**

```typescript
// 导入事件存储实现
import { InMemoryEventStore } from './inMemoryEventStore.js';
import { randomUUID } from 'node:crypto';

// 创建支持可恢复性的传输层配置
const transport = new StreamableHTTPServerTransport({
    // 启用有状态模式，生成唯一会话 ID
    sessionIdGenerator: () => randomUUID(),

    // 配置事件存储，启用可恢复性功能
    // 客户端断开连接后可以重新连接并恢复错过的消息
    eventStore: new InMemoryEventStore(),

    // 设置 SSE 重试间隔（毫秒）
    // 客户端会在指定时间后尝试重新连接，用于实现轮询行为
    retryInterval: 2000,

    // 会话初始化回调
    // 当新会话创建时调用，可用于记录或初始化会话相关资源
    onsessioninitialized: sessionId => {
        console.log(`会话 ${sessionId} 已初始化，支持可恢复连接`);
    }
});
```

#### 已弃用字段（推荐使用外部中间件）

以下字段已标记为弃用，建议使用外部中间件（如反向代理、API 网关或专门的安全中间件）来处理相关的安全验证逻辑：

| 字段名                         | 类型       | 必填 | 默认值      | 描述                                                                  |
| ------------------------------ | ---------- | ---- | ----------- | --------------------------------------------------------------------- |
| `allowedHosts`                 | `string[]` | 否   | `undefined` | 允许的 Host 头值列表（用于 DNS 重绑定攻击防护）                       |
| `allowedOrigins`               | `string[]` | 否   | `undefined` | 允许的 Origin 头值列表（用于 CORS 和 DNS 重绑定防护）                 |
| `enableDnsRebindingProtection` | `boolean`  | 否   | `false`     | 启用 DNS 重绑定保护（需要同时配置 `allowedHosts` 和/或 `allowedOrigins`） |

**注意：** 这些安全相关功能现在推荐使用专门的中间件或反向代理（如 Nginx、Traefik 等）来实现，以实现更好的灵活性和可维护性。

#### `sessionIdGenerator`（会话管理）

`sessionIdGenerator` 参数决定了传输层的会话管理模式。根据是否提供该函数，传输层可以工作在两种不同的模式下：

| 模式           | `sessionIdGenerator` 设置               | 行为特点                                                                                                      |
| -------------- | --------------------------------------- | ------------------------------------------------------------------------------------------------------------- |
| **有状态模式** | 提供生成函数（如 `() => randomUUID()`） | - 为每个新会话生成唯一会话 ID<br>- 在响应头中返回 `mcp-session-id`<br>- 验证后续请求中的会话 ID<br>- 维护会话状态和消息历史，支持可恢复性功能 |
| **无状态模式** | `undefined`                             | - 不生成或验证会话 ID<br>- 不维护会话状态<br>- 每个请求独立处理，无会话概念<br>- 适合无服务器环境或简单场景                                     |

**选择建议：**
- **有状态模式**：适用于需要会话管理、断线重连、消息历史记录的场景
- **无状态模式**：适用于无服务器函数（如 Cloudflare Workers、AWS Lambda）或简单的请求-响应场景

#### 端点路由配置

根据 MCP 协议规范，客户端默认会连接到服务的 `/mcp` 接口。因此，当将传输层与 Node.js HTTP 服务器结合使用时，**必须明确声明 `/mcp` 路由**，并将相关请求正确转发给传输层处理。

##### 为什么要将请求转发给 `transport.handleRequest()`

`transport.handleRequest()` 是 `StreamableHTTPServerTransport` 的核心方法，负责处理 HTTP 请求的生命周期。将请求转发给这个方法的原因是：

1. **协议层隔离**：传输层专门处理底层通信细节，包括：
    - JSON-RPC 消息的解析和序列化
    - Server-Sent Events (SSE) 流式传输的管理
    - 会话状态的管理和维护
    - 协议版本协商和验证

2. **统一请求处理**：`handleRequest()` 方法根据 HTTP 方法（GET/POST/DELETE）自动路由到相应的处理逻辑：
    - **POST 请求**：处理 JSON-RPC 消息（请求、通知、批量消息）
    - **GET 请求**：建立 SSE 流式连接，用于服务器推送消息
    - **DELETE 请求**：终止会话并清理资源

3. **会话管理集成**：传输层维护会话状态，`handleRequest()` 负责：
    - 验证 `Mcp-Session-Id` 头部（有状态模式）
    - 执行 DNS 重绑定保护（如果启用）
    - 调用 `onsessioninitialized` 和 `onsessionclosed` 回调

4. **可恢复性支持**：如果配置了 `EventStore`，`handleRequest()` 会：
    - 处理 `Last-Event-ID` 头部，支持断线重连
    - 存储和重放历史事件
    - 管理 SSE 流的事件 ID 序列

5. **错误处理标准化**：传输层处理所有协议级别的错误，并返回标准的 JSON-RPC 错误响应，包括：
    - 无效的 JSON 格式（错误码 -32700）
    - 不支持的协议版本（错误码 -32000）
    - 无效的会话 ID（错误码 -32001）
    - 方法不支持（错误码 -32601）

##### 具体交互流程

完整的 MCP over HTTP 交互流程如下：

**1. 初始化阶段**

```
客户端 → 服务器: POST /mcp
Headers: Accept: application/json,text/event-stream
Body: { "jsonrpc": "2.0", "method": "initialize", "params": { ... } }

服务器 → 客户端: 200 OK
Headers: Content-Type: text/event-stream, mcp-session-id: <session-id>
Body: [SSE 流] { "jsonrpc": "2.0", "id": 1, "result": { ... } }
```

- 客户端发送初始化请求，声明支持的协议版本和能力
- 服务器返回初始化响应，建立 SSE 流连接
- 如果是有状态模式，服务器生成并返回会话 ID

**2. 常规请求/响应流程**

```
客户端 → 服务器: POST /mcp
Headers:
  Accept: application/json,text/event-stream
  Mcp-Session-Id: <session-id> (有状态模式)
  Mcp-Protocol-Version: <version>
Body: { "jsonrpc": "2.0", "method": "tools/call", "params": { ... }, "id": 2 }

服务器 → 客户端: 200 OK
Headers: Content-Type: text/event-stream
Body: [SSE 流] { "jsonrpc": "2.0", "id": 2, "result": { ... } }
```

- 客户端发送 JSON-RPC 请求到 `/mcp` 端点
- 服务器通过 SSE 流返回响应（可能包含多个事件）
- 传输层自动关联请求和响应 ID

**3. 服务器推送流程**

```
服务器 → 客户端: [通过现有的 SSE 流]
事件: { "jsonrpc": "2.0", "method": "notifications/tools/list_changed", "params": { ... } }
```

- 服务器可以在任何时候通过 SSE 流发送通知
- 客户端保持 GET 连接以接收服务器推送的消息

**4. 断线重连流程**（如果启用了 `EventStore`）

```
客户端 → 服务器: GET /mcp
Headers:
  Accept: text/event-stream
  Mcp-Session-Id: <session-id>
  Last-Event-ID: <last-event-id>

服务器 → 客户端: 200 OK
Headers: Content-Type: text/event-stream
Body: [SSE 流，重放错过的事件]
```

- 客户端重新连接时带上最后收到的事件 ID
- 服务器从事件存储中重放错过的事件
- 客户端恢复到断线前的状态

**5. 会话终止流程**

```
客户端 → 服务器: DELETE /mcp
Headers: Mcp-Session-Id: <session-id>

服务器 → 客户端: 200 OK
```

- 客户端发送 DELETE 请求终止会话
- 服务器清理会话资源，关闭相关连接
- 调用 `onsessionclosed` 回调

##### 路由配置实践

1. 客户端 `StreamableHTTPClientTransport` 构造函数的 URL 参数通常为 `http://localhost:3000/mcp`
2. 服务器需要监听 `/mcp` 路径，将请求转发给 `transport.handleRequest()`
3. 需要支持 `POST`（发送 JSON-RPC）、`GET`（建立 SSE 流）、`DELETE`（终止会话）

**安全最佳实践**：在生产环境中，建议将 MCP 端点限制到特定路径（如 `/mcp`），避免处理无关请求。

### 示例


#### 直接使用（Node.js HTTP 服务器）

这个示例展示了如何在原生 Node.js HTTP 服务器中使用传输层，包括路由处理和错误处理：

```typescript
// 导入必要的模块
import { McpServer } from '@modelcontextprotocol/server';
import { StreamableHTTPServerTransport } from '@modelcontextprotocol/server/streamableHttp.js';
import { randomUUID } from 'node:crypto';
import http from 'node:http';

// 创建 MCP 服务器实例
const server = new McpServer({
    name: 'http-example-server',  // 服务器名称
    version: '1.0.0'               // 服务器版本
});

// 创建有状态的传输层
const transport = new StreamableHTTPServerTransport({
    // 启用有状态模式，为每个会话生成唯一 ID
    sessionIdGenerator: () => randomUUID(),

    // 会话初始化回调
    onsessioninitialized: sessionId => {
        console.log(`新会话建立: ${sessionId}`);
    },

    // 会话关闭回调
    onsessionclosed: sessionId => {
        console.log(`会话关闭: ${sessionId}`);
    }
});

// 连接传输层到服务器
// 这一步是必需的，使服务器能够通过传输层发送和接收消息
await server.connect(transport);

// 创建 HTTP 服务器（仅处理 /mcp 端点）
const httpServer = http.createServer(async (req, res) => {
    // 仅处理 /mcp 路径的请求
    if (req.url === '/mcp') {
        // 将请求转发给传输层处理
        // transport.handleRequest() 会处理 JSON-RPC 消息解析、SSE 流建立等
        await transport.handleRequest(req, res);
    } else {
        // 对于非 /mcp 路径的请求，返回 404 错误
        res.writeHead(404, { 'Content-Type': 'application/json' });
        res.end(
            JSON.stringify({
                error: 'Not Found',
                message: 'MCP endpoint is at /mcp'
            })
        );
    }
});

// 启动 HTTP 服务器
httpServer.listen(3000, () => {
    console.log('MCP 服务器运行在 http://localhost:3000');
});
```

#### 无状态模式（无服务器环境）

这个示例展示了如何在无服务器环境（如 Cloudflare Workers）中使用无状态传输层：

```typescript
import { McpServer } from '@modelcontextprotocol/server';
import { StreamableHTTPServerTransport } from '@modelcontextprotocol/server/streamableHttp.js';

const server = new McpServer({
    name: 'stateless-server',
    version: '1.0.0'
});

// 创建无状态传输层
const transport = new StreamableHTTPServerTransport({
    sessionIdGenerator: undefined // 明确设置为无状态
});

await server.connect(transport);

// Cloudflare Workers 示例
export default {
    async fetch(request: Request): Promise<Response> {
        return transport.handleRequest(request);
    }
};
```

#### 与 Koa 结合

这个示例展示了如何将传输层与 Koa 框架集成，利用中间件处理路由：

```typescript
import Koa from 'koa';
import { McpServer } from '@modelcontextprotocol/server';
import { StreamableHTTPServerTransport } from '@modelcontextprotocol/server/streamableHttp.js';
import { randomUUID } from 'node:crypto';
import bodyParser from 'koa-bodyparser';

const app = new Koa();
app.use(bodyParser());

const server = new McpServer({
    name: 'koa-example-server',
    version: '1.0.0'
});

const transport = new StreamableHTTPServerTransport({
    sessionIdGenerator: () => randomUUID()
});

await server.connect(transport);

// Koa 中间件处理 MCP 请求（仅 /mcp 路径）
app.use(async ctx => {
    // 仅处理 /mcp 路径的请求
    if (ctx.path === '/mcp') {
        await transport.handleRequest(ctx.req, ctx.res, ctx.request.body);
    } else {
        ctx.status = 404;
        ctx.body = {
            error: 'Not Found',
            message: 'MCP endpoint is at /mcp'
        };
    }
});

app.listen(3000, () => {
    console.log('Koa 服务器运行在 http://localhost:3000');
});
```

#### 带可恢复性的高级示例

这个示例展示了如何配置和使用可恢复性功能，包括事件存储和 SSE 流管理：

```typescript
import { McpServer } from '@modelcontextprotocol/server';
import { StreamableHTTPServerTransport } from '@modelcontextprotocol/server/streamableHttp.js';
import { InMemoryEventStore } from '@modelcontextprotocol/server/webStandardStreamableHttp.js';
import { randomUUID } from 'node:crypto';

const server = new McpServer({
    name: 'resumable-server',
    version: '1.0.0'
});

// 创建内存事件存储
const eventStore = new InMemoryEventStore();

const transport = new StreamableHTTPServerTransport({
    sessionIdGenerator: () => randomUUID(),
    eventStore, // 启用可恢复性
    retryInterval: 2000, // 客户端 2 秒后重连
    onsessioninitialized: sessionId => {
        console.log(`会话 ${sessionId} 已初始化，支持可恢复连接`);
    }
});

await server.connect(transport);

// 长时间运行的工具示例
server.tool('long-task', {}, async (_args, extra) => {
    // 发送进度更新
    await server.sendLoggingMessage({ level: 'info', data: '任务开始处理...' }, extra.sessionId);

    // 关闭 SSE 流以触发客户端轮询（可恢复性关键）
    if (extra.closeSSEStream) {
        extra.closeSSEStream();
    }

    // 模拟长时间处理
    await new Promise(resolve => setTimeout(resolve, 5000));

    // 发送完成消息（会被事件存储，客户端重连时可恢复）
    await server.sendLoggingMessage({ level: 'info', data: '任务处理完成' }, extra.sessionId);

    return {
        content: [{ type: 'text', text: '长时间任务执行完成' }]
    };
});
```

## 客户端传输层

除了服务器端传输层，SDK 还提供了对应的客户端传输层实现，用于建立与 MCP 服务器的连接：

| 传输层                          | 描述                          | 适用场景             |
| ------------------------------- | ----------------------------- | -------------------- |
| `StdioClientTransport`          | 通过子进程连接本地 MCP 服务器 | 本地 CLI 工具、开发调试 |
| `StreamableHTTPClientTransport` | 通过 HTTP 连接远程 MCP 服务器 | Web 客户端、远程访问、浏览器应用 |

客户端传输层的配置选项和使用方式与服务器端类似。更多详细信息，请参考客户端相关的文档。
