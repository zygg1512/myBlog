# Server 类

Server 是 `@modelcontextprotocol/server` 包提供的底层 API 类，用于创建 MCP (Model Context Protocol) 服务器。它继承自 Protocol 类，提供了完整的协议实现和底层控制功能，适合需要精细控制的场景。

## 构造函数

### 语法

```typescript
new Server(serverInfo: Implementation, options?: ServerOptions)
```

### 参数

| 参数名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
|`serverInfo`|`Implementation`| 是 | 服务器的基本信息配置，用于标识和描述服务器实例 |
|`options`|`ServerOptions`| 否 | 服务器的高级配置选项，用于定制服务器行为和能力 |

**serverInfo (Implementation) 详细字段：**

| 字段名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
|`name`|`string`| 是 | 服务器名称，用于标识服务器，建议使用小写字母和连字符 |
|`version`|`string`| 是 | 语义化版本号，如 "1.0.0" |
|`description`|`string`| 否 | 服务器描述，向客户端说明服务器功能 |
|`websiteUrl`|`string`| 否 | 官网或文档URL，提供更多信息 |
|`icons`|`Icon[]`| 否 | 图标数组，用于在客户端UI中显示 |

**icons (Icon[]) 数组元素字段：**

| 字段名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
|`url`|`string`| 是 | 图标的完整URL地址 |
|`type`|`string`| 是 | MIME类型，常见值：'image/png', 'image/svg+xml', 'image/jpeg' |
|`size`|`number`| 否 | 图标尺寸（像素），建议使用 16, 32, 48, 64, 128 等标准尺寸 |

**options (ServerOptions) 详细字段：**

| 字段名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
|`capabilities`|`ServerCapabilities`| 否 | 服务器能力声明，定义服务器支持的功能 |
|`instructions`|`string`| 否 | 使用说明，向客户端提供操作指导 |
|`jsonSchemaValidator`|`JsonSchemaValidator`| 否 | 自定义JSON Schema验证器实现 |

**capabilities (ServerCapabilities) 详细字段：**

| 字段名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
|`tools`|`object`| 否 | 工具相关能力配置 |
|`tools.listChanged`|`boolean`| 否 | 是否支持工具列表变更通知，true时可发送工具列表更新通知 |
|`resources`|`object`| 否 | 资源相关能力配置 |
|`resources.listChanged`|`boolean`| 否 | 是否支持资源列表变更通知，true时可发送资源列表更新通知 |
|`resources.subscribe`|`boolean`| 否 | 是否支持资源订阅，true时客户端可订阅特定资源的变更 |
|`prompts`|`object`| 否 | 提示相关能力配置 |
|`prompts.listChanged`|`boolean`| 否 | 是否支持提示列表变更通知，true时可发送提示列表更新通知 |
|`logging`|`object`| 否 | 日志功能支持，空对象表示支持基本日志功能 |
|`completions`|`object`| 否 | 自动补全相关能力配置 |
|`completions.tools`|`boolean`| 否 | 是否支持工具参数自动补全，true时客户端可请求工具参数建议 |
|`completions.resources`|`boolean`| 否 | 是否支持资源URI自动补全，true时客户端可请求资源URI建议 |
|`completions.prompts`|`boolean`| 否 | 是否支持提示参数自动补全，true时客户端可请求提示参数建议 |
|`tasks`|`object`| 否 | 实验性任务功能支持 |
|`tasks.requests`|`object`| 否 | 任务请求相关配置 |
|`tasks.requests.tools`|`object`| 否 | 工具调用任务配置 |
|`tasks.requests.tools.call`|`object`| 否 | 是否支持工具调用任务，空对象表示支持基本工具调用任务 |

**jsonSchemaValidator (jsonSchemaValidator) 详细字段：**

| 字段名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
|`getValidator`|`function`| 是 | 根据JSON Schema创建验证器的函数 |

**getValidator 函数签名：**
```typescript
getValidator<T>(schema: JsonSchemaType): JsonSchemaValidator<T>
```

**`JsonSchemaValidator<T>` 函数签名：**
```typescript
(input: unknown) => JsonSchemaValidatorResult<T>
```

**`JsonSchemaValidatorResult<T> `类型：**
```typescript
type JsonSchemaValidatorResult<T> = { valid: true; data: T; errorMessage: undefined } | { valid: false; data: undefined; errorMessage: string }
```

### 示例

```typescript
import { Server } from '@modelcontextprotocol/server'

// 基本初始化
const server = new Server({
    name: 'basic-server',
    version: '1.0.0'
})

// 完整配置初始化
const server = new Server(
    {
        name: 'advanced-server',
        version: '2.0.0',
        description: '高级MCP服务器',
        websiteUrl: 'https://example.com',
        icons: [
            {
                url: 'https://example.com/icon.png',
                type: 'image/png',
                size: 32
            }
        ]
    },
    {
        capabilities: {
            tools: { listChanged: true },
            resources: { listChanged: true, subscribe: true },
            prompts: { listChanged: true },
            logging: {},
            completions: {
                tools: true,
                resources: true,
                prompts: true
            },
            tasks: {
                requests: {
                    tools: { call: {} }
                }
            }
        },
        instructions: '这是一个提供底层控制的MCP服务器。'
    }
)
```

## 实例属性

### oninitialized

事件回调属性，当客户端发送 `initialized` 通知后触发。

```typescript
public oninitialized?: () => void
```

**用途**：
- 监听客户端初始化完成事件
- 获取客户端能力和版本信息
- 执行初始化后的设置

**示例**：

```typescript
server.oninitialized = () => {
    console.log('客户端初始化完成')
    console.log('客户端能力:', server.getClientCapabilities())
    console.log('客户端版本:', server.getClientVersion())
}
```

## 连接管理

### connect()

建立与客户端的连接并启动服务器。此方法会初始化传输层、处理协议握手，并开始监听客户端请求。

```typescript
connect(transport: Transport): Promise<void>
```

**参数**

| 参数名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
|`transport`|`Transport`| 是 | 传输层实例，定义了服务器与客户端的通信方式 |

**transport (Transport) 可选类型：**

| 传输层类型 | 适用场景 | 特点 | 配置参数 |
|-----------|---------|------|----------|
|`StreamableHTTPServerTransport`| 远程HTTP服务 | 支持SSE流式传输，适合Web应用集成 | sessionIdGenerator, port, host |
|`StdioServerTransport`| 本地进程通信 | 通过标准输入输出通信，适合命令行工具 | 无需配置参数 |
|`SSEServerTransport`| 传统HTTP+SSE | 兼容旧版客户端的HTTP传输方式 | port, host 等HTTP配置 |

**返回值**

| 类型 | 描述 |
|------|------|
| `Promise<void>` | 异步操作Promise，连接成功时resolve，失败时reject并抛出错误信息 |

**示例**：

```typescript
import { StreamableHTTPServerTransport } from '@modelcontextprotocol/server/streamable-http'
import { StdioServerTransport } from '@modelcontextprotocol/server/stdio'

// HTTP传输 - 适合Web服务集成
const httpTransport = new StreamableHTTPServerTransport({
    sessionIdGenerator: () => crypto.randomUUID(), // 会话ID生成器
    port: 3000,                                    // 监听端口
    host: 'localhost'                              // 监听地址
})

try {
    await server.connect(httpTransport)
    console.log('HTTP服务器启动成功，监听端口 3000')
} catch (error) {
    console.error('HTTP服务器启动失败:', error)
}

// 标准输入输出传输 - 适合命令行工具
const stdioTransport = new StdioServerTransport()

try {
    await server.connect(stdioTransport)
    console.log('Stdio服务器启动成功')
} catch (error) {
    console.error('Stdio服务器启动失败:', error)
}

// 带错误处理的完整示例
async function startServer() {
    const transport = new StreamableHTTPServerTransport({
        sessionIdGenerator: () => crypto.randomUUID()
    })

    try {
        // 连接前的准备工作
        console.log('正在启动MCP服务器...')

        // 建立连接
        await server.connect(transport)

        console.log('MCP服务器已启动并等待客户端连接')

        // 设置优雅关闭处理
        process.on('SIGINT', async () => {
            console.log('收到关闭信号，正在优雅关闭服务器...')
            await server.close()
            process.exit(0)
        })

    } catch (error) {
        console.error('服务器启动失败:', error)
        process.exit(1)
    }
}

startServer()
```

### close()

优雅地关闭服务器连接，清理资源并停止所有活动的通信。

```typescript
close(): Promise<void>
```

**参数**

此方法无需参数。

**返回值**

| 类型 | 描述 |
|------|------|
| `Promise<void>` | 异步操作Promise，关闭完成时resolve，失败时reject并抛出错误信息 |

**注意事项**

- 调用后服务器将无法接受新的连接
- 正在处理的请求会等待完成
- 建议在进程退出前调用此方法

**示例**：

```typescript
// 基本关闭操作
async function shutdown() {
    try {
        console.log('正在关闭服务器...')
        await server.close()
        console.log('服务器已安全关闭')
    } catch (error) {
        console.error('关闭服务器时发生错误:', error)
    }
}

// 处理进程信号的优雅关闭
process.on('SIGINT', async () => {
    console.log('\n收到 SIGINT 信号，开始优雅关闭...')
    await shutdown()
    process.exit(0)
})

process.on('SIGTERM', async () => {
    console.log('收到 SIGTERM 信号，开始优雅关闭...')
    await shutdown()
    process.exit(0)
})

// 带超时的关闭操作
async function shutdownWithTimeout(timeoutMs = 5000) {
    const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('关闭超时')), timeoutMs)
    })

    try {
        await Promise.race([
            server.close(),
            timeoutPromise
        ])
        console.log('服务器已关闭')
    } catch (error) {
        console.error('关闭失败或超时:', error)
        // 强制退出
        process.exit(1)
    }
}

// 在应用退出时自动清理
process.on('exit', () => {
    console.log('应用程序退出')
})

// 捕获未处理的异常
process.on('uncaughtException', async (error) => {
    console.error('未捕获的异常:', error)
    await shutdown()
    process.exit(1)
})

process.on('unhandledRejection', async (reason, promise) => {
    console.error('未处理的Promise拒绝:', reason)
    await shutdown()
    process.exit(1)
})
```

## 能力管理

### registerCapabilities()

告知客户端服务器支持哪些功能。此方法必须在`connect()`之前执行。

```typescript
registerCapabilities(capabilities: ServerCapabilities): void
```

**参数**

| 参数名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
|`capabilities`|`ServerCapabilities`| 是 | 服务器能力配置对象，定义服务器支持的功能 |

**capabilities (ServerCapabilities) 详细字段：** 与「构造函数」章节一致。

**返回值**

此方法无返回值。

**注意事项**：
- 必须在 `connect()` 调用前注册
- 一旦连接建立，能力不可修改
- 客户端会根据声明的能力调整行为
- 未声明的能力将不可用

**示例**：

```typescript
// 基本能力注册
server.registerCapabilities({
    tools: { listChanged: true },
    resources: { listChanged: true, subscribe: true },
    logging: {}
})

// 完整能力注册
server.registerCapabilities({
    tools: {
        listChanged: true  // 启用工具列表变更通知
    },
    resources: {
        listChanged: true, // 启用资源列表变更通知
        subscribe: true    // 启用资源订阅功能
    },
    prompts: {
        listChanged: true  // 启用提示列表变更通知
    },
    logging: {},           // 启用日志功能
    completions: {
        tools: true,       // 启用工具参数自动补全
        resources: true,   // 启用资源URI自动补全
        prompts: true      // 启用提示参数自动补全
    },
    tasks: {
        requests: {
            tools: { call: {} }  // 启用工具调用任务
        }
    }
})

// 连接必须在能力注册之后
await server.connect(transport)

// ❌ 错误：连接后不能修改能力
// server.registerCapabilities({ tools: { listChanged: false } }) // 这会失败

// 条件性能力注册
const isProduction = process.env.NODE_ENV === 'production'
server.registerCapabilities({
    tools: { listChanged: true },
    resources: {
        listChanged: true,
        subscribe: !isProduction  // 生产环境禁用订阅功能
    },
    logging: isProduction ? {} : undefined,  // 仅生产环境启用日志
    completions: {
        tools: true,
        resources: true,
        prompts: true
    }
})

await server.connect(transport)
```

### getClientCapabilities()

获取连接的客户端声明的能力信息，用于了解客户端支持哪些MCP功能。此方法只有在协议初始化完成后才返回有效数据。

```typescript
getClientCapabilities(): ClientCapabilities | undefined
```

**参数**

此方法无需参数。

**返回值**

| 类型 | 描述 |
|------|------|
| ClientCapabilities \|`undefined`| 客户端能力对象，初始化前为undefined |

**ClientCapabilities 详细字段：**

| 字段名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
|`experimental`|`object`| 否 | 实验性功能支持 |
|`sampling`|`object`| 否 | LLM采样能力，客户端可以处理服务器发起的LLM推理请求 |
|`roots`|`object`| 否 | 文件系统根目录能力 |
|`roots.listChanged`|`boolean`| 否 | 是否支持根目录列表变更通知，客户端可以提供可访问的文件系统根目录列表 |
|`elicitation`|`object`| 否 | 用户输入引出能力，客户端可以处理服务器发起的用户输入请求 |

**作用**

- 获取客户端支持的MCP协议功能列表
- 用于条件性功能启用和行为调整
- 帮助服务器适配不同客户端的能力差异

**使用时机**

- 在 `oninitialized` 回调中调用
- 需要检查客户端特定能力时
- 实现功能降级或适配时

### getClientVersion()

获取连接的客户端版本和实现信息，用于了解客户端的身份和版本详情。此方法只有在协议初始化完成后才返回有效数据。

```typescript
getClientVersion(): Implementation | undefined
```

**参数**

此方法无需参数。

**返回值**

| 类型 | 描述 |
|------|------|
| Implementation \|`undefined`| 客户端实现信息，初始化前为undefined |

**Implementation 详细字段：**

| 字段名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
|`name`|`string`| 是 | 客户端名称，如 "Claude Desktop", "MCP CLI" |
|`version`|`string`| 是 | 客户端版本号，如 "1.0.0" |
|`description`|`string`| 否 | 客户端描述信息 |
|`websiteUrl`|`string`| 否 | 客户端官网或文档URL |
|`icons`|`Icon[]`| 否 | 客户端图标信息 |

**作用**

- 获取客户端的标识信息和版本号
- 用于日志记录和调试信息
- 实现基于客户端版本的兼容性处理

**使用时机**

- 在 `oninitialized` 回调中调用
- 需要记录客户端信息时
- 实现客户端特定的兼容性逻辑时

**示例**：

```typescript
server.oninitialized = () => {
    const clientCaps = server.getClientCapabilities()
    const clientVersion = server.getClientVersion()

    console.log('客户端信息:', {
        name: clientVersion?.name,
        version: clientVersion?.version,
        capabilities: clientCaps
    })

    // 根据客户端能力调整行为
    if (clientCaps?.sampling) {
        console.log('客户端支持采样功能')
    }

    if (clientCaps?.roots) {
        console.log('客户端支持文件系统根目录')
    }
}
```

## 请求处理

### setRequestHandler()

注册客户端请求处理器，用于处理特定类型的客户端请求。这是Server类的核心方法，提供了对MCP协议请求的底层控制能力。

与McpServer的高级API（如registerTool、registerResource）相比，setRequestHandler提供了更大的灵活性，但需要手动处理能力注册、请求路由、参数验证等细节。

```typescript
setRequestHandler<T>(schema: Schema, handler: RequestHandler<T>): void
```


**参数**

| 参数名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
|`schema`|`Schema`| 是 | 请求的Zod Schema定义，用于验证和解析请求参数，参见「常见的 Schema」章节 |
|`handler`|`RequestHandler`| 是 | 请求处理函数，接收解析后的请求数据和额外上下文信息 |

**handler (RequestHandler) 函数签名：**
```typescript
type RequestHandler<T> = (request: T, extra: RequestHandlerExtra) => Promise<any>
```

**handler 函数参数：**

| 参数名 | 类型 | 描述 |
|--------|------|------|
|`request`|`T`| 根据Schema解析的请求数据 |
|`extra`|`RequestHandlerExtra`| 请求处理的上下文信息 |

**extra (RequestHandlerExtra) 详细字段：**

| 字段名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
|`signal`|`AbortSignal`| 是 | 请求取消信号，用于长时间运行的操作中检查是否被取消 |
|`sessionId`|`string`| 否 | 会话标识符，多会话环境下区分不同客户端连接 |
|`requestId`|`RequestId`| 是 | 请求唯一标识，用于日志记录、错误追踪、调试 |
|`authInfo`|`AuthInfo`| 否 | 认证信息（如果启用认证），用于权限检查、用户身份验证 |
|`sendNotification`|`function`| 是 | 发送通知到客户端的函数，用于进度更新、状态变更通知 |
|`sendRequest`|`function`| 是 | 向客户端发起请求的函数，用于双向通信、客户端能力调用 |
|`taskStore`|`TaskStore`| 否 | 任务存储接口（实验性），用于长时间运行任务的状态管理 |

**返回值**

此方法无返回值，注册成功后，当客户端发送对应类型的请求时会调用处理函数。

**注意事项**：
- 同一个Schema只能注册一个处理器，重复注册会覆盖之前的处理器
- 处理函数必须返回符合MCP协议规范的响应格式
- 建议在处理器中进行适当的错误处理和参数验证
- 处理器应该是异步函数，支持Promise返回

**示例**：

```typescript
import { ListToolsRequestSchema, CallToolRequestSchema, ReadResourceRequestSchema, GetPromptRequestSchema } from '@modelcontextprotocol/core'

// 工具列表处理器：当客户端请求工具列表时触发
server.setRequestHandler(ListToolsRequestSchema, async (request, extra) => {
    return {
        tools: [
            {
                name: 'echo',
                description: '回显工具',
                inputSchema: {
                    type: 'object',
                    properties: {
                        message: { type: 'string' }
                    },
                    required: ['message']
                }
            }
        ]
    }
})

// 工具调用处理器：当客户端调用工具时触发
server.setRequestHandler(CallToolRequestSchema, async (request, extra) => {
    const { name, arguments: args } = request.params

    // 检查认证
    if (!extra.authInfo) {
        throw new Error('需要认证')
    }

    // 检查取消信号
    if (extra.signal.aborted) {
        throw new Error('请求已取消')
    }

    // 发送进度通知
    await extra.sendNotification({
        method: 'notifications/progress',
        params: {
            operation: 'tool-execution',
            progress: 0.5
        }
    })
    // 路由到具体工具
    switch (name) {
        case 'echo':
            return {
                content: [
                    {
                        type: 'text',
                        text: `回显: ${args.message}`
                    }
                ]
            }
        default:
            throw new Error(`未知工具: ${name}`)
    }
})

// 资源读取处理器
server.setRequestHandler(ReadResourceRequestSchema, async (request, extra) => {
    const { uri } = request.params

    switch (uri) {
        case 'memory://system/status':
            return {
                contents: [
                    {
                        uri,
                        mimeType: 'application/json',
                        text: JSON.stringify(
                            {
                                uptime: process.uptime(),
                                memory: process.memoryUsage(),
                                timestamp: new Date().toISOString()
                            },
                            null,
                            2
                        )
                    }
                ]
            }
        default:
            throw new Error(`未知资源: ${uri}`)
    }
})

// 提示处理器
server.setRequestHandler(GetPromptRequestSchema, async (request, extra) => {
    const { name, arguments: args } = request.params

    switch (name) {
        case 'code-review':
            return {
                description: '代码审查提示',
                messages: [
                    {
                        role: 'system',
                        content: {
                            type: 'text',
                            text: '你是一个代码审查专家。'
                        }
                    },
                    {
                        role: 'user',
                        content: {
                            type: 'text',
                            text: `请审查以下代码：\n${args.code}`
                        }
                    }
                ]
            }
        default:
            throw new Error(`未知提示: ${name}`)
    }
})
```

#### 常见的 Schema

客户端到服务器请求 Schema (Client → Server)

|            Schema 名称             |      JSON-RPC 方法       |  功能分类   |                   用途说明                    |
| :--------------------------------: | :----------------------: | :---------: | :-------------------------------------------: |
|`InitializeRequestSchema`|`initialize`|  连接管理   |   客户端初始化连接请求，协商协议版本和能力    |
|`PingRequestSchema`|`ping`|  连接管理   |        心跳检测请求，检查连接是否存活         |
|`CompleteRequestSchema`|   completion/complete    |  自动补全   | 请求自动补全选项(用于 prompts/resources 参数) |
|`SetLevelRequestSchema`|     logging/setLevel     |  日志管理   |              设置服务器日志级别               |
|`GetPromptRequestSchema`|       prompts/get        | Prompt 管理 |           获取特定 prompt 模板内容            |
|`ListPromptsRequestSchema`|       prompts/list       | Prompt 管理 |       列出服务器提供的所有 prompt 模板        |
|`ListResourcesRequestSchema`|      resources/list      |  资源管理   |           列出服务器提供的所有资源            |
|`ListResourceTemplatesRequestSchema`| resources/templates/list |  资源管理   |           列出服务器提供的资源模板            |
|`ReadResourceRequestSchema`|      resources/read      |  资源管理   |               读取特定资源内容                |
|`SubscribeRequestSchema`|   resources/subscribe    |  资源管理   |               订阅资源更新通知                |
|`UnsubscribeRequestSchema`|  resources/unsubscribe   |  资源管理   |             取消订阅资源更新通知              |
|`CallToolRequestSchema`|        tools/call        |  工具调用   |             调用服务器提供的工具              |
|`ListToolsRequestSchema`|        tools/list        |  工具管理   |           列出服务器提供的所有工具            |
|`GetTaskRequestSchema`|        tasks/get         |  任务管理   |               获取任务状态信息                |
|`GetTaskPayloadRequestSchema`|       tasks/result       |  任务管理   |               获取任务执行结果                |
|`ListTasksRequestSchema`|        tasks/list        |  任务管理   |                 列出所有任务                  |
|`CancelTaskRequestSchema`|       tasks/cancel       |  任务管理   |                 取消指定任务                  |

服务器到客户端请求 Schema (Server → Client)

|         Schema 名称         |     JSON-RPC 方法      | 功能分类 |              用途说明              |
| :-------------------------: | :--------------------: | :------: | :--------------------------------: |
|`PingRequestSchema`|`ping`| 连接管理 |         心跳检测请求(双向)         |
|`CreateMessageRequestSchema`| sampling/createMessage | LLM 采样 |   服务器请求客户端进行 LLM 推理    |
|`ElicitRequestSchema`|   elicitation/create   | 用户交互 |    服务器请求客户端收集用户输入    |
|`ListRootsRequestSchema`|       roots/list       | 文件系统 | 服务器请求客户端提供可访问的根目录 |
|`GetTaskRequestSchema`|       tasks/get        | 任务管理 |         获取任务状态(双向)         |
|`GetTaskPayloadRequestSchema`|      tasks/result      | 任务管理 |         获取任务结果(双向)         |
|`ListTasksRequestSchema`|       tasks/list       | 任务管理 |           列出任务(双向)           |
|`CancelTaskRequestSchema`|      tasks/cancel      | 任务管理 |           取消任务(双向)           |

## 双向通信

### ping()

向连接的客户端发送ping请求，用于测试连接状态和网络延迟。这是MCP协议中的双向心跳检测机制，服务器可以主动检查客户端的连接健康状况。

```typescript
ping(): Promise<void>
```

**参数**

此方法无需参数。

**返回值**

| 类型 | 描述 |
|------|------|
| `Promise<void>` | 异步操作Promise，客户端响应ping时resolve，连接异常或超时时reject |

**使用场景**

- 定期健康检查
- 连接故障诊断
- 网络质量监控
- 长连接维持

**示例**：

```typescript
// 基本ping测试
try {
    await server.ping()
    console.log('客户端连接正常')
} catch (error) {
    console.error('客户端连接异常:', error)
    // 可能的错误：网络超时、客户端断开、协议错误
}

// 带超时的ping测试
async function pingWithTimeout(timeoutMs = 5000) {
    const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error('Ping超时')), timeoutMs)
    })

    try {
        await Promise.race([
            server.ping(),
            timeoutPromise
        ])
        console.log('客户端响应正常')
        return true
    } catch (error) {
        console.error('Ping失败:', error.message)
        return false
    }
}

// 定期健康检查
async function startHealthCheck() {
    const checkInterval = 30000 // 30秒检查一次

    const healthCheckTimer = setInterval(async () => {
        const isHealthy = await pingWithTimeout(3000)

        if (!isHealthy) {
            console.warn('客户端连接异常，尝试重连...')
            // 实现重连逻辑
            clearInterval(healthCheckTimer)
        } else {
            console.log('连接健康检查通过')
        }
    }, checkInterval)

    // 在服务器关闭时清理定时器
    process.on('SIGTERM', () => {
        clearInterval(healthCheckTimer)
    })
}

// 启动健康检查
startHealthCheck()

// 测量网络延迟
async function measureLatency() {
    const startTime = Date.now()

    try {
        await server.ping()
        const latency = Date.now() - startTime
        console.log(`网络延迟: ${latency}ms`)
        return latency
    } catch (error) {
        console.error('延迟测量失败:', error)
        return -1
    }
}
```

### `createMessage()`

`createMessage`方法允许 MCP Server 主动向客户端请求 LLM（大语言模型）生成内容，实现服务器发起的采样功能。会触发`sampling/createMessage` JSON-RPC消息。

通过这个方法，服务器可以发送消息列表、系统提示、工具定义等参数给客户端，客户端会调用其 LLM 服务（如 Claude、GPT 等）生成响应内容并返回给服务器，从而实现服务器端主动获取 AI 生成内容的能力，这在需要服务器根据业务逻辑动态生成文本、进行智能分析或与用户交互的场景中非常有用。

`createMessage` 方法能够成功调用需要满足以下条件：

1. 客户端必须支持 `sampling` 能力
2. 如果使用工具，客户端必须支持 `tools` 能力

```typescript
createMessage(params: CreateMessageParams, options?: RequestOptions): Promise<CreateMessageResult>
```

**参数**

| 参数名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
|`params`|`CreateMessageParams`| 是 | 消息创建参数配置 |
|`options`|`RequestOptions`| 否 | 请求选项配置 |

**params (CreateMessageParams) 详细字段：**

| 字段名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
|`messages`|`PromptMessage[]`| 是 | 消息列表，包含对话的历史消息 |
|`maxTokens`|`number`| 否 | 最大生成token数，控制响应长度 |
|`temperature`|`number`| 否 | 温度参数，控制生成的随机性，范围0-1 |
|`stopSequences`|`string[]`| 否 | 停止序列，遇到这些字符串时停止生成 |
|`systemPrompt`|`string`| 否 | 系统提示，定义AI的行为和角色 |
|`includeContext`| 'none' \| 'thisServer' \| 'allServers' | 否 | 上下文包含策略 |
|`metadata`|`object`| 否 | 元数据，附加的请求信息 |
|`tools`|`Tool[]`| 否 | 可用工具列表 |
|`toolChoice`| 'auto' \| 'required' \|`object`| 否 | 工具选择策略 |

**messages (PromptMessage[]) 数组元素字段：**

| 字段名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
|`role`| 'user' \| 'assistant' | 是 | 消息发送者角色，user表示人类用户，assistant表示AI助手 |
|`content`|`ContentBlock`| 是 | 消息内容，可以是文本或其他格式 |

**返回值**

| 类型 | 描述 |
|------|------|
| `Promise<CreateMessageResult>` | 异步操作Promise，返回LLM生成的消息结果 |

**CreateMessageResult 详细字段：**

| 字段名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
|`role`| 'assistant' | 是 | 响应角色，总是来自assistant |
|`content`|`object`| 是 | 生成的内容 |
|`content.type`| 'text' \| 'image' | 是 | 内容类型 |
|`content.text`|`string`| 否 | 文本内容（当type为text时） |
|`content.data`|`string`| 否 | 数据内容（当type为image时） |
|`content.mimeType`|`string`| 否 | MIME类型（当type为image时） |
|`model`|`string`| 是 | 使用的LLM模型名称 |
|`stopReason`| 'endTurn' \| 'stopSequence' \| 'maxTokens' \| 'toolUse' | 否 | 停止生成的原因 |

**示例**：

```typescript
// 基本文本生成
const response = await server.createMessage({
    messages: [
        {
            role: 'user',
            content: {
                type: 'text',
                text: '请解释什么是MCP协议'
            }
        }
    ],
    maxTokens: 500,
    temperature: 0.7
})

console.log('生成的内容:', response.content.text)
console.log('使用的模型:', response.model)

// 带工具的对话
const responseWithTools = await server.createMessage({
    messages: [
        {
            role: 'assistant',
            content: {
                type: 'text',
                text: '你是一个代码分析助手，可以使用提供的工具来分析代码。'
            }
        },
        {
            role: 'user',
            content: {
                type: 'text',
                text: '请分析 /path/to/file.js 这个文件'
            }
        }
    ],
    tools: [
        {
            name: 'read-file',
            description: '读取文件内容',
            inputSchema: {
                type: 'object',
                properties: {
                    path: { type: 'string' }
                },
                required: ['path']
            }
        }
    ],
    toolChoice: 'auto',
    maxTokens: 1000
})
```

### elicitInput()

`elicitInput`方法允许 MCP 服务器主动向客户端请求用户输入，支持两种模式：

- 表单模式（form）用于收集结构化数据，通过定义 JSON Schema 来指定需要的字段和验证规则；
- URL模式（url）用于处理需要外部验证的敏感操作，如支付确认或身份验证，服务器会提供一个URL让用户在浏览器中完成操作。

这个方法实现了服务器发起的双向交互，使得服务器可以在执行过程中根据业务需要动态获取用户的输入和确认，而不仅仅是被动响应客户端的请求，特别适用于需要用户参与决策或提供额外信息的复杂工作流程场景。

简而言之，它是服务器主动"询问"用户的机制，让服务器能够在需要时暂停执行并等待用户的输入或确认。**使用前提条件**：客户端必须支持相应的 `elicitation` 能力。

```typescript
elicitInput(params: ElicitationParams, options?: RequestOptions): Promise<ElicitationResult>

interface ElicitationParams {
    mode?: 'form' | 'url' // 引出模式，默认 'form'
    message?: string // 提示消息
    requestedSchema?: object // 请求的数据schema（仅form模式）
    url?: string // 跳转URL（仅url模式）
    elicitationId?: string // 引出标识（仅url模式）
}

interface ElicitationResult {
    action: 'accept' | 'cancel' // 用户操作
    //  accept：用户接受并完成了输入操作
    // cancel：用户取消了输入操作
    content?: any // 用户输入的内容
}
```

**示例**：
```typescript
// 表单模式 - 收集结构化数据
const formResult = await server.elicitInput({
    mode: 'form',
    message: '请提供项目配置信息',
    requestedSchema: {
        type: 'object',
        properties: {
            projectName: {
                type: 'string',
                title: '项目名称',
                description: '项目的显示名称'
            },
            language: {
                type: 'string',
                enum: ['javascript', 'typescript', 'python', 'java'],
                title: '编程语言'
            },
            features: {
                type: 'array',
                items: {
                    type: 'string',
                    enum: ['testing', 'linting', 'formatting', 'documentation']
                },
                title: '启用的功能'
            }
        },
        required: ['projectName', 'language']
    }
})

if (formResult.action === 'accept') {
    console.log('用户输入:', formResult.content)
    // { projectName: 'MyApp', language: 'typescript', features: ['testing', 'linting'] }
} else {
    console.log('用户取消了输入')
}

// URL模式 - 处理敏感操作
import { UrlElicitationRequiredError } from '@modelcontextprotocol/core'

async function handlePayment() {
    // 抛出URL引出错误，客户端会打开指定URL
    throw new UrlElicitationRequiredError([
        {
            mode: 'url',
            message: '请完成支付验证',
            url: 'https://payment.example.com/verify?session=abc123',
            elicitationId: 'payment-verification-123'
        }
    ])
}

// 创建引出完成通知器
const notifier = server.createElicitationCompletionNotifier('payment-verification-123')

// 在支付完成后调用
setTimeout(async () => {
    await notifier() // 通知客户端引出完成
}, 10000)
```

### listRoots()

`listRoots`法允许 MCP 服务器向客户端请求可访问的文件系统根目录列表，这是一个服务器发起的请求，用于发现客户端环境中哪些目录路径是可以被服务器访问和操作的。

客户端必须支持`roots`能力才能响应此请求，返回的结果包含每个根目录的名称和 URI 路径信息。

这个方法主要用于文件操作相关的 MCP 服务器，让服务器能够了解客户端的文件系统边界和权限范围，确保后续的文件读取、写入或其他文件系统操作都在客户端允许的安全范围内进行，避免越权访问客户端的敏感目录。

简而言之，它是服务器用来"探查"客户端文件系统访问权限的方法，为后续的文件操作建立安全边界。

请求客户端的文件系统根目录列表。

```typescript
listRoots(params?: ListRootsParams, options?: RequestOptions): Promise<ListRootsResult>
```

一般情况下会直接调用，不需要参数。

返回值：

- roots：一个数组，包含客户端允许访问的所有根目录
- 每个根目录对象包含：
    - name：用户友好的显示名称（如 "项目目录"、"文档文件夹"）
    - uri：实际的文件系统路径，通常是`file://`协议的 URI 格式

```typescript
{
    roots: [
        {
            name: '项目目录',
            uri: 'file:///Users/username/projects'
        },
        {
            name: '文档文件夹',
            uri: 'file:///Users/username/Documents'
        }
    ]
}
```

示例：

```typescript
try {
    const roots = await server.listRoots()

    console.log('可访问的根目录:')
    roots.roots.forEach(root => {
        console.log(`- ${root.name}: ${root.uri}`)
    })
} catch (error) {
    console.error('获取根目录失败:', error)
}
```

## 日志和通知

### sendLoggingMessage()

向连接的客户端发送日志消息，用于实时传输服务器的运行状态、错误信息和调试数据。这是MCP协议中的日志传输机制，让客户端能够监控服务器的运行情况。

```typescript
sendLoggingMessage(params: LoggingMessageParams, sessionId?: string): Promise<void>
```

**参数**

| 参数名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
|`params`|`LoggingMessageParams`| 是 | 日志消息的具体内容和配置 |
|`sessionId`|`string`| 否 | 目标会话的标识符，用于向特定客户端会话发送日志 |

**params (LoggingMessageParams) 详细字段：**

| 字段名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
|`level`|`LoggingLevel`| 是 | 日志级别，用于分类和过滤 |
|`logger`|`string`| 否 | 日志来源标识，可选的模块或组件名称 |
|`data`|`any`| 是 | 日志数据，可以是任意结构的数据 |

**level (LoggingLevel) 可选值：**

| 级别 | 用途 | 使用场景 |
|------|------|----------|
|`debug`| 调试信息 | 开发阶段的详细执行流程 |
|`info`| 一般信息 | 正常的业务操作记录 |
|`notice`| 重要通知 | 需要注意但非错误的事件 |
|`warning`| 警告信息 | 潜在问题或异常情况 |
|`error`| 错误信息 | 处理失败但可恢复的错误 |
|`critical`| 严重错误 | 影响功能的严重问题 |
|`alert`| 紧急警报 | 需要立即处理的问题 |
|`emergency`| 系统崩溃 | 系统不可用的紧急情况 |

**返回值**

| 类型 | 描述 |
|------|------|
| `Promise<void>` | 异步操作Promise，日志发送成功时resolve，失败时reject |

**作用**

- 向客户端实时传输服务器日志
- 支持多级别的日志分类和过滤
- 提供结构化的日志数据传输
- 支持会话级别的日志隔离

**使用前提条件**

- 服务器必须在初始化时声明`logging`能力
- 客户端必须支持日志接收功能

**示例**：

```typescript
// 基本日志记录
await server.sendLoggingMessage({
    level: 'info',
    logger: 'UserService',
    data: {
        message: '用户登录成功',
        userId: '12345',
        timestamp: new Date().toISOString(),
        ip: '192.168.1.100'
    }
})

// 错误日志记录
await server.sendLoggingMessage({
    level: 'error',
    logger: 'DatabaseManager',
    data: {
        message: '数据库连接失败',
        error: error.message,
        stack: error.stack,
        retryCount: 3,
        connectionString: 'postgresql://localhost:5432/mydb'
    }
})

// 会话特定日志
await server.sendLoggingMessage(
    {
        level: 'warning',
        logger: 'SessionManager',
        data: {
            message: '会话即将过期',
            sessionId: 'session-123',
            expiresIn: '5分钟'
        }
    },
    'session-123' // 仅发送给指定会话
)

// 结构化调试日志
await server.sendLoggingMessage({
    level: 'debug',
    logger: 'ToolExecutor',
    data: {
        message: '工具执行开始',
        toolName: 'file-reader',
        parameters: { path: '/tmp/data.txt' },
        executionId: 'exec-789',
        startTime: Date.now()
    }
})

// 性能监控日志
await server.sendLoggingMessage({
    level: 'notice',
    logger: 'PerformanceMonitor',
    data: {
        message: '请求处理完成',
        method: 'tools/call',
        duration: 1250, // 毫秒
        memoryUsage: process.memoryUsage(),
        cpuUsage: process.cpuUsage()
    }
})
```

### 列表变更通知方法

这些方法用于向客户端发送各种列表变更的通知，让客户端能够及时更新其缓存的列表信息。

#### sendResourceUpdated()

通知客户端特定资源已更新，触发客户端重新获取该资源的内容。

```typescript
sendResourceUpdated(params: { uri: string }, sessionId?: string): Promise<void>
```

**参数**

| 参数名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
|`params`|`object`| 是 | 资源更新参数 |
|`params.uri`|`string`| 是 | 已更新资源的URI标识 |
|`sessionId`|`string`| 否 | 可选的目标会话ID |

**返回值**

| 类型 | 描述 |
|------|------|
| `Promise<void>` | 异步操作Promise，通知发送成功时resolve，失败时reject |

**作用**

- 通知客户端特定资源内容已变更
- 触发客户端重新读取资源
- 支持实时资源同步

**使用前提条件**：服务器必须声明`resources.subscribe`能力

#### sendResourceListChanged()

通知客户端资源列表已发生变更（添加、删除或修改资源）。

```typescript
sendResourceListChanged(sessionId?: string): Promise<void>
```

**参数**

| 参数名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
|`sessionId`|`string`| 否 | 可选的目标会话ID |

**返回值**

| 类型 | 描述 |
|------|------|
| `Promise<void>` | 异步操作Promise，通知发送成功时resolve，失败时reject |

**作用**

- 通知客户端重新获取资源列表
- 用于资源动态添加或删除场景
- 保持客户端资源列表同步

**使用前提条件**：服务器必须声明`resources.listChanged`能力

#### sendToolListChanged()

通知客户端工具列表已发生变更（添加、删除或修改工具）。

```typescript
sendToolListChanged(sessionId?: string): Promise<void>
```

**参数**

| 参数名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
|`sessionId`|`string`| 否 | 可选的目标会话ID |

**返回值**

| 类型 | 描述 |
|------|------|
| `Promise<void>` | 异步操作Promise，通知发送成功时resolve，失败时reject |

**作用**

- 通知客户端重新获取工具列表
- 用于工具动态注册或注销场景
- 保持客户端工具列表同步

**使用前提条件**：服务器必须声明`tools.listChanged`能力

#### sendPromptListChanged()

通知客户端提示列表已发生变更（添加、删除或修改提示模板）。

```typescript
sendPromptListChanged(sessionId?: string): Promise<void>
```

**参数**

| 参数名 | 类型 | 必填 | 描述 |
|--------|------|------|------|
|`sessionId`|`string`| 否 | 可选的目标会话ID |

**返回值**

| 类型 | 描述 |
|------|------|
| `Promise<void>` | 异步操作Promise，通知发送成功时resolve，失败时reject |

**作用**

- 通知客户端重新获取提示列表
- 用于提示模板动态管理场景
- 保持客户端提示列表同步

**使用前提条件**：服务器必须声明`prompts.listChanged`能力

#### 完整示例

```typescript
// 正确的服务器配置
const server = new Server(
    {
        name: 'notification-server',
        version: '1.0.0'
    },
    {
        capabilities: {
            tools: { listChanged: true },      // 支持工具列表变更通知
            resources: {
                listChanged: true,             // 支持资源列表变更通知
                subscribe: true                // 支持资源订阅通知
            },
            prompts: { listChanged: true },    // 支持提示列表变更通知
            logging: {}
        }
    }
)

// 连接传输层
await server.connect(transport)

// 动态资源管理示例
class ResourceManager {
    private resources = new Map<string, any>()

    async addResource(uri: string, content: any) {
        this.resources.set(uri, content)

        // 通知客户端资源列表已变更
        await server.sendResourceListChanged()
        console.log(`资源已添加: ${uri}`)
    }

    async updateResource(uri: string, content: any) {
        if (this.resources.has(uri)) {
            this.resources.set(uri, content)

            // 通知客户端特定资源已更新
            await server.sendResourceUpdated({ uri })
            console.log(`资源已更新: ${uri}`)
        }
    }

    async removeResource(uri: string) {
        if (this.resources.delete(uri)) {
            // 通知客户端资源列表已变更
            await server.sendResourceListChanged()
            console.log(`资源已删除: ${uri}`)
        }
    }
}

// 动态工具管理示例
class ToolManager {
    private tools = new Map<string, any>()

    async registerTool(name: string, config: any) {
        this.tools.set(name, config)

        // 通知客户端工具列表已变更
        await server.sendToolListChanged()
        console.log(`工具已注册: ${name}`)
    }

    async unregisterTool(name: string) {
        if (this.tools.delete(name)) {
            // 通知客户端工具列表已变更
            await server.sendToolListChanged()
            console.log(`工具已注销: ${name}`)
        }
    }
}

// 使用示例
const resourceManager = new ResourceManager()
const toolManager = new ToolManager()

// 动态添加资源
await resourceManager.addResource(
    'file:///tmp/config.json',
    { setting1: 'value1', setting2: 'value2' }
)

// 更新资源内容
await resourceManager.updateResource(
    'file:///tmp/config.json',
    { setting1: 'updated_value1', setting2: 'value2' }
)

// 动态注册工具
await toolManager.registerTool('new-calculator', {
    description: '新的计算器工具',
    inputSchema: { expression: 'string' }
})

// 会话特定通知
await server.sendResourceListChanged('session-123')  // 仅通知特定会话

// 批量通知示例
async function performBatchUpdate() {
    // 执行多个资源更新
    await resourceManager.updateResource('resource1', 'content1')
    await resourceManager.updateResource('resource2', 'content2')
    await resourceManager.updateResource('resource3', 'content3')

    // 只发送一次列表变更通知（优化性能）
    await server.sendResourceListChanged()
    console.log('批量更新完成')
}
```

### createElicitationCompletionNotifier()

当服务器通过`elicitInput`方法以 URL 模式请求用户进行外部操作（如支付验证、身份认证等）时，用户会被重定向到外部网站完成操作，而服务器无法直接知道用户何时完成了这些操作。

此方法通过`elicitationId`创建一个异步通知器，当外部系统（通常通过`webhook`回调或其他异步机制）确认用户完成了所需操作后，服务器可以调用这个通知器来告知客户端操作已完成，从而恢复被暂停的工作流程。这是 MCP 协议中处理异步用户交互的重要机制，确保了复杂的多步骤操作能够正确协调和完成。

简而言之，它是服务器用来"通知"客户端外部用户操作已完成的异步回调机制。

创建引出完成通知器，用于URL模式的引出操作。

```typescript
createElicitationCompletionNotifier(elicitationId: string, options?: NotificationOptions): () => Promise<void>
```

**参数**：

- `elicitationId` - 标识
- `options` - 通知选项

**返回值**：通知函数

**示例**：

```typescript
import { Server } from '@modelcontextprotocol/server'
import { CallToolRequestSchema, UrlElicitationRequiredError } from '@modelcontextprotocol/core'

const server = new Server({
    name: 'payment-server',
    version: '1.0.0'
})

// 存储通知器的映射
const notifiers = new Map<string, () => Promise<void>>()

// 注册工具处理器 - 需要用户验证的支付操作
server.setRequestHandler(CallToolRequestSchema, async (request, extra) => {
    if (request.params.name === 'process-payment') {
        const elicitationId = `payment-${Date.now()}`

        // 创建完成通知器
        const notifier = server.createElicitationCompletionNotifier(elicitationId)

        // 存储通知器以便后续调用
        notifiers.set(elicitationId, notifier)

        // 抛出URL引出错误，让用户去外部网站完成支付
        throw new UrlElicitationRequiredError([
            {
                mode: 'url',
                message: '请完成支付验证',
                url: `https://payment.example.com/verify?id=${elicitationId}`,
                elicitationId
            }
        ])
    }

    return { content: [{ type: 'text', text: '未知工具' }] }
})

// 模拟外部支付系统的webhook回调
// 在实际应用中，这通常是一个HTTP端点
async function onVerificationComplete(elicitationId: string) {
    console.log(`收到验证完成通知: ${elicitationId}`)

    // 获取对应的通知器
    const notifier = notifiers.get(elicitationId)

    if (notifier) {
        try {
            // 调用通知器，告知客户端验证已完成
            await notifier()
            console.log('验证完成通知已发送给客户端')

            // 清理通知器
            notifiers.delete(elicitationId)
        } catch (error) {
            console.error('发送通知失败:', error)
        }
    } else {
        console.error(`未找到对应的通知器: ${elicitationId}`)
    }
}

// 模拟外部支付完成后的回调
setTimeout(() => {
    // 假设3秒后支付完成
    onVerificationComplete('payment-1642123456789')
}, 3000)
```


## Server 与 McpServer 对比

### API 层次对比

| 特性           | Server（底层 API）             | McpServer（高级 API）  |
| -------------- | ------------------------------ | ---------------------- |
| **控制程度**   | 完全控制，手动处理所有协议细节 | 自动化处理，简化接口   |
| **开发复杂度** | 高，需要深入理解协议           | 低，开箱即用           |
| **代码量**     | 多，需要手动实现路由和验证     | 少，一行代码完成注册   |
| **灵活性**     | 极高，可自定义任何行为         | 中等，受限于预定义模式 |
| **性能**       | 最优，无额外抽象层             | 良好，有轻微抽象开销   |
| **类型安全**   | 手动保证                       | 自动保证               |
| **错误处理**   | 手动实现                       | 自动统一处理           |
| **调试难度**   | 低，完全透明                   | 中等，内部逻辑不透明   |

### 功能实现对比

| 功能             | Server 实现方式                                                     | McpServer 实现方式                        |
| ---------------- | ------------------------------------------------------------------- | ----------------------------------------- |
| **工具注册**     | 手动设置 `ListToolsRequestSchema` 和 `CallToolRequestSchema` 处理器 | `registerTool()` 或 `tool()` 方法         |
| **资源注册**     | 手动设置多个资源相关处理器                                          | `registerResource()` 或 `resource()` 方法 |
| **提示注册**     | 手动设置提示相关处理器                                              | `registerPrompt()` 或 `prompt()` 方法     |
| **能力声明**     | 手动调用 `registerCapabilities()`                                   | 自动注册相关能力                          |
| **参数验证**     | 手动使用 Zod 验证                                                   | 自动验证输入输出                          |
| **错误处理**     | 手动捕获和转换错误                                                  | 自动包装为 MCP 错误                       |
| **列表变更通知** | 手动调用 `sendToolListChanged()`                                       | 自动发送通知                              |
| **状态管理**     | 手动维护注册状态                                                    | 内置状态管理（启用/禁用/更新）            |

### 工具注册对比

Server（底层 API）：

```typescript
// 需要手动管理工具注册表
const registeredTools = new Map()

// 手动设置工具列表处理器
server.setRequestHandler(ListToolsRequestSchema, async () => {
    return {
        tools: Array.from(registeredTools.values()).map(tool => ({
            name: tool.name,
            description: tool.description,
            inputSchema: zodToJsonSchema(tool.inputSchema)
        }))
    }
})

// 手动设置工具调用处理器
server.setRequestHandler(CallToolRequestSchema, async (request, extra) => {
    const { name, arguments: args } = request.params
    const tool = registeredTools.get(name)

    if (!tool) {
        throw new McpError(ErrorCode.MethodNotFound, `Unknown tool: ${name}`)
    }

    // 手动验证参数
    const validatedArgs = tool.inputSchema.parse(args)

    try {
        const result = await tool.handler(validatedArgs, extra)
        return result
    } catch (error) {
        throw new McpError(ErrorCode.InternalError, error.message)
    }
})

// 手动注册工具
registeredTools.set('echo', {
    name: 'echo',
    description: '回显工具',
    inputSchema: z.object({ message: z.string() }),
    handler: async ({ message }) => ({
        content: [{ type: 'text', text: `回显: ${message}` }]
    })
})

// 手动注册能力
server.registerCapabilities({
    tools: { listChanged: true }
})
```

McpServer（高级 API）：

```typescript
// 一行代码完成工具注册
mcpServer.registerTool(
    'echo',
    {
        description: '回显工具',
        inputSchema: { message: z.string() }
    },
    async ({ message }) => ({
        content: [{ type: 'text', text: `回显: ${message}` }]
    })
)
// 自动处理：协议路由、参数验证、能力注册、错误处理
```

### 使用场景建议

| 场景              | 推荐 API  | 理由                       |
| ----------------- | --------- | -------------------------- |
| **快速原型开发**  |`McpServer`| 开发效率高，快速验证想法   |
| **标准 MCP 功能** |`McpServer`| 内置最佳实践，降低出错概率 |
| **团队协作项目**  |`McpServer`| 学习曲线平缓，代码一致性好 |
| **复杂业务逻辑**  |`Server`| 完全控制，可实现任意逻辑   |
| **性能关键应用**  |`Server`| 无抽象层开销，最优性能     |
| **协议扩展开发**  |`Server`| 访问完整协议功能           |
| **深度定制需求**  |`Server`| 可自定义所有行为           |
| **调试协议问题**  |`Server`| 完全透明，便于调试         |
| **学习 MCP 协议** |`Server`| 深入理解协议细节           |

### 混合使用策略

```typescript
// 创建 McpServer 实例
const mcpServer = new McpServer(serverInfo, options)

// 标准功能使用高级 API
mcpServer.registerTool('calculator', config, handler)
mcpServer.registerResource('config', uri, config, handler)

// 特殊需求使用底层 API
mcpServer.server.setRequestHandler(CustomRequestSchema, async (request, extra) => {
    // 自定义协议处理
    return await handleCustomRequest(request, extra)
})

// 覆盖默认行为（高级用法）
mcpServer.server.setRequestHandler(CallToolRequestSchema, async (request, extra) => {
    // 自定义工具调用逻辑
    // 仍可访问 mcpServer._registeredTools
    const tool = mcpServer._registeredTools[request.params.name]

    // 添加自定义前置处理
    await customPreProcessing(request, extra)

    // 调用原始处理逻辑或自定义处理
    const result = await tool.handler(request.params.arguments, extra)

    // 添加自定义后置处理
    await customPostProcessing(result, extra)

    return result
})
```
