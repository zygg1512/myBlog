
# 单元测试和集成测试
近几年，前端发展越来越迅猛，各类框架层出不穷，前端实现的业务逻辑也越来越复杂，前端单元测试也越来越受重视。那么前端应该如何做好单元测试？
## 单元测试
### 什么是单元测试
#### 单测的定义
来自维基百科的定义：
> 在计算机编程中，单元测试（Unit Testing）又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。

程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。

定义里面指出，单元测试针对的是程序的最小单元，因此我们应该针对最小单元来写单测。
#### 单测完善程度的衡量
单测完善程度用覆盖率来衡量

关于测试覆盖率，我们大致了解下以下几个常见的计算维度：

- 行覆盖率：可执行语句执行的比例
- 函数覆盖率：函数被调用的比例
- 分支覆盖率：判断语句分支被执行的比例

来看下面这个例子：
```javascript
function foo(a){
  if(a < 5) a+= 2
  return a + 3
}
```
对于`foo(4)`来说：

- 行覆盖率：100%
- 函数覆盖率：100%
- 分支覆盖率：50%

对于测试用例`foo(4)`，分支覆盖率只有`50%`，原因是`foo(4)`只测试了`if`为`true`的情况，没有测试到`if`为`false`的情况。

如果想要分支覆盖率达到100%，还应该测试`foo(5)`
### 为什么需要单测
#### 现状与问题

- 缺乏意识：没有单测意识，很多代码没有单测
- 缺乏设计：模块缺乏设计，相互耦合，写单测困难
- 测试困难：升级公共 API，人工测试验证困难
- 测试不全面：部分代码分支众多，人工测试没办法覆盖所有分支
#### 单测的价值与意义

- 能力建设：一个具备开发经验的开发人员，基本上都会编写单元测试。即便不会，可以通过培训来快速达成。从学习曲线上看，单元测试很容易上手。
- 提升效率：能够通过 mock 数据，及早发现问题，而越早发现Bug，造成的浪费就会越小。
- 追求卓越：单元测试可以充当一个设计工具，它有助于开发人员去思考代码结构的设计，让代码更加有利于测试。
- 测试更全面：能够覆盖 QA 测试覆盖不到的情况，比如各种 if 分支、异常处理。
- 更有信心：升级公共 API 时，如果依赖这个 API 的所有代码单测都能通过，那我们对这次代码升级是更有信心的。
### 怎样写单测
#### 单测的原则：FIRST

<img height="300px" src="https://github.com/zygg1512/myBlog/raw/master/images/自动化测试/单测的原则.png" />

#### 单测需要测什么：RIGHT BICEP!
<img height="300px" src="https://github.com/zygg1512/myBlog/raw/master/images/自动化测试/单测需要测什么.png" />

##### 结果正确
这个是最基本的检查，如果单测的运行结果都不正确，那其他的都免谈。
##### 边界条件检查
边界检查尤为重要，很多错误都是发生在边界上。边界检查遵循 CORRECT

<img height="300px" src="https://github.com/zygg1512/myBlog/raw/master/images/自动化测试/边界条件检查.webp" />

- 有序性：如果一组值是有序的，那么在向其中删除或者添加时，需要校验这组值是否仍然是有序的
- 引用/耦合性：对于类的状态、其他对象的状态等需要做一些假设，程序员就需要对代码进行测试，保证在假设未满足的情况下运行良好。
- 存在性：当数据不存在的时候，程序是否运行良好，例如null，空字符串等
- 基数性：这里的基数主要强调的是计数，考虑以“0-1-N 原则”，当数值分别为0、1、N 时，可能出现的结果，其中N 为最大值。
- 时间性：要充分考虑与时间相关的问题，涉及到并发、异步、超时等这些情况需要特别注意，所有事情的发生时间是否在预期范围内。
##### 反向关联检查

- 例：对于加密算法，使用解密算法反向检查其输出，验证解密后明文是否正确。
- 例：对于写操作API，使用读操作API来反向检查验证
##### 交叉检查

- 例： 对性能优化的算法，使用性能差但验证过的算法交叉检查 
##### 强制错误条件发生

- 例： Mock依赖系统不可用 或者 Mock系统时间错误
- 例：甚至可以直接throw error，来验证程序对错误的处理
##### 满足性能要求
当某个程序升级的时候，是否会对性能造成影响？这需要我们对程序的性能进行测试
## 集成测试
### 写单测的时机
写单测的时机主要有以下三种，大家可以根据自己的实际情况来进行选择。
#### 具体实现代码之前（TDD）
即测试驱动开发（TDD）：编写某个功能的代码之前先编写测试代码，然后编写使测试通过的功能代码，重复这个过程，通过测试来推动整个开发的进行。

特点：UT 能够更好的实践我们的代码设计。对于某些复杂度较高的接口（甚至是一些私有方法），建议使用 TDD 进行开发。
##### TDD开发流程（Red-Creen Development）

1. 编写测试用例
2. 运行测试，测试用例无法通过测试
3. 编写代码，使测试用例通过
4. 优化代码，完成开发
5. 当需要开发新需求新功能时，重复上述步骤

<img height="300px" src="https://github.com/zygg1512/myBlog/raw/master/images/自动化测试/TDD开发流程.png" />

##### TDD的优势

1. 长期减少回归BUG
2. 代码质量更好（组织、可维护性）
3. 测试覆盖率高
4. 错误测试代码不容易出现
##### TDD的缺点

- 安全感低
- 测试用例和代码耦合性较高。当修改代码后，可能需要修改多个测试用例
#### 与具体实现代码同步进行
先写少量功能代码，紧接着写单元测试（重复这两个过程，直到完成功能代码开发）。

特点：每个单测比较简单易懂，可读性可维护性都比较好（重构时单测的改动不大）。
#### 编写完功能代码后（BDD）
BDD（Behavior Driven Developmen）也叫行为驱动开发。这种单元测试“粒度”会比较粗。对同样的功能代码，采取前两种方案的结果可能是用10个“小”的单测来覆盖，而这种方案写的单测，往往是用1个“大”的单测来覆盖。

特点：逻辑就比较复杂，因为它要测的东西很多，可读性可维护性可能会比较差。
##### BDD开发流程

1. 编写业务代码
2. 根据用户行为编写测试用例
3. 使测试用例通过
4. 重复上述步骤
##### BDD优势

1. 开发效率和速度会高很多。先写代码再写测试，不会影响业务进度
2. 测试用例和代码耦合性比较小。重新编写代码后，需修改的测试用例不会特别多
3. 使业务逻辑更加可靠。当测试用例通过后，基本可以确定面向用户的操作也会成功
##### BDD缺点

- 测试覆盖率低
### BDD和TDD开发流程区别
| TDD | BDD |
| --- | --- |
| 先写测试再写代码 | 先写代码再写测试 |
| 一般结合单元测试使用，是白盒测试 | 一般结合集成测试使用，是黑盒测试 |
| 代码是测试重点 | UI（DOM）是测试重点 |

### 集成测试插件
[介绍 | Vue Test Utils](https://v1.test-utils.vuejs.org/zh/)

