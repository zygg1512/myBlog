# Yarn
## 概述
`yarn` 是在 `2016` 年发布的，那时 `npm` 还处于 `V3` 时期，还没有 `package-lock.json` 文件，不稳定性、安装速度慢等缺点经常会受到广大开发者吐槽。此时，`yarn` 诞生。

尽管 npm 发展至今，已经在很多方面向 yarn 看齐，但 yarn 的安装理念仍然需要我们关注。yarn 提出的安装理念很好的解决了当时 npm 的依赖管理问题，yarn有以下优点：
1.  **速度快** 。速度快主要来自以下两个方面： 
    1. 并行安装：无论 npm 还是 Yarn 在执行包的安装时，都会执行一系列任务。npm 是按照队列执行每个 package，也就是说必须要等到当前 package 安装完成之后，才能继续后面的安装。而 Yarn 是同步执行所有任务，提高了性能。
    2. 离线模式：如果之前已经安装过一个软件包，用 Yarn 再次安装时会从缓存中获取，npm5.x 之后也有缓存但是读取速度不如 Yarn。
2.  **版本统一**：为了防止拉取到不同的版本，Yarn 有一个锁定文件 (lock file) 记录了被确切安装上的模块的版本号。每次只要新增了一个模块，Yarn 就会创建（或更新）`yarn.lock`这个文件。npm5.x 之后也有了锁定文件，但是策略和Yarn略有差异，后面会说。
3.  **更简洁的输出**：npm 的输出信息比较冗长。在执行 npm install 的时候，命令行里会不断地打印出所有被安装上的依赖。相比之下，Yarn 简洁太多：默认情况下，结合了 emoji 直观且直接地打印出必要的信息，也提供了一些命令供开发者查询额外的安装信息。
4.  **更好的语义化**： Yarn 改变了一些 npm 命令的名称，比如 yarn add/remove，感觉上比 npm 原本的 install/uninstall 要更清晰。

## yarn.lock
`yarn.lock`中会准确的存储每个依赖的具体版本信息，以保证在不同机器安装可以得到相同的目录结构。
```yml
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY. 
# yarn lockfile v1 
expect-jsx@^5.0.0: 
 version "5.0.0" 
 resolved "[http://registry.npmjs.org/expect-jsx/-/expect-jsx-5.0.0.tgz#61761b43365f285a80eb280c785e0783bbe362c7](http://registry.npmjs.org/expect-jsx/-/expect-jsx-5.0.0.tgz#61761b43365f285a80eb280c785e0783bbe362c7 "http://registry.npmjs.org/expect-jsx/-/expect-jsx-5.0.0.tgz#61761b43365f285a80eb280c785e0783bbe362c7")" 
 integrity sha1-YXYbQzZfKFqA6ygMeF4Hg7vjYsc= 
 dependencies: 
 collapse-white-space "^1.0.0" 
react "^16.0.0"
 react-element-to-jsx-string "^13.0.0" 
react-rater@^6.0.0: 
 version "6.0.0" 
 resolved "[http://registry.npmjs.org/react-rater/-/react-rater-6.0.0.tgz#2e666b6e5e5c33b622541df6a7124f6c99606927](http://registry.npmjs.org/react-rater/-/react-rater-6.0.0.tgz#2e666b6e5e5c33b622541df6a7124f6c99606927 "http://registry.npmjs.org/react-rater/-/react-rater-6.0.0.tgz#2e666b6e5e5c33b622541df6a7124f6c99606927")" 
 integrity sha512-NP1+rEeL3LyJqA5xF7U2fSHpISMcVeMgbQ0u/P1WmayiHccI7Ixx5GohygmJY82g7SxdJnIun2OOB6z8WTExmg== 
 dependencies: 
 prop-types "^15.7.2" 
 react "^16.8.0"
 react-dom "^16.8.0" 
// 这里
react@^16.0.0, react@^16.8.0:
version "16.14.0"
 resolved "[http://registry.npmjs.org/react/-/react-16.14.0.tgz#94d776ddd0aaa37da3eda8fc5b6b18a4c9a3114d](http://registry.npmjs.org/react/-/react-16.14.0.tgz#94d776ddd0aaa37da3eda8fc5b6b18a4c9a3114d "http://registry.npmjs.org/react/-/react-16.14.0.tgz#94d776ddd0aaa37da3eda8fc5b6b18a4c9a3114d")" 
 integrity sha512-0X2CImDkJGApiAlcf0ODKIneSwBPhqJawOa5wCtKbu7ZECrmS26NvtSILynQ66cgkT/RJ4LidJOc3bUESwmU8g== 
 dependencies: 
 loose-envify "^1.1.0" 
 object-assign "^4.1.1" 
 prop-types "^15.6.2" 
 // 这里
react@^17.0.1:
version "17.0.2"
 resolved "[http://registry.npmjs.org/react/-/react-17.0.2.tgz#d0b5cc516d29eb3eee383f75b62864cfb6800037](http://registry.npmjs.org/react/-/react-17.0.2.tgz#d0b5cc516d29eb3eee383f75b62864cfb6800037 "http://registry.npmjs.org/react/-/react-17.0.2.tgz#d0b5cc516d29eb3eee383f75b62864cfb6800037")" 
 integrity sha512-gnhPt75i/dq/z3/6q/0asP78D0u592D5L1pd7M8P+dck6Fu/jJeL6iVVK23fptSUZj8Vjf++7wXA8UNclGQcbA== 
 dependencies: 
 loose-envify "^1.1.0" 
 object-assign "^4.1.1"
```
从上面依赖版本描述的信息中，可以确定以下几点：
1. 所有依赖，不管是项目声明的依赖，还是依赖的依赖，都是 **扁平化管理**。
2. 如果安装的依赖有多个版本，将同名依赖基于版本限制规则（`^`、`~`）划分版本区间，将相同区间的同名依赖归为一类，并安装最终版本。如：
   1. `react@^16.0.0, react@^16.8.0`会被归为一类，并基于`^`规则安装`16.14.0`。
   2. `react@^17.0.1`作为单独一类，基于`^`规则安装`17.0.2`。
4. 每个依赖确定的版本中，是由以下几项构成： 
   1. 第一行是 name 和语义化版本号，这些都来自`package.json`中的定义。
   2. `version`字段，记录的是一个确切的版本。
   3. `resolved`字段记录的是包的 URL 地址。
   4. `integrity`：hash 值，用于检验包的完整性和时效性。
   5. `dependencies`字段记录的是当前包的依赖，即当前包在`package.json`的`dependencies`字段中的所有依赖

`Yarn` 在安装期间，只会使用当前项目的`yarn.lock`文件（即 顶级`yarn.lock`文件），会忽略任何依赖里面的`yarn.lock`文件。在顶级`yarn.lock`中包含需要锁定的整个依赖树里全部包版本的所有信息。

## Yarn 安装依赖流程
**1、检查（checking）** 主要是检查项目中是否存在一些 npm 相关的配置文件。

如 package-lock.json 等。如果存在，可能会警告提示，因为它们可能会存在冲突。在这一阶段，也会检查系统 OS、CPU 等信息。

**2、解析包（resolving packages）** 这一步主要是解析依赖树，确定版本信息等。

首先获取项目`package.json`中声明的首层依赖，包括 dependencies, devDependencies, optionalDependencies 声明的依赖。

接着采用遍历首层依赖的方式获取依赖包的版本信息，以及递归查找每个依赖下嵌套依赖的版本信息，并将解析过和正在解析的包用一个 Set 数据结构来存储，这样就能保证同一个版本范围内的包不会被重复解析。
- 对于没有解析过的包，首次尝试从`yarn.lock`中获取到版本信息，并标记为已解析。
- 如果在`yarn.lock`中没有找到包，则向远程发起请求获取满足版本范围的已知最高版本的包信息，获取后将当前包标记为已解析。

总之，在经过复杂的解析算法后，我们就确定了所有依赖的具体版本信息以及下载地址。

**3、获取包（fetching packages）** 这一步主要是利用系统缓存，到缓存中找到具体的包资源。首先会尝试在缓存中查找依赖包，如果没有命中缓存，则将依赖包下载到缓存中。对于没有命中缓存的包，Yarn 会维护一个 fetch 队列，按照规则进行网络请求。这里也是 yarn 诞生之初解决 npm v3 安装缓慢问题的优化点，支持并行下载。

**4、链接包（linking dependencies）** 这一步主要是将缓存中的依赖，复制到项目目录下，同时遵循扁平化原则。前面说到，Yarn 优先将依赖安装到项目目录，因此需要将全局缓存中的依赖复制到项目。在复制依赖前，Yarn 会先解析 peerDependencies，如果找不到符合 peerDependencies 声明的依赖版本，则进行 warning 提示（这并不会影响命令执行），并最终拷贝依赖到项目中。

**5、构建包（building fresh package）** 如果依赖包中存在二进制包需要进行编译，会在这一步进行。

简单点说就是
1. 将依赖包的版本区间解析为某个具体的版本号
2. 下载对应版本依赖的 tar 包到本地离线镜像
3. 将依赖从离线镜像解压到本地缓存
4. 将依赖从缓存拷贝到当前目录的 node_modules 目录

首次执行`yarn install`安装，会按照`package.json`中的版本号，去向远程查询，并获取到符合版本规则的最新的依赖包进行下载，并构建依赖关系树。比如在`package.json`中指定 vue 的版本为`^2.0.0`，就会获取符合`2.x.x`的最高版本的包。然后自动生成`yarn.lock`文件，并生成缓存。

之后再执行`yarn install`，会对比`package.json`中依赖版本范围和`yarn.lock`中版本号是否匹配。

1. 版本号匹配，会根据`yarn.lock`中的`resolved`字段去查看缓存。如果有缓存，直接复制；没有缓存则按照`resolved`字段的 url 去下载包。
2. 版本号不匹配，根据`package.json`中的版本范围去远程查询，下载符合版本规则最新的包，并更新至`yarn.lock`中。

### 如何判断有没有命中缓存？
判断系统中是否存在符合 "**cachefolder+slug+node_modules+pkg.name**" 规则的路径，如果存在则判断为命中缓存，否则就会重新下载。值得注意的是，不同版本的包在缓存中是扁平化管理。可以通过`yarn cache dir`查看。

## npm 和 Yarn
**相同点：**
1. `package.json`作为项目依赖描述文件。
2. `node_modules`作为依赖存储目录，Yarn v2 不再是这样。
3. `lockfile`锁定版本依赖，在 Yarn 中叫`yarn.lock`，在 npm 中叫`package-lock.json`，在 npm v7 也支持了`yarn.lock`。它确保在不同机器或不同环境中，能够得到稳定的`node_modules`目录结构。

**差异：**
1. 依赖管理策略。 
   - 生成`package-lock.json`后，如果手动修改`package.json`中的版本，重新执行`npm install`会根据第一章说的那种策略去修改。
   - 而 Yarn 在执行前是先对比了一遍`package.json`和`yarn.lock`中的版本，如果版本范围完全不符的话会重新安装并更新`yarn.lock`
2. `package-lock.json`自带版本锁定+依赖结构，你想改动一些依赖，可能影响的范围要比表面看起来的复杂的多；而`yarn.lock`自带版本锁定，并没有确定的依赖结构，使用 Yarn 管理项目依赖，需要`package.json + yarn.lock`共同确定依赖的结构。 
3.  目前 npm v7 优化了缓存和下载网络策略，性能的差异在缩小。 

## yarn 常用命令
```bash
## npm install
yarn
## 重新拉取所有包，即使之前已经安装的（所以以后别在删除node-modules了...） 
yarn install --force
## 为 node_modules 目录指定另一位置，代替默认的 ./node_modules 
yarn install --modules-folder <path>
## 不读取或生成 yarn.lock 文件
yarn install --no-lockfile
## 只安装 dependence下的包，不安装 devDependencies 的包
yarn install --production[=true|false] / --production / --prod
## 会安装 latest 最新版本
yarn add package-name
## 安装包到dependencies中 
yarn add <package...>
## 用 --dev 或 -D 安装包到 devDependencies
yarn add <package...> [--dev/-D]
## 用 --peer 或者 -P 安装包到 peerDependencies
yarn add <package...> [--peer/-P]
## 用 --optional 或者 -O 安装包到 optionalDependencies
yarn add <package...> [--optional/-O]
## 用 --exact 或者 -E 会安装包的精确版本
yarn add <package...> [--exact/-E]
## 删除指定包
yarn remove package-name
```

## yarn缺点
和 npm 一样存在如下问题：
- 扁平化算法本身的**复杂性**很高，耗时较长
- 项目中仍然可以**非法访问**没有声明过依赖的包
## 关于 yarn 的 PnP
> Yarn 1.12+ 版本

### Yarn 现状与痛点
Yarn 团队开发 PnP 特性最直接的原因就是现有的依赖管理方式效率太低。引用依赖时慢，安装依赖时也慢。

先说说 Node 在处理依赖引用时的逻辑，这个流程会有如下两种情况：
- 如果我们传给`require()`调用的参数是一个[核心模块](https://nodejs.org/api/modules.html#modules_core_modules)（例如 “fs”、”path”等）或者是一个本地相对路径（例如`./module-a.js`或`/my-li/module-b.js`），那么 Node 会直接使用对应的文件。
- 如果不是前面描述的情况，那么 Node 会开始寻找`node_modules`目录： 
   1. 首先 Node 会在当前目录寻找`node_modules`，如果没有则到父目录查找，以此类推直到系统根目录。
   2. 找到`node_modules`目录之后，再在该目录中寻找名为`moduleName.js`的文件或是名为`moduleName`的子目录。

可见 Node 在解析依赖时需要进行大量的文件 I/O 操作，效率并不高。

再来看看安装依赖时发生了什么，现阶段`yarn install`操作会执行以下 4 个步骤：
1. 将依赖包的版本区间解析为某个具体的版本号
2. 下载对应版本依赖的 tar 包到本地离线镜像
3. 将依赖从离线镜像解压到本地缓存
4. 将依赖从缓存拷贝到当前目录的`node_modules`目录

其中第 4 步同样涉及大量的文件 I/O，导致安装依赖时效率不高（尤其是在 CI 环境，每次都需要安装全部依赖）。

### 实现方案
PnP 的具体工作原理是，作为把依赖从缓存拷贝到`node_modules`的替代方案，Yarn 会维护一张静态映射表，该表中包含了以下信息：
- 当前依赖树中包含了哪些依赖包的哪些版本
- 这些依赖包是如何互相关联的
- 这些依赖包在文件系统中的具体位置

这个映射表在 Yarn 的 PnP 实现中对应项目目录中的`.pnp.js`文件。

这个`.pnp.js`文件是如何生成，Yarn 又是如何利用它的呢？

在安装依赖时，在第 3 步完成之后，Yarn 并不会拷贝依赖到`node_modules`目录，而是会在`.pnp.js`中记录下该依赖在缓存中的具体位置。这样就避免了大量的 I/O 操作同时项目目录也不会有`node_modules`目录生成。

同时`.pnp.js`还包含了一个特殊的 resolver，Yarn 会利用这个特殊的 resolver 来处理`require()`请求，该 resolver 会根据`.pnp.js`文件中包含的静态映射表直接确定依赖在文件系统中的具体位置，从而避免了现有实现在处理依赖引用时的 I/O 操作。

### 带来了哪些好处
从 PnP 的实现方案可以看出，同一个系统上不同项目引用的相同依赖的相同版本实际都是指向的缓存中的同一个目录。这带来了几个最直观的好处：
- 安装依赖的速度得到了空前的提升
- CI 环境中多个 CI 实例可以共享同一份缓存
- 同一个系统中的多个项目不再需要占用多份磁盘空间

### 使用 PnP
只需在项目中执行下面命令即可开启 PnP 特性
```bash
yarn --pnp
```

### `pkg.installConfig`字段
在项目中开启 PnP 特性后，Yarn 会在`package.json`文件中创建一个`installConfig`字段：
```javascript
{
  "installConfig": {
    "pnp": true
  }
}
```
只要`installConfig.pnp`的值是一个真值且当前版本的 Yarn 支持，PnP 特性就会被启用。

#### 执行`npm script`或是运行`.js`文件
由于在开启了 PnP 的项目中不再有`node_modules`目录，所有的依赖引用都必须由`.pnp.js`中的 resolver 处理。因此不论是执行 scripts命令 还是用`node`直接执行一个 JS 文件，都必须经由 Yarn 处理。必须通过`yarn run`或是`yarn node`执行。

#### 在项目中调试依赖
在开发过程中有时会直接修改`node_modules`目录下的依赖来调试。但在 PnP 模式下，由于依赖都指向了全局缓存，我们不再可以直接修改这些依赖。

针对这种场景，Yarn 提供了`yarn unplug packageName`来将某个指定依赖拷贝到项目中的`.pnp/unplugged`目录下。之后`.pnp.js`中的 resolver 就会自动加载这个 unplug 的版本。

调试完毕后，再执行`yarn unplug --clear packageName`可移除本地`.pnp/unplugged`中的对应依赖。
