# TypeScript 编译器配置 (tsconfig.json)

## 快速查阅表

### 根级选项速查
| 选项 | 类型 | 默认值 | 最低版本 | 用途 |
|------|------|--------|----------|------|
| `compileOnSave` | boolean | false | 1.8+ | 文件保存时编译 |
| `extends` | string \| string[] | - | 2.1+ | 配置继承 |
| `files` | string[] | - | 1.6+ | 显式文件列表 |
| `include` | string[] | - | 1.6+ | 文件包含模式 |
| `exclude` | string[] | 见下文 | 1.6+ | 文件排除模式 |
| `references` | object[] | - | 3.0+ | 项目引用 |
| `typeAcquisition` | object | { enable: false, include: [], exclude: [] } | 2.0+ | 自动类型获取 |
| `watchOptions` | object | - | 3.8+ | 文件监听选项 |

### 常见问题索引
- [文件选择问题](#文件选择问题) - 如何控制哪些文件被编译？
- [配置复用问题](#配置复用问题) - 如何避免重复配置？
- [大型项目管理问题](#大型项目管理问题) - 如何组织大型/多包项目？
- [开发体验优化问题](#开发体验优化问题) - 如何提升开发效率？
- [类型管理问题](#类型管理问题) - 如何处理第三方库类型？

---

## 1. 配置文件基础
TypeScript 配置文件（tsconfig.json）包含两个主要部分：

### 根级选项（Root Fields）
直接位于配置文件根层的选项，控制编译器的基本行为：
- `compileOnSave` - 文件保存时编译
- `extends` - 配置继承
- `files` - 显式文件列表
- `include`/`exclude` - 文件包含/排除模式
- `references` - 项目引用
- `typeAcquisition` - 类型自动获取
- `watchOptions` - 文件监听选项

### 编译器选项（Compiler Options）
位于 `compilerOptions` 对象内的选项，控制 TypeScript 编译的详细行为。完整的编译器选项文档请参考 [编译选项配置](./2.%20编译选项配置.md)。

主要类别包括：
- `target` - 目标 ECMAScript 版本
- `module` - 模块系统
- `moduleResolution` - 模块解析策略
- `strict` - 严格类型检查
- 以及其他 100+ 个选项

### 配置文件示例结构
```json
{
  // 根级选项
  "extends": "./tsconfig.base.json",
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"],

  // 编译器选项
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "strict": true
  },

  // 其他根级选项
  "watchOptions": {
    "watchFile": "useFsEvents"
  }
}
```

### 配置优先级与合并规则

### extends 多层继承解析顺序
TypeScript 5.0+ 支持多重 `extends`（配置文件数组），继承顺序为从左到右：

**示例**：
```json
{
  "extends": ["./tsconfig.base.json", "./tsconfig.strict.json", "./tsconfig.test.json"]
}
```

**解析顺序**：
1. 加载当前配置文件的基础设置
2. 按顺序应用 `extends` 数组中的每个配置文件
3. 后加载的配置覆盖先加载的配置（右侧覆盖左侧）
4. 最后应用当前配置文件的设置（最高优先级）

**继承链示例**：
```
当前文件 (最高优先级)
    ↓ 继承/覆盖
tsconfig.test.json
    ↓ 继承/覆盖
tsconfig.strict.json
    ↓ 继承/覆盖
tsconfig.base.json (最低优先级)
```

**加载顺序**：从 `tsconfig.base.json` 开始（最低优先级），到 `tsconfig.strict.json`，再到 `tsconfig.test.json`，最后应用当前文件的配置（最高优先级）。


### 配置合并示例
```json
// tsconfig.base.json
{
  "compilerOptions": {
    "target": "ES2015",
    "strict": false
  }
}

// tsconfig.strict.json
{
  "compilerOptions": {
    "strict": true
  }
}

// tsconfig.json
{
  "extends": ["./tsconfig.base.json", "./tsconfig.strict.json"],
  "compilerOptions": {
    "target": "ES2022"  // 覆盖 base.json 的 ES2015
  }
}

// 最终配置：
// target: "ES2022" (来自当前文件)
// strict: true (来自 tsconfig.strict.json，覆盖 base.json 的 false)
```

### TypeScript 版本兼容性
- **TypeScript 2.1+**：基础 `extends` 支持
- **TypeScript 5.0+**：多重 `extends`（数组支持）
- **TypeScript 3.8+**：`watchOptions` 支持
- **TypeScript 2.3+**：`plugins` 支持

## 2. 常见场景与解决方案

### 2.1 文件选择问题
**问题**：如何控制哪些文件被编译？

**解决方案**：
TypeScript 提供三种机制控制编译文件范围：

#### 1. `files` - 显式文件列表（最高优先级）
- 显式列出要编译的文件路径（相对或绝对路径）
- 不支持 glob 模式
- 总是被编译，不受 `exclude` 影响

#### 2. `include` - 模式匹配包含
- 使用 glob 模式匹配文件（`*`, `**`, `?`）
- 匹配的文件将被编译，除非被 `exclude` 排除

#### 3. `exclude` - 模式匹配排除
- 过滤 `include` 匹配的文件
- 不影响 `files` 中显式列出的文件
- 默认排除：`node_modules`, `bower_components`, `jspm_packages`, `outDir`

#### 优先级规则与决策流程
文件选择遵循明确的优先级规则：

1. **`files` 最高优先级**：显式列出的文件总是被编译
2. **`exclude` 中等优先级**：排除匹配的文件（仅影响 `include` 匹配的文件）
3. **`include` 最低优先级**：通过模式匹配包含文件，可被 `exclude` 覆盖

**决策流程**：
```
是否为 files 中列出的文件？
  ├── 是 → 编译
  └── 否 → 是否匹配 include 模式？
         ├── 否 → 不编译
         └── 是 → 是否匹配 exclude 模式？
                ├── 是 → 不编译
                └── 否 → 编译
```

#### 常见陷阱与注意事项
- **被引用文件**：如果文件被 `files` 或 `include` 中的文件引用，即使它在 `exclude` 中也会被编译
- **默认行为**：未指定任何文件选择选项时，编译当前目录下所有 `.ts`、`.tsx`、`.d.ts` 文件
- **路径解析**：所有路径相对于 `tsconfig.json` 所在目录

#### 配置示例
```json
{
  "files": ["src/main.ts"],
  "include": ["src/**/*.ts"],
  "exclude": ["node_modules", "dist", "src/**/*.test.ts"]
}
```

### 2.2 配置复用问题
**问题**：如何避免重复配置？

**解决方案**：
- **`extends`**: 配置继承（单文件与数组）
- **继承解析顺序与覆盖规则**
- **配置合并策略**


### 2.3 大型项目管理问题
**问题**：如何组织大型/多包项目？

**解决方案**：
- **`references`**: 项目引用与复合项目
- **`composite`**: 增量编译支持
- **项目间依赖管理**


### 2.4 开发体验优化问题
**问题**：如何提升开发效率？

**解决方案**：
- **`watchOptions`**: 文件监听策略优化
- **`plugins`**: 语言服务插件
- **`compileOnSave`**: 保存时编译


### 2.5 类型管理问题
**问题**：如何处理第三方库类型？

**解决方案**：
- **`typeAcquisition`**: 自动类型获取
- **与 `@types` 包的集成**


---

## 3. 配置选项详解（参考手册）

### 3.1 根级选项参考

### 3.2 编译器选项概览
编译器选项位于 `compilerOptions` 对象内，控制 TypeScript 编译的详细行为。完整的编译器选项文档请参考 [编译选项配置](./2.%20编译选项配置.md)。

主要类别包括：
- `target` - 目标 ECMAScript 版本
- `module` - 模块系统
- `moduleResolution` - 模块解析策略
- `strict` - 严格类型检查
- `plugins` - 语言服务插件（影响编辑器体验）
- 以及其他 100+ 个选项

> 注意：`plugins` 选项位于 `compilerOptions` 内，不是根级选项。

---

#### compileOnSave [TypeScript 1.8+]
`compileOnSave`：用于在保存文件时自动编译 TypeScript 文件。但需要编译器支持。
```json
{
  "compileOnSave": false
}
```
#### extends [TypeScript 2.1+]
用于继承另一个配置文件的设置。通过使用 extends，可以将多个配置文件的设置合并，从而减少重复配置。
- 可选值： ""、[]
- 可以通过指定一个其他的 tsconfig.json 文件路径，即一个配置文件可以继承另一个文件的配置属性

在原文件里的配置最先被加载，原文件里的配置被继承文件里的同名配置所重写。 如果发现循环引用，则会报错
```json
{
  // 把基础配置抽离成tsconfig.base.json文件，然后引入
  "extends": "./tsconfig.base.json"
}
```
#### include [TypeScript 1.6+]
用于指定要包含在编译过程中的文件或目录。它接受一个字符串数组，每个字符串可以使用`glob`匹配模式，支持的`glob`通配符有：
- `*`匹配0或多个字符（不包括目录分隔符`/`）
- `**`匹配任意数量的目录层级
- `?`匹配一个任意字符（不包括目录分隔符`/`）
```json
{
  "include": [
    "src",       // 会编译 src 目录下的所有文件，包括子目录
    "src/**/*",  // 会编译 src 目录下的所有文件，包括子目录
    "src/*",     // 只会编译 src 一级目录下的文件
    "src/*/*",   // 只会编译 src 二级目录下的文件
    "src/*.spec.ts", // 匹配 src 目录下的所有 .spec.ts 文件
    "src/(component|service).ts" // 匹配 src 目录下的 component.ts 或 service.ts 文件
    "src/file?.ts",       // 匹配 src 目录下的 file1.ts, file2.ts 等文件
  ]
}
```
#### exclude [TypeScript 1.6+]
用于指定要排除在编译过程之外的文件或目录。它接受一个字符串数组，每个字符串可以使用`glob`匹配模式，支持的`glob`通配符和`include`一致。
- 默认情况下会排除`node_modules`，`bower_components`，`jspm_packages`和`outDir`目录。
- 需要注意的是如果显式添加了`exclude`选项，那么默认的排除规则将被覆盖。
- `exclude` 用于过滤 `include` 匹配的文件，但 `files` 中显式列出的文件不受 `exclude` 影响。如果一个文件同时匹配 `include` 和 `exclude`，该文件将被排除，不会被编译。

`exclude`仅用于排除那些没有被显式引用的文件。被包含文件所引用的文件，即使在`exclude`中列出，仍然会被编译。假设有这样一个场景：
```json
{
  "include": [
    "src/main.ts",    // main.ts 中引入了 a。ts
  ],
  "exclude": [
    "src/a.ts",    // 排除 src 目录下的 a.ts 文件
  ]
}
```
如果`src/main.ts`中通过`import`或其他方式引用了`a.ts`，那么即使`a.ts`被列在`exclude`中，TypeScript 编译器仍然会编译`a.ts`。这是因为 TypeScript 编译器会自动解析和编译所有被包含文件引用的模块，以确保编译过程的完整性和正确性。


#### files [TypeScript 1.6+]
用于显式指定哪些文件会被编译。它接受一个字符串数组，每个字符串是一个文件路径。可以是相对或绝对路径，但不支持 glob 匹配模式的路径。
- `files`中的每个文件都需要提供相对于`tsconfig.json`位置的路径。
- 如果`files`中指定了文件，则被指定文件中引用的文件（通过 import 或 reference 指令）也会被编译。
```json
{
  "files": [
    "src/main.ts",    // 包含 src 目录下的 main.ts 文件
    "./src/app.ts"      // 包含 src 目录下的 app.ts 文件
  ]
}
```
### 与 `include`、`exclude` 的关系
关于 `files`、`include`、`exclude` 的详细优先级规则和配置合并行为，请参考本文档的 **[配置优先级与合并规则](#配置优先级与合并规则)** 章节。

**简要总结**：
- **优先级规则**：`files` 中显式列出的文件总是被编译；`include` 匹配的文件会被编译，除非被 `exclude` 排除
- **默认行为**：未指定任何文件选择选项时，编译当前目录下的所有 `.ts`、`.tsx`、`.d.ts` 文件
- **交互规则**：`files` 中显式列出的文件总是被编译，不受 `exclude` 影响
- **详细示例**：参见配置文件结构部分的完整示例

#### references [TypeScript 3.0+]
> `references`是 TypeScript 3.0的新特性。

`references`是一个数组，数组元素是一个包含`path`属性的对象，`path`属性指定一个或多个被引用项目的路径。被引用的项目必须有自己的`tsconfig.json`文件，并且设置了`composite`选项为`true`。`references`的主要作用是当某个项目代码修改后还能单独编译相应的项目而不是整个项目。再说的简单点，就是实现了关联项目间的懒编译。

假设要开发一个类似于`lodash`的工具库，并在其他项目中使用，而且后期很有可能还要在业界推广。为了保证这个工具的顺利开发及推广，必须要做相应的单元测试。那这个工具库可以看做一个项目，对其中的每个功能的测试也可作为一个独立的项目。

整个过程中，工具库的开发和测试应该是属于同一个项目下 “分项目” 的。那这种情况下`reference`就很棒了。首先搭一个目录出来：
```lua
|---- src/
	|---- index.ts    // 整个工具库的入口
	|---- copyDeep.ts // 其中定义了copyDeep方法
|---- test/
	|---- copyDeep.test.ts // copyDeep的单元测试
|---- package.json
|---- tsconfig.json
```
在`copyDeep.test.ts`中肯定要引用`src/copyDeep`，也就是说`test`的项目是依赖于`src`的

- 如果`src`中的代码发生了变化，整个工具库项目应该重新编译，而`test`项目不应该再被编译
- 如果`test`项目中的代码发生了变化，那`test`项目应该被重新编译，而`src`项目不应该再被编译

如何在一个项目中配置而做到分别编译相应的子项目呢？

首先最先想到的应该是在`tsconfig.json`文件中引入`include`字段配置，先尝试一下下面的配置：
```json
{
    "files": [
        "./src/index.ts"
    ],
    "include": [
        "./test/*.test.ts"
    ],
    "compilerOptions": {
        "outDir": "./dist/"
    }
}
```
来分析这样配置的会有哪些问题：
1. 首先，从整个项目层面，确实做到了修改任意文件重新编译的功能。但注意，编译的是全量的 ts 文件
2. 随着日后项目的增大，在`*.test.ts`文件中引入也将逐渐变大
3. 修改了`src/*.ts`的内容，`test/*.ts`也将作为输出，这是我们不希望看到的

此时，`reference`将解决上述的每一个问题，修改项目结构如下：
```lua
|---- src/
	|---- index.ts    	// 整个工具库的入口
	|---- copyDeep.ts 	// 其中定义了copyDeep方法
	|---- tsconfig.json // 工具库的编译配置文件
|---- test/
	|---- copyDeep.test.ts 	// copyDeep的单元测试
	|---- tsconfig.json 	// 测试的编译配置文件
|---- package.json
|---- tsconfig.json
```
并修改为以下配置：
```json
// 根目录下的 tsconfig.json
{
  "compilerOptions": {
    "declaration": true, // 为子项目生成.d.ts声明文件
      "outDir": "./dist"
      }
}

// src目录下的 src/tsconfig.json
{
  "extends": "../tsconfig",
    "compilerOptions": {
    "composite": true // 必须设置为true，表明该文件夹为一个子项目
  }
}

// test目录下的 src/tsconfig.json
{
  "extends": "../tsconfig",
    "references": [
    { "path": "../src" } // 表示引用了工具库项目
  ]
}
```
这样配置后，如果`src`项目已经编译完成并且输出了编译后的文件，那在`test`项目中，实际加载的是 src 项目声明的`.d.ts`文件，而且这个声明文件是对`test`项目可见的

另外，如果开启了`watch`模式，修改了内容只会编译相应的项目而不会全量编译。这会显著的加速类型检查和编译，减少编辑器的内存占用。而且在代码结构层命有了一个很清晰的规划。
#### typeAcquisition [TypeScript 2.0+]
对象类型，用于指定是否自动获取依赖包的类型声明文件，或指定自动获取哪些依赖包的类型声明文件。包含 3 个子属性：
- `enable`：布尔类型，是否开启自动引入`d.ts`，默认为`false`。
- `include`：数组类型，允许自动引入的库名，如：["jquery", "lodash"]；前提是`enable`需要设置为`true`。
- `exclude`：数组类型，排除的库名；前提是`enable`需要设置为`true`。
```json
{
  "typeAcquisition": {
    "enable": true, // 启用自动类型获取功能。这是 typeAcquisition 的核心功能，允许 TypeScript 编译器自动下载和管理类型声明文件。
    "exclude": ["jquery"],
    "include": ["jest"]
  }
}
```
在整个项目中，如果存在用 JavaScript 写的库，ts 会自动去`compilerOptions.typeRoots`指定的目录中（默认是`@types`目录）寻找对应的类型声明文件。这个行为被称为 typeAcquisition (类型获得)。这个行为可以通过`enable`来开启或关闭，且以库级别来指定应用的范围。

##### typeAcquisition 默认值
```json
{
  "typeAcquisition": {
    "enable": false,
    "include": [],
    "exclude": []
  }
}
```
#### plugins [TypeScript 2.3+]
`plugins` 选项允许配置 TypeScript 语言服务插件，用于扩展编辑器的功能（如代码检查、重构、代码补全等）。这些插件主要用于增强开发体验，不影响编译输出。

### 配置格式
```json
{
  "compilerOptions": {
    "plugins": [
      {
        "name": "typescript-plugin-name",
        "option1": "value1",
        "option2": true
      }
    ]
  }
}
```

### 常用插件示例
#### 1. **typescript-eslint-language-service**
集成 ESLint 到 TypeScript 语言服务，提供实时代码检查。

```json
{
  "compilerOptions": {
    "plugins": [
      {
        "name": "typescript-eslint-language-service",
        "configFile": "./.eslintrc.js"
      }
    ]
  }
}
```

#### 2. **typescript-plugin-css-modules**
为 CSS Modules 提供类型支持。

```json
{
  "compilerOptions": {
    "plugins": [
      {
        "name": "typescript-plugin-css-modules",
        "customMatcher": "\\.module\\.(css|scss|sass|less)$"
      }
    ]
  }
}
```

#### 3. **@styled/typescript-styled-plugin**
为 styled-components 和 Emotion 提供语法高亮和智能提示。

```json
{
  "compilerOptions": {
    "plugins": [
      {
        "name": "@styled/typescript-styled-plugin",
        "tags": ["styled", "css", "sty"]
      }
    ]
  }
}
```

### 插件开发与使用注意事项
1. **仅影响编辑器**：插件通常只影响 TypeScript 语言服务（编辑器功能），不改变编译输出
2. **编辑器集成**：需要在编辑器中启用 TypeScript 插件支持（如 VS Code 的 TypeScript 版本选择）
3. **性能考虑**：复杂的插件可能影响编辑器性能
4. **配置继承**：插件配置随 `extends` 继承
5. **与构建工具集成**：某些插件可能需要额外的构建工具配置

### 现代开发工具链集成
现代工具链（如 Vite、Webpack）通常有独立的插件系统，与 TypeScript 语言服务插件不同：
- **构建时插件**：影响编译过程，配置在构建工具中
- **语言服务插件**：影响开发体验，配置在 `tsconfig.json` 中

#### watchOptions [TypeScript 3.8+]
对象类型，用于配置使用哪种监听策略来跟踪文件和目录。

`tsc --watch`：该命令启动 TypeScript 编译器的监视模式。在这种模式下，TypeScript 会根据`tsconfig.json`中的`watchOptions`配置项来监视文件和目录的变化，并在检测到更改时自动重新编译项目。
### 属性配置
#### watchFile
字符串类型，配置单个文件的监听策略，必须为一下几个值：
- `useFsEvents`(默认)：采用文件系统原生事件机制监听文件更改（推荐，性能较好）。
- `useFsEventsOnParentDirectory`：监视父目录的文件系统事件。如此整个项目的文件监听器将显著减少，但可能导致监听并不准确。
- `dynamicPriorityPolling`：创建一个动态队列去监听文件，修改频率较低的文件将被减少轮询监听的频率。
- `fixedPollingInterval`：固定间隔的检查每个文件是否发生变化。
- `priorityPollingInterval`：固定间隔的检查每个文件是否发生变化，但使用启发式监听的文件的检查频率要低于非启发式监听的文件。
#### watchDirectory
字符串类型，指定 TypeScript 如何监视目录中的文件更改，必须为以下几个值：
- `useFsEvents`(默认)：使用文件系统事件监视目录（推荐）。
- `dynamicPriorityPolling`：创建一个动态队列去监听目录，修改频率较低的目录将被减少轮询监听的频率。
- `fixedPollingInterval`：使用固定的轮询间隔监视目录。
#### fallbackPolling
指定当文件系统事件不可用时的轮询方式。可以设置为以下几个值：
- `fixedPollingInterval`：使用固定的轮询间隔。
- `dynamicPriorityPolling`：创建一个动态队列去监听文件，修改频率较低的文件将被减少轮询监听的频率。
- `priorityPollingInterval`：根据文件的优先级使用不同的轮询间隔。
#### synchronousWatchDirectory
布尔类型，是否对目录延迟监听。
- true：同步监视目录。当文件发生修改时同步的调用回调并更新目录监听器。
- false：异步监视目录（默认）。

如果有大量的文件更改，比如在 npm install 时`node_modules`目录发生的变化，延迟监听是非常有用的。但总有些不常见的场景需要禁用延迟监听。
#### excludeFiles
字符串数组，支持通配符，用于指定不需要被监听的文件。
#### excludeDirectories
字符串数组，用于指定不需要被监听的目录。
## 例子
假设项目结构如下：
```lua
/project
  ├── src
  │   ├── main.ts
  │   ├── helper.ts
  ├── tests
  │   ├── test1.ts
  │   └── test2.ts
  └── tsconfig.json
```
`tsconfig.json`如下（TypeScript 5.x 现代配置）：
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "outDir": "./dist",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true
  },
  "include": [
    "src/**/*"
  ],
  "exclude": [
    "node_modules",
    "dist",
    "tests"
  ],
  "watchOptions": {
    "watchFile": "useFsEvents", // 使用文件系统事件监视单个文件的更改（推荐，性能较好）
    "watchDirectory": "useFsEvents", // 使用文件系统事件监视目录中的文件更改
    "fallbackPolling": "dynamicPriorityPolling", // 当文件系统事件不可用时，使用动态优先级轮询策略
    "synchronousWatchDirectory": false, // 异步监视目录（默认，性能影响较小）
    "excludeDirectories": ["node_modules", "dist"] // 排除不需要监视的目录
  }
}
```

### 现代开发工具链下的 watchOptions 最佳实践 [TypeScript 3.8+]
在现代开发工具链中，`watchOptions` 的配置需要考虑与构建工具的集成和性能优化。

#### 与构建工具集成
大多数现代构建工具（如 Vite、Webpack、esbuild）都有自己的文件监听机制，通常比 `tsc --watch` 更高效。建议的配置策略：

1. **使用构建工具的文件监听**：
   - 对于开发服务器，使用构建工具自带的监听功能
   - `tsc --watch` 主要用于类型检查，而非完整构建

2. **TypeScript 仅类型检查配置**：
```json
{
  "compilerOptions": {
    "noEmit": true,  // 不生成文件，仅类型检查
    "incremental": true
  },
  "watchOptions": {
    "watchFile": "useFsEvents",
    "watchDirectory": "useFsEvents",
    "excludeDirectories": ["**/node_modules", "dist", "build"]
  }
}
```

#### 性能优化配置
针对大型项目的优化配置：

```json
{
  "watchOptions": {
    "watchFile": "useFsEventsOnParentDirectory",  // 减少文件监听器数量
    "watchDirectory": "useFsEvents",
    "fallbackPolling": "dynamicPriorityPolling",  // 动态优先级轮询
    "synchronousWatchDirectory": false,
    "excludeDirectories": [
      "**/node_modules",
      "dist",
      "build",
      "coverage",
      ".git"
    ],
    "excludeFiles": [
      "**/*.spec.ts",
      "**/*.test.ts",
      "**/*.d.ts"
    ]
  }
}
```

#### 现代工具链示例配置

**Vite + TypeScript 项目**：
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "noEmit": true,  // Vite 处理构建
    "strict": true,
    "skipLibCheck": true
  },
  "watchOptions": {
    "watchFile": "useFsEvents",
    "watchDirectory": "useFsEvents",
    "excludeDirectories": ["node_modules", "dist"]
  }
}
```

**Webpack + TypeScript 项目**：
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "jsx": "react-jsx",
    "esModuleInterop": true,
    "skipLibCheck": true
  },
  "watchOptions": {
    "watchFile": "useFsEvents",
    "watchDirectory": "useFsEvents",
    "fallbackPolling": "dynamicPriorityPolling"
  }
}
```

#### 监视模式与增量编译
结合 `incremental` 和 `tsBuildInfoFile` 实现高效监听：

```json
{
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": "./node_modules/.cache/tsbuildinfo.json"
  },
  "watchOptions": {
    "watchFile": "useFsEvents",
    "watchDirectory": "useFsEvents"
  }
}
```

#### 常见问题与解决方案

1. **文件监视不触发**：
   - 检查 `excludeDirectories` 是否排除了目标目录
   - 在虚拟文件系统或容器中运行时，使用轮询策略而非文件系统事件

2. **性能问题**：
   - 减少监视范围：通过 `include` 精确指定源文件
   - 排除构建输出和依赖目录
   - 使用 `useFsEventsOnParentDirectory` 减少监听器数量

3. **与 IDE 冲突**：
   - 某些 IDE 可能使用自己的 TypeScript 服务，与 `tsc --watch` 冲突
   - 解决方案：在 IDE 中禁用内置 TypeScript，或使用单独的终端运行 `tsc --watch`

#### 版本兼容性说明
- **TypeScript 3.8+**：`watchOptions` 基本功能
- **TypeScript 4.0+**：性能改进和错误修复
- **TypeScript 5.0+**：与现代打包器更好的集成

通过合理配置 `watchOptions`，可以在保持类型检查实时性的同时，最小化对系统资源的影响。

## 4. 高级主题

### 4.1 现代 TypeScript 配置
TypeScript 5.0+ 引入了许多新特性，优化了配置体验：

- **`moduleResolution: "bundler"`** - 适用于现代打包器（Vite、Webpack、esbuild）
- **`verbatimModuleSyntax`** - 更精确的模块语法检查
- **`allowImportingTsExtensions`** - 允许导入 `.ts` 扩展名
- **`resolvePackageJsonExports`** 和 `resolvePackageJsonImports` - 更好的包解析

**现代配置示例**：
```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "bundler",
    "verbatimModuleSyntax": true,
    "strict": true,
    "skipLibCheck": true,
    "types": ["vite/client"]
  }
}
```

### 4.2 调试与验证工具
- **`tsc --showConfig`** - 显示最终合并的配置（包含继承和默认值）
- **`tsc --listFiles`** - 列出实际编译的文件列表
- **`tsc --noEmit --diagnostics`** - 显示编译诊断信息

### 4.3 性能优化
- **增量编译**：`incremental: true` + `tsBuildInfoFile`
- **项目引用**：使用 `references` 分割大型项目
- **监视模式调优**：合理配置 `watchOptions`

## 5. 配置示例库

### 5.1 按项目类型
- **简单前端项目**：基础配置 + 严格模式
- **Node.js 后端项目**：CommonJS 模块 + 类型检查
- **库/包开发项目**：声明文件生成 + 多目标输出

### 5.2 按构建工具
- **Vite**：`moduleResolution: "bundler"` + `noEmit: true`
- **Webpack**：`module: "ESNext"` + `target: "ES2020"`
- **esbuild**：`module: "ESNext"` + `skipLibCheck: true`