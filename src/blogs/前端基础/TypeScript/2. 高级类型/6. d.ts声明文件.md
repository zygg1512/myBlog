# d.ts声明文件

## 前言

要生成 TypeScript 声明文件，需要在 tsconfig.json 中将 `declaration` 选项设置为 `true`。

### npm包中设置导出的d.ts

在 `package.json` 中添加 `types` 字段，指向声明文件的位置（例如 `"types": "./lib/main.d.ts"`），这样其他开发者在安装你的 npm 包时就能获得完整的类型提示。

你也可以直接指向 TypeScript 源码文件（例如 `"types": "index.ts"`），这样不仅能提供类型信息，在某些编辑器中还能直接查看和跳转到源码实现。**注意**：直接指向 `.ts` 文件需要确保源码不包含需要编译的 TypeScript 特性，建议使用编译后的 `.d.ts` 文件以获得更好的兼容性。

```json
{
    "name": "awesome",
    "author": "Vandelay Industries",
    "version": "1.0.0",
    "main": "./lib/main.js",
    "types": "./lib/main.d.ts"
}
```

#### `exports` 字段（TypeScript 4.7+）

TypeScript 4.7+ 支持 `package.json` 中的 `exports` 字段，可以更精细地控制模块导出，同时支持 ESM 和 CJS 双模式：

```json
{
    "name": "my-package",
    "version": "1.0.0",
    "exports": {
        ".": {
            "import": {
                "types": "./dist/esm/index.d.ts",
                "default": "./dist/esm/index.js"
            },
            "require": {
                "types": "./dist/cjs/index.d.ts",
                "default": "./dist/cjs/index.js"
            }
        },
        "./styles": {
            "import": "./dist/esm/styles.css",
            "require": "./dist/cjs/styles.css"
        }
    }
}
```

**注意：**

- `exports` 字段中的 `types` 子字段用于指定类型声明文件的位置
- `typings` 字段与 `types` 字段含义相同，可以互换使用
- 如果声明文件名为 `index.d.ts` 且位于包的根目录，TypeScript 会自动查找该文件，但显式指定 `types` 字段是更好的实践
- 使用 `exports` 字段时，`main`、`module`、`types` 等字段通常会被忽略，但为了向后兼容，建议同时保留这些字段

#### 版本兼容性提示

在声明文件中使用新特性时，建议通过 `typesVersions` 字段提供多版本支持：

```json
{
    "typesVersions": {
        ">=4.1": {
            "*": ["types/ts4.1/*"]
        },
        ">=5.0": {
            "*": ["types/ts5.0/*"]
        }
    }
}
```

## `d.ts`声明文件中的修饰符

### export

`export`主要用于模块内部，将模块内定义的类型暴露给外部使用。

#### `export =`

`export =` 是 CommonJS 和 AMD 模块系统中的导出语法，它将**整个模块**导出为一个单一的值，可以是对象、函数、类等。在导入时，需要使用`import = require()`语法。

```typescript
// 定义一个模块文件 utils.ts
function add(a: number, b: number) {
    return a + b;
}

// 使用 export = 导出整个模块
export = add;

// 在另一个文件中导入
import addFunction = require('./utils');
console.log(addFunction(1, 2));
```

- 当使用 `export =` 时，不能再使用 `export default` 或其他命名导出，因为 `export =` 已将整个模块导出为单个值
- 从使用 `export =` 导出的模块导入时，不能使用 ES6 的 `import` 语法，必须使用 `import = require()` 语法

### declare

`declare` 用于告诉 TypeScript 编译器某个变量、函数、类或接口的类型信息，但不包含具体实现代码。因此，需要在运行时为这些声明的全局变量、函数等提供实际实现。

`declare` 既可以用于声明全局类型信息，也可以在模块内部声明局部类型信息：

- **全局声明**：如果一个 TypeScript 文件没有 `import` 或 `export` 语句，它被视为全局文件（非模块文件）。在此文件中使用 `declare` 声明的类型都是全局类型，可以被项目中的其他 TypeScript 文件直接使用。
- **模块内声明**：如果文件中包含 `import` 或 `export` 语句，它被视为模块。此时在模块内使用 `declare` 声明的类型只在该模块内可见，除非使用 `export` 导出。

#### 注意

TypeScript 编译器对 `declare` 的使用较为宽松，允许在 `.d.ts` 文件中出现类似具体实现的写法，但实际上会将其视为类型声明处理。


### import type 和 export type

TypeScript 3.8+ 引入了 `import type` 和 `export type` 语法，用于明确表示只导入/导出类型，不会引入运行时代码。

```typescript
// 只导入类型
import type { SomeType } from './some-module';
import type { ComponentProps } from 'react';

// 只导出类型
export type { User, Post } from './types';

// 在 .d.ts 文件中的使用
declare module 'my-module' {
    import type { ExistingType } from 'original-module';
    export interface MyType extends ExistingType {
        newField: string;
    }
}
```

优点：

- **明确意图**：清晰表明只涉及类型，不涉及运行时
- **避免循环依赖**：类型导入不会导致模块间的运行时依赖
- **Tree-shaking 友好**：帮助打包器识别纯类型导入

注意：在 `.d.ts` 声明文件中，通常使用 `import type` 来避免引入不必要的运行时依赖。

## 声明全局类型

### 声明全局接口类型

```typescript
interface MyGlobalInterface {
    name: string;
    value: number;
}

type MyGlobalType = string | number;
```

- 使用 `interface` 和 `type` 定义类型时，通常不需要加 `declare`，因为 TypeScript 能识别它们为类型声明关键字
- **何时需要加 `declare`？**
    - 对于变量、函数、类等运行时实体，需要使用 `declare` 来声明其类型而不提供具体实现
    - `interface` 和 `type` 本身定义的是纯类型，不需要 `declare` 修饰

### 声明一个全局变量

```typescript
// 声明一个可变的全局变量
declare let globalCounter: number;

// 声明一个不可变的全局常量
declare const APP_VERSION: string;

// 声明一个全局对象
declare const globalConfig: {
    apiUrl: string;
    timeout: number;
};
```

例如，在项目中引入微信 SDK 后，会有一个全局对象 `wx`。如果不进行类型声明，在 TypeScript 文件中直接使用 `wx.config()` 会报错。可以按如下方式声明：

```typescript
interface Wx {
    config: () => void;
}
declare const wx: Wx;
```

### 声明全局方法

```typescript
// 声明全局函数
declare function logMessage(message: string): void;

// 声明带参数的全局函数
declare function calculateSum(a: number, b: number): number;

// 函数重载示例
declare function processInput(input: string): string;
declare function processInput(input: number): number[];
declare function processInput(input: boolean): boolean;
```

### 声明全局类

```typescript
declare class MyGlobalClass {
    constructor(name: string);
    getName(): string;
    static create(): MyGlobalClass;
}
```

### 声明全局枚举类型

```typescript
declare enum MyGlobalEnum {
    Up = 1,
    Down,
    Left,
    Right,
}
```

### 声明全局对象

```typescript
// 声明一个命名空间（全局对象）
declare namespace MyApp {
    // 命名空间内的类型
    export interface Config {
        version: string;
        debug: boolean;
    }

    // 命名空间内的变量
    export const defaultConfig: Config;

    // 命名空间内的函数
    export function initialize(config: Partial<Config>): void;
}
```

比如声明一个 JQuery 对象

```typescript
declare namespace JQuery {
    type cssSelect = {
        css: (key: string, value: string) => cssSelect;
    };
}
```

声明完成后就可以在其他地方直接使用`JQuery`类型，但是不能直接使用`JQuery.cssSelect`类型

#### 如何使用对象内属性对应的类型

如果想要引用`JQuery`中的`cssSelect`类型，则需要在`cssSelect`前加上`export`关键字

```typescript
declare namespace JQuery {
    export type cssSelect = {
        css: (key: string, value: string) => cssSelect;
    };
}
```

此时就可以直接使用`JQuery.cssSelect`类型了

需要注意的是，在命名空间（`namespace`）中定义的类型前面不能加`declare`关键字，但是可以加`export`关键字，比如

```typescript
declare namespace JQuery {
    export function $(ready: () => void): void; // success
    // error：不能在已有的环境上下文中使用 "declare" 修饰符
    declare function $1(ready: () => void): void;
}
```

### 声明全局装饰器类型

TypeScript 5.0 实现了新的装饰器标准，但以下示例展示了传统的装饰器类型定义（仍然被广泛使用）：

```typescript
// 类装饰器
declare type ClassDecorator = <TFunction extends Function>(
    target: TFunction,
) => TFunction | void;

// 方法装饰器
declare type MethodDecorator = <T>(
    target: Object,
    propertyKey: string | symbol,
    descriptor: TypedPropertyDescriptor<T>,
) => TypedPropertyDescriptor<T> | void;

// 使用示例
declare function sealed(constructor: Function): void;
```

## 在已有的全局对象类型中扩展属性

### 新增全局变量

在 TypeScript 中声明全局变量时，需要注意文件是否为模块（包含 import/export 语句）。

```typescript
// 在模块文件（有 import/export 的文件）中必须使用 declare global
declare global {
    const myGlobalVar: string; // 将能在全局直接使用 myGlobalVar
}

// 在非模块文件（没有 import/export 的文件）中，可以直接在顶层使用 declare
// 注意：全局声明需要在 TypeScript 编译器能够访问的文件中（如在 tsconfig.json 的 include/files 中）
declare const myGlobalVar: string; // 将能在全局直接使用 myGlobalVar
```

### 扩展 Window

```typescript
// 在模块文件（有 import/export 的文件）中必须使用 declare global
declare global {
    interface Window {
        myGlobalVar: string; // 将能在全局使用 window.myGlobalVar
    }
}

// 在非模块文件（没有 import/export 的文件）中，可以直接使用 declare interface
// 注意：全局声明需要在 TypeScript 编译器能够访问的文件中
declare interface Window {
    myGlobalVar: string; // 将能在全局使用 window.myGlobalVar
}
```

### 扩展 Node.js 的全局对象

在 Node.js 16+ 中，全局对象的类型定义发生了变化，推荐使用 `globalThis` 进行扩展。对于旧版本 Node.js，可以扩展 `NodeJS.Global` 接口。

```typescript
// 方法一：使用 globalThis（推荐，适用于 Node.js 16+ 和现代浏览器）
declare global {
    var myGlobalVar: string; // 将能在全局使用 globalThis.myGlobalVar 或直接使用 myGlobalVar
}

// 方法二：扩展 global 命名空间（兼容旧版本）
declare global {
    namespace NodeJS {
        interface Global {
            myGlobalVar: string; // 将能在全局使用 global.myGlobalVar（Node.js 15 及以下）
        }
    }
}

// 注意：在模块文件中必须使用 declare global，非模块文件中可以省略
```

## 声明模块

使用`declare module`语法可以为现有的 JavaScript 模块提供类型声明，使得 TypeScript 项目能够正确识别和使用这些模块，主要用途有：

- 为第三方库添加类型声明：当使用的第三方 JavaScript 库没有自带类型声明文件（d.ts）时，可以使用`declare module`手动为其编写类型声明，让 TypeScript 编译器能够对这些库的使用进行类型检查。
- 自定义模块类型声明：如果有自定义的 JavaScript 模块，也可以使用`declare module`为其定义类型，方便在 TypeScript 代码中使用。

基本语法如下：

```typescript
// 声明具体模块
declare module '模块名' {
    // 模块内部的类型声明
    export const 变量名: 类型;
    export function 函数名(参数: 类型): 返回值类型;
    export class 类名 {
        constructor(参数: 类型);
        方法名(参数: 类型): 返回值类型;
    }
    export interface 接口名 {
        属性名: 类型;
    }
    // 默认导出
    export default 默认导出的类型;
}

// 通配符模块声明（TypeScript 2.0+）
declare module '*.css' {
    const content: string;
    export default content;
}

// TypeScript 4.1+ 支持更精确的通配符模式
declare module '*.module.css' {
    const classes: { readonly [key: string]: string };
    export default classes;
}

declare module '*.png' {
    const src: string;
    export default src;
}

// 重新导出模式
declare module 'short-module-name' {
    export * from 'original-long-module-name';
    export { default } from 'original-long-module-name';
}
```

### 扩充第三方模块的类型声明

扩充第三方模块类型声明是指在不改变原有声明的基础上，为模块添加新的属性、方法或类型。主要通过模块扩充（Module Augmentation）的方式来实现，这种方式允许你在现有的模块类型上添加额外的定义。

#### 扩充 lodash 模块

假设使用了`lodash`这个第三方模块，要为其添加一个新的类型。首先，创建一个类型声明文件，例如`lodash-augmentation.d.ts`：

```typescript
// 使用 import type 避免循环依赖，只导入类型信息
import type * as _ from 'lodash';

declare module 'lodash' {
    interface LoDashStatic {
        // 添加一个新的方法类型
        myCustomMethod(arg: string): string;
    }
}
```

上述例子中，如果不需要引用 lodash 内部的类型，可以不添加导入语句。但如果需要在扩充中使用模块内的类型（如示例所示），建议只导入需要的类型：

```typescript
import type { Dictionary, List } from 'lodash';

declare module 'lodash' {
    interface LoDashStatic {
        anotherCustomMethod(arg: Dictionary<number>): List<number>;
    }
}
```

#### 给导出内容是 Class 的模块扩展属性

下面对`any-touch`的类型进行扩充，这里`any-touch`的默认导出是一个`Class`。假设对`any-touch`的代码做了如下修改：

1. 导出增加`aaa`变量，是`string`类型
2. 类的实例增加`bbb`属性，是`number`类型
3. 类增加静态属性`ccc`，是个函数

**注意**：以下示例展示了如何为模块添加新的导出和扩展默认导出的类。在实际项目中，建议将类型扩充放在单独的`.d.ts`文件中。

```typescript
// 在单独的 .d.ts 文件中（如 any-touch-augmentation.d.ts）
declare module 'any-touch' {
    // 导出增加 "aaa"变量, 是个字符串
    export const aaa: string;

    // 扩展默认导出的类
    export default class AnyTouch {
        // 类增加静态属性"ccc", 是个函数
        static ccc: () => void;
        // 类的实例增加"bbb"属性, 是number类型
        bbb: number;
    }
}
```

测试使用：

```typescript
// index.ts - 使用扩充后的类型
import AT, { aaa } from 'any-touch';

const s = aaa.substr(0, 1); // aaa 是 string 类型

const at = new AT();
at.bbb = 123; // bbb 是 number 类型

AT.ccc = () => {}; // ccc 是静态方法
```

#### 扩充没有类型声明文件的模块

假设有一个 myModule 模块没有类型声明，则可以通过下面这种方式扩充

```typescript
declare module 'myModule' {
    export function greet(name: string): string;
    // 添加新的类型
    export function sayGoodbye(name: string): string;
}
```

### 覆盖第三方模块的类型声明

在 TypeScript 中，直接覆盖第三方模块的类型声明通常不被推荐，因为可能导致类型不一致和潜在的错误。TypeScript 的类型合并（declaration merging）机制允许扩展接口，但不能直接修改已有属性的类型。

#### 理解类型合并机制

TypeScript 支持接口合并：当多个同名接口在相同作用域中被声明时，它们的成员会被合并。但是，如果同名属性类型不同，会导致冲突错误。

#### 正确扩展 axios 模块的类型

如果要修改 axios 的 `AxiosRequestConfig` 接口，应该使用模块扩充（module augmentation）来扩展原始接口：

```typescript
// axios-augmentation.d.ts
import 'axios';

declare module 'axios' {
    export interface AxiosRequestConfig {
        // 扩展新属性
        customField?: string;
        // 注意：不能直接覆盖已有属性的类型，如 timeout 已经是 number
        // 如果需要修改 timeout 类型，更好的做法是创建新的配置接口
    }
}

// 或者创建新的配置接口继承原接口
export interface MyAxiosRequestConfig extends AxiosRequestConfig {
    timeout: number | string; // 这会创建一个新接口，不会影响原始类型
}
```

#### 类型覆盖的替代方案

如果必须修改现有属性类型，可以考虑以下方法：

1. **使用类型断言**：在调用处进行类型转换
2. **创建包装函数**：封装原始函数并提供新的类型签名
3. **提交 PR 到 DefinitelyTyped**：修改官方类型定义

注意：直接导出同名接口试图"覆盖"原有类型通常不会生效，因为 TypeScript 会进行接口合并，属性类型冲突时会产生错误。

### 扩充其他非ts、js文件的类型

#### 扩充 Vue 文件的类型（Vue 3）

TypeScript 只支持模块的导入导出，对于 `.vue` 单文件组件，需要声明模块类型。以下是 Vue 3 的类型声明：

```typescript
// vue-shim.d.ts
declare module '*.vue' {
    import { DefineComponent } from 'vue';
    // Vue 3 组件类型定义
    const component: DefineComponent<{}, {}, any, any, any, any>;
    export default component;
}

// 或者使用更简化的版本
declare module '*.vue' {
    import { DefineComponent } from 'vue';
    const component: DefineComponent<{}, {}, any>;
    export default component;
}

// 对于使用 `<script setup>` 语法糖的组件
declare module '*.vue' {
    import { DefineComponent } from 'vue';
    const component: DefineComponent;
    export default component;
}
```

使用示例：

```vue
<!-- App.vue -->
<script setup lang="ts">
import HelloWorld from './components/HelloWorld.vue';
</script>

<template>
    <HelloWorld />
</template>

<!-- 或者使用 Options API -->
<script lang="ts">
import { defineComponent } from 'vue';
import HelloWorld from './components/HelloWorld.vue';

export default defineComponent({
    components: { HelloWorld },
    // ... 其他选项
});
</script>
```

声明 `.vue` 文件为模块后，TypeScript 能够正确识别导入的组件类型，在 `components` 字段中注册时也能获得类型提示。

#### 扩充其他文件的类型

在编辑 TypeScript 文件时，如果想导入 `.css`、`.less`、`.png` 等格式的文件，如果没有相应的 `declare` 声明，会导致语法错误。

```typescript
declare module '*.less';
declare module '*.png';
// 针对文件后缀声明类型，如使用 CSS Modules
declare module '*.less' {
    const styles: Record<string, string>;
    export = styles;
}
```

声明后，就可以直接使用 `import` 导入而不会出现语法错误。

```typescript
import style from './style.css';
```
