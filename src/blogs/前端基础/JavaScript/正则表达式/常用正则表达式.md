
# 常用正则表达式
## 正则表达式实例化方式
- 字面量  `let reg = /\bis\b/g`
- 实例化构造函数 `let reg = new RegExp('\\bis\\b','g')` 
   - 传两个参数 
      - 第一个 String 类型 正则表达式的文本，使用表达式时需要用`\`转移
      - 第二个 String 类型 修饰符
## 修饰符
| 代码 | 解释 |
| --- | --- |
| g | global 全文搜索，不添加的话搜索到的第一个匹配停止 |
| i | ignore case 忽略大小写，默认大小写不敏感 |
| m | multiple lines 多行搜索并匹配 |

## 常用表达式
### 预定义类（当前位置）
| 代码 | 解释 |
| --- | --- |
| `.` | 匹配除换行符以外的任意字符 |
| `\w` | 匹配字母或数字或下划线或汉字 |
| `\s` | 匹配任意的空白符 |
| `\d` | 匹配数字 |
| `\b` | 匹配一个零宽单词边界 |
| `^` | 匹配字符串的开始 |
| `$` | 匹配字符串的结束 |

#### 取反
| 代码 | 解释 |
| --- | --- |
| `\W` | 匹配任意不是字母，数字，下划线，汉字的字符 |
| `\S` | 匹配任意不是空白符的字符 |
| `\D` | 匹配任意非数字的字符 |
| `\B` | 匹配一个零宽非单词边界 |

#### `\b` 和 `\B`
在[MDN](https://link.zhihu.com/?target=https%3A//developer.mozilla.org/zh-CN)中有关于这个的表述：

- `\b` 的描述：匹配一个零宽单词边界（Matches a zero-width word boundary）
- `\B` 的描述：匹配一个零宽非单词边界（Matches a zero-width non-word boundary）

名次解释：
- 零宽：只匹配位置, 不匹配字符
- 单词：在JS中, 单词的定义就是`\w`, 非单词的定义就是`\W`
- 边界：不同为之界； `\w界\W`。也就是在这个位置之前是单词, 那么在这个位置之后就是非单词, 反之也是这样
- 非边界：同类无界. `\w\w` 或者 `\W\W`, 这个位置前后都是同类, 所以就没有界这一说
```javascript
const str = 'a  __'
const reg1 = /\b/g
// str 中单词边界（\w界\W）的有 a 的左边位置和右边位置、下划线的左边位置和右边位置，注意是位置而非字符
str.replace(reg1, '@') // @a@  @__@

const reg2 = /\B/g
// str 中非单词边界（\W\W、\w\w）的有 两个空格中间位置、两个下划线的中间位置
str.replace(reg2, '#') // a ## _#_
```
### 量词（数量）
| 代码 | 解释 |
| --- | --- |
| `*` | 重复零次或更多次 |
| `+` | 重复一次或更多次 |
| `?` | 重复零次或一次 |
| `{n}` | 重复n次 |
| `{n,}` | 重复n次或更多次 |
| `{n,m}` | 重复n到m次 |

### 范围类
| 代码 | 解释 |
| --- | --- |
| `[abc]` | 只匹配 abc 中的一个 |
| `[^x]` | 匹配除了x以外的任意字符 |
| `[.?!]` | 匹配标点符号(`.`或`?`或`!`) |
| `[0-9]` | 匹配数字0 - 9 的任意一个字符 |
| `[a-zA-Z]` | 匹配所有字母的一个 |

### 正则贪婪模式和非贪婪模式
#### 贪婪模式

- 正则表达式默认是贪婪模式，即 尽可能多的匹配
```javascript
'1234567'.replace(/\d{3,5}/g,'X') //打印 ‘X67’
//以最大匹配数量匹配
```
如果剩余的字符串数量也在3～5（不包括5）之间，则根据 3 或者 4 匹配
```javascript
'12345678'.replace(/\d{3,5}/g,'X') //打印 ‘XX’
//第一次根据 5 匹配，此时还剩 3 个，在3～5内，所以再匹配一次
```
#### 非贪婪模式

- 让正则表达式尽可能少的匹配，也就是说一旦成功匹配不再继续尝试

在量词后面加上`?`就可以了
```javascript
'1234567'.replace(/\d{3,5}?/g,'X') //打印 ‘XX7’
//即以根据最小匹配数量匹配
```
### 分组
使用 `()` 可以达到分组功能，使量词作用于分组
```javascript
'a1b2c3d4'.replace(/([a-z]\d){3}/g,'X') // 打印XXXd4
```
使用 `|` 可以达到或的效果
```javascript
'1a3'.replace(/(1|a)/g,'X') // 打印XX3
```
#### 反向引用（分组捕获）
将 2020-02-20 ---> 02/20/2015
```javascript
'2020-02-20'.replace(/\d{4}-\d{2}-\d{2}/g, ???)
```
如果用这种方法的话，不能确定要替换成的值，因为有可能是 2019-12-25 等，这里相当于变量，而不是常量
这个时候可以用反向引用（分组捕获）
定义：用`$n`代表每个分组的内容，代码如下
```javascript
let reg = /(\d{4})-(\d{2})-(\d{2})/g
'2020-02-20'.replace(reg,'$2/$3/$1')  //打印 '02/20/2020'
```
#### 忽略分组`/(?:x)/`
不给分组分配分组索引，输出内容，但是不匹配
```javascript
// 举例一
'zaok'.replace(/(?:z).(ok)/g,'$1')  //打印 'ok'，此时 $1 代表的是 ok 
// 举例二
/(?:js|golang) is good/.exec('js is good, golang is good')
// js这个词虽然有（）进行处理，但是不会被匹配到，而是整体输出`js is good`
// ["js is good", index: 0, ...]

/(js|golang) is good/.exec('js is good, golang is good')
// 去掉“?:”之后的结果
// ["js is good", "js", index: 0, ...]
```
### 零宽断言
#### 先行断言`/x(?=y)/`
x 只有在 y 前面才匹配，必须写成`/x(?=y)/`的形式
```javascript
// 比如：查找字符串 % 前面的数字
const str = 'The best way to achieve a goal is to devote 100% of your time and energy to it.'
str.match(/\d+(?=%)/g) // ['100']
```
#### 先行否定断言`/x(?!y)/`
x 只有不在 y 前面才匹配，必须写成`/x(?!y)/`的形式
```javascript
// 查找字符串中数字不在 % 前面的数字
let str = 'I have more than 100 books'
str.match(/\d+(?!%)/g) // ['100']
```
#### 后行断言`/(?<=y)x/`
"后行断言"正好与"先行断言"相反 ， x 只有在 y 后面才匹配 ， 必须写成`/(?<=y)x/`的形式
```javascript
// 查找￥后面的数字
const str = 'I spent ￥100 RMB to buy this book';
/(?<=￥)\d+/.exec(str); // ['100']
```
#### 后行否定断言`/(?<!y)x/`
x 只有不在 y 后面才匹配，必须写成`/(?<!y)x/`的形式
```javascript
// 查找不是￥后面的数字
let str = `I spent $100 RMB to buy this book`;
/(?<!￥)\d+/.exec(str) // ["100"]
```
#### 小结
上述这些匹配也叫零宽断言，只匹配位置, 不匹配字符
用于查找在某些内容(但并不包括这些内容)之前或之后的东西；也就是说它们像`\b`,`^`,`$`那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。
## 参考

- [JS正则里面“?”的用处](https://zhuanlan.zhihu.com/p/99114469)
- [JavaScript 的正则表达式中的 \b 以及 \B 问题？](https://www.zhihu.com/question/46315785/answer/148484184)
