# 应用内负载均衡
当我们明白了网络架构上的负载均衡方式之后，接下来就说下应用内的负载均衡。应用内负载均衡分为两种
- 进程负载均衡：当一个机器接收到请求后，机器内部会将主进程分为多个子进程，并将请求分散到子进程中。比如 Node.js 的 PM2就有单机负载均衡的作用。
- RPC负载均衡：假如 Node 服务要通过RPC调用远程其他服务，为了不影响其他服务，需要将RPC均衡分派到其他服务的不同节点上

## 进程负载均衡
常见的进程负载均衡工具有PM2，通过 [Cluster](https://www.yuque.com/zygg/bemfxw/xycrl6ge8x9ku2d6) 模块实现

<img src="https://github.com/zygg1512/myBlog/raw/master/images/Service/负载均衡/进程负载均衡.png" height="300px" />

## RPC负载均衡
假如 Node 服务要通过RPC调用远程其他服务，为了不影响其他服务，需要将RPC均衡分派到其他服务的不同节点上

### RPC概念
RPC是指远程过程调用，也就是说两台服务器A，B，一个应用部署在A服务器上，想要调用B服务器上应用提供的函数/方法，**由于不在一个内存空间，不能直接调用**，需要通过网络来表达调用的语义和传达调用的数据。

那么服务 A 如果想要调用服务 B 中的某个方法该怎么办呢？使用 HTTP请求 当然可以，但是可能会比较慢而且一些优化做的并不好。 RPC 的出现就是为了解决这个问题。

最终解决的问题：**让分布式或者微服务系统中不同服务之间的调用像本地调用一样简单。解决不同服务之间调用问题。**

#### 为什么用 RPC，不用 HTTP
**首先需要指正，这两个并不是并行概念。**RPC 是一种**设计**，**就是为了解决不同服务之间的调用问题**，完整的 RPC 实现一般会包含有**传输协议**和**序列化协议**这两个。
**而 HTTP 是一种传输协议，RPC 框架完全可以使用 HTTP 作为传输协议，也可以直接使用 TCP，使用不同的协议一般也是为了适应不同的场景。**

#### 使用 TCP 和使用 HTTP 的区别
**传输效率：**

- TCP，通常自定义上层协议，可以让请求报文体积更小
- HTTP：如果是基于HTTP 1.1 的协议，请求中会包含很多无用的内容

**性能消耗，主要在于序列化和反序列化的耗时**

- TCP，可以基于各种序列化框架进行，效率比较高
- HTTP，大部分是通过 JSON 来实现的，字节大小和序列化耗时都要更消耗性能

**跨平台：**

- TCP：通常要求客户端和服务器为统一平台
- HTTP：可以在各种异构系统上运行

**总结：**

- RPC 的 TCP 方式主要用于公司内部的服务调用，性能消耗低，传输效率高
- HTTP主要用于对外的异构环境，浏览器接口调用，APP接口调用，第三方接口调用等

#### RPC步骤

1. 服务消费方（client）以本地调用方式调用服务
2. client stub接收到调用后负责将方法、参数等组装成能够进行网络传输的消息体
3. client stub找到服务地址，并将消息发送到服务端
4. server stub收到消息后进行解码
5. server stub根据解码结果调用本地的服务
6. 本地服务执行并将结果返回给server stub
7. server stub将返回结果打包成消息并发送至消费方（client）
8. client stub接收到消息，并进行解码
9. 服务消费方（client）得到最终结果

时序图如下
<img src="https://github.com/zygg1512/myBlog/raw/master/images/Service/负载均衡/RPC时序图.png" height="300px" />
