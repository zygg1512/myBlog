# 镜像 Image
镜像是一种轻量级、可执行的独立软件包。用来打包软件运行环境和机遇运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件。

从另一个角度看，Docker 镜像其实是基于 UnionFS 文件系统的，由一组镜像层依次挂载而得。每个镜像层包含对上一镜像层的修改，这些修改发生在容器运行的过程中。所以，**镜像是对容器运行环境进行持久化存储的结果。**
## 深入镜像
### 镜像实现原理
#### 镜像管理
与其他虚拟机的镜像管理不同，**Docker 将镜像管理纳入到了自身设计之中**。也就是说，所有的 Docker 镜像都是按照 Docker 设定的逻辑打包，由 Docker Engine 控制。

**比较：**
- 常见的虚拟机镜像：通常是由热心的提供者以他们自己熟悉的方式打包成镜像文件，然后被使用者从网上下载或是通过其他方式获得后，恢复到虚拟机中的文件系统里的。
- Docker 的镜像：必须通过 Docker 来打包，也必须通过 Docker 下载或导入后使用，不能单独直接恢复成容器中的文件系统。

虽然这么做失去了很多灵活性，但固定的格式意味着我们可以很轻松的在不同的服务器间传递 Docker 镜像，配合 Docker 自身对镜像的管理功能，让我们**在不同的机器中传递和共享 Docker 变得非常方便**。这也是 Docker 能够提升我们工作效率的一处体现。
#### 镜像层编码
对于每一个记录文件系统修改的镜像层来说，Docker 都会根据它们的信息生成了一个 Hash 码，这是一个 64 长度的字符串，足以保证全球唯一性。这种编码的形式在 Docker 很多地方都有体现，之后我们会经常见到。

由于镜像层都有唯一的编码，我们就能够区分不同的镜像层并能保证它们的内容与编码是一致的，这带来了如下好处：
- **镜像之间可以共享镜像层**
- **镜像可以共用一些存储空间，达到 1 + 1 < 2 的效果，为我们在同一台机器里存放众多镜像提供了可能**

<img src="https://github.com/zygg1512/myBlog/raw/master/images/Service/docker/镜像-镜像层.png" height="300px" />

举一个实际的例子，由 Docker 官方提供的两个镜像 elasticsearch 镜像和 jenkins 镜像都是在 openjdk 镜像之上修改而得，那么在我们实际使用的时候，这两个镜像是可以共用 openjdk 镜像内部的镜像层的。

事实上，这个优势更明显。一个虚拟机镜像的占用空间往往用 GB 来衡量，在同一台物理机上存放几个就已经是了不起的事情了。而 Docker 管理之下的镜像，占用空间是以 MB 为单位进行衡量的，加上镜像之间还能够共享部分的镜像层，也就是共享存储空间，所以我们在常见的硬盘里放下几十、数百个镜像也不是什么难事。
#### 镜像命名
镜像层的 ID 既可以识别每个镜像层，也可以用来直接识别镜像 ( **因为根据最上层镜像能够找出所有依赖的下层镜像，所以最上层的镜像层 ID 就能表示镜像的 ID** )，但是使用这种无意义的超长哈希码显然是违背人性的，所以我们还要介绍镜像的命名，通过镜像名能够更容易的识别镜像。

在 `docker images`命令打印出的内容中，还能看到两个与镜像命名有关的数据：**REPOSITORY** 和 **TAG**，这两者就组成了 docker 对镜像的命名规则。
```bash
> docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
php                 7-fpm               f214b5c48a25        9 days ago          368MB
redis               3.2                 2fef532eadb3        11 days ago         76MB
redis               4.0                 e1a73233e3be        11 days ago         83.4MB
cogset/cron         latest              c01d5ac6fc8a        15 months ago       125MB
```
来看这个例子：

<img src="https://github.com/zygg1512/myBlog/raw/master/images/Service/docker/镜像-镜像命名.webp" height="300px" />

准确的来说，镜像的命名可以分成三个部分：**username**、**repository** 和 **tag**

- **username**： 主要用于识别上传镜像的不同用户，与 GitHub 中的用户空间类似
   - 有的镜像有 username 这个部分，而有的镜像是没有的。没有 username 这个部分的镜像，表示镜像是由 Docker 官方所维护和提供的，所以就不单独标记用户
- **repository**：主要用于识别镜像内容，形成对镜像的表意描述，通常采用的是软件名
- **tag**：主要用于表示镜像的版本，方便区分镜像内容
   - 如果在操作中没有指定 tag，Docker 会采用 **latest** 作为缺省 tag
### 镜像加载原理
Docker 的镜像实际上由一层一层的文件系统组成

#### Docker 镜像的最底层是 bootfs
bootfs(boot file system)：主要包含 boot 加载器(bootloader)和内核(Kernel)。这一层与典型的 Linux/Unix 系统是一样的。

boot 加载器(bootloader)的作用是引导添加内核(Kernel)。

boot 加载器加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs 转交给内核，系统也会**卸载 bootfs**

#### Docker 镜像的第二层是 rootfs
rootfs(root file system)：在 bootfs 之上。包含的就是典型 Linux系统中 的 /dev,/proc,/bin,/etc 等标准目录和文件。 rootfs就是各种不同的操作系统发行版，比如 Ubuntu, Centos 等等

<img src="https://github.com/zygg1512/myBlog/raw/master/images/Service/docker/镜像-镜像roots层.png" height="300px" />

#### Docker 镜像的第三层就是镜像层

如下图，添加了两个镜像，分别是 emacs、Apache

<img src="https://github.com/zygg1512/myBlog/raw/master/images/Service/docker/镜像-镜像层.png" height="300px" />

当用docker run启动这个容器时，实际上在镜像的顶部添加了一个新的可写层。这个可写层也叫容器层

<img src="https://github.com/zygg1512/myBlog/raw/master/images/Service/docker/镜像-镜像容器层.png" height="300px" />

容器启动后，容器内的应用对容器的改动，比如，文件的增删改操作；都只会发生在容器层中，对容器层下面的所有只读镜像层没有影响
> Docker 镜像都是只读的，当容器启动时，一个新的可写层加载到镜像的顶部！这一层就是我们通常说的容器层，容器之下的都叫镜像层！

#### 镜像加载的例子
在加载一个镜像的时候，会按照从底层到高层的顺序依次加载该镜像所需要的镜像层。在加载的过程中，如果当前镜像层已经存在，则会跳过当前镜像层。

比如：已经下载过 MySQL镜像，而 MySQL镜像 依赖 CentOS镜像，所以 CentOS镜像 也会被下载下来。现在要下载 Tomcat镜像，而 Tomcat镜像 也需要 CentOS镜像，那么下载 Tomcat镜像的时候，就会跳过已被下载过的 CentOS镜像。

<img src="https://github.com/zygg1512/myBlog/raw/master/images/Service/docker/镜像-镜像加载.png" height="300px" />

### 小结
#### 如何查看镜像分层
```bash
## 查看镜像元信息
> docker inspect xxx

"RootFS": {
  "Type": "layers",
  "Layers": [
    "sha256:a13c519c6361b881ba38a452d05e130fc2ee26f0849f119936d747b96cf6a5c3",
    "sha256:bafdbe68e4aee5999c326aaa33571b595d6bfbea119742439588c3e0c1a56130",
    "sha256:a037458de4e074da622d972e28cfa275c246c684e06efdd28d39c0faa45cb633",
    "sha256:08fa02ce37ebdcd0029cf499ca859e0dc488d7725499063baf4481681e6da7ef",
    "sha256:5bdcc8e2060c976a390966445e46453b29dfb5e1860a3b96ded020a924472dc0",
    "sha256:78d9c6989ad1034568c7e0eaf5a6efa463e3a07111ebf33fd0b5a99654ae3a23",
    "sha256:9e01c2c7216e365743513b738a9e458b518db8787d3024407a536d5bc41c5d09",
    "sha256:fef4baf488014a1557cd120fe6d56040a5d5a845f472b350a7609c4668110ad8",
    "sha256:adcd0466d8b3275549b226f0a0654aad190a4cdc18e59d75411c80e35ee94e14"
  ]
}
```
查看镜像元信息时，可以看到镜像被分为了多少层，如上被分成了 9 层，每一层都是一个镜像层
## 容器的生命周期
由于 Docker 揽下了大部分容器管理的活，只对外提供给我们非常简单的操作接口，这就意味着 Docker 里对容器的一些运行细节会被更加严格的定义，这其中就包括了容器的生命周期。

这里有一张容器运行的状态流转图：

<img src="https://github.com/zygg1512/myBlog/raw/master/images/Service/docker/镜像-容器运行状态流转图.webp" height="300px" />

图中展示了几种常见的操作  Docker 容器的命令，以及执行命令后容器的状态变化。先撇开命令，着重看看容器的几个核心状态，也就是图中色块表示的：
- **Created**：容器已经被创建，容器所需的相关资源已经准备就绪，但容器中的程序还未处于运行状态。
- **Running**：容器正在运行，也就是容器中的应用正在运行。
- **Paused**：容器已暂停，表示容器中的所有程序都处于暂停（不是停止）状态。
- **Stopped**：容器处于停止状态，占用的资源和沙盒环境都依然存在，只是容器中的应用程序均已停止。
- **Deleted**：容器已删除，相关占用的资源及存储在 Docker 中的管理信息也都已释放和移除。

在这几种状态中，Running 是最为关键的状态，在这种状态中的容器，就是真正正在运行的容器了。

通过`docker create`创建的容器，是处于 Created 状态的，其内部的应用程序还没有启动，所以需要通过`docker start`命令来启动它，进入 Running 状态。
### 容器主进程
在 Docker 的设计中，容器的生命周期其实与容器中 PID 为 1 这个进程有着密切的关系。更确切的说，它们其实是共患难，同生死的兄弟。**容器的启动，本质上可以理解为这个进程的启动，而容器的停止也就意味着这个进程的停止，反过来理解亦然。**

当我们启动容器时，Docker 其实会按照镜像中的定义，启动对应的程序，并将这个程序的主进程作为容器的主进程 ( 也就是 PID 为 1 的进程 )。而当我们控制容器停止时，Docker 会向主进程发送结束信号，通知程序退出。

而当容器中的主进程主动关闭时 ( 正常结束或出错停止 )，也会让容器随之停止。

**为什么不要在同一个容器中运行多个应用？**

**因为 Docker 无法跟踪不同应用的生命周期，有可能造成应用的非正常关闭，进而影响系统、数据的稳定性。** 如果一个容器只运行一个应用，那么就可以理解为这个进程只负责这一个应用，当应用非正常关闭时这个进程也会关闭，Docker 就可以跟踪应用的生命周期
### 容器的写时复制机制
> 在编程里，写时复制常常用于对象或数组的拷贝中，当拷贝对象或数组时，复制的过程并不是马上发生在内存中，而只是先让两个变量同时指向同一个内存空间，并进行一些标记，当要对对象或数组进行修改时，才真正进行内存的拷贝

Docker 的写时复制与编程中的类似，在通过镜像运行容器时，并不是马上就把镜像里的所有内容拷贝到容器所运行的沙盒文件系统中，而是利用 UnionFS 将镜像以只读的方式挂载到沙盒文件系统中。只有在容器中发生对文件的修改时，修改才会体现到沙盒环境上。

也就是说，容器在创建和启动的过程中，不需要进行任何的文件系统复制操作，也不需要为容器单独开辟大量的硬盘空间，与其他虚拟化方式对这个过程的操作进行对比，Docker 启动的速度可见一斑。

采用写时复制机制来设计的 Docker，既保证了镜像在生成为容器时，以及容器在运行过程中，不会对自身造成修改。又借助剔除常见虚拟化在初始化时需要从镜像中拷贝整个文件系统的过程，大幅提高了容器的创建和启动速度。可以说，Docker 容器能够实现秒级启动速度，写时复制机制在其中发挥了举足轻重的作用。

#### 为什么虚拟机是分钟级别而 Docker 是秒级别？
通过案例来证明一下，Centos 这个镜像包的大小是209M，平时安装在虚拟机上的 Centos 都是几个G，这个里为什么 200M 就可以？

这是因为 Centos镜像文件 只是一个最精简的 rootfs 版本，**与底层系统（主机）共用了内核(Kernel)**，所以才 200M 就可以将一个 Centos 跑起来，对于不同发行版本可能这个大小会略微有所不同。
- **可以和主机共用内核(Kernel)，只需提供最精简的rootfs版本**
- **容器的写时复制机制**



