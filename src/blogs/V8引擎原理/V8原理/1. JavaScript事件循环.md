# JavaScript 事件循环
## JavaScript 为什么是单线程
JavaScript 作为浏览器脚本语言，他主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。

比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器就很难判断应该以谁为准了。

### Worker 线程有没有改变 JavaScript 是单线程
为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程是完全受主线程控制的，而且不得操作 DOM。

所以，这个标准并没有改变 JavaScript 是单线程的本质。

## 浏览器包含哪些进程
Chrome使用多进程架构，每个进程独立运行，这有助于提高浏览器的稳定性和安全性。不同进程之间通过 IPC（进程间通信）进行数据交互和协调。

- Browser 进程：这是 Chrome 浏器览的主进程，负责管理和协调其他进程。它处理用户界面、安全验证、扩展和插件管理等任务。
- Renderer 进程：每个标签页（标签）和独立的扩展程序都有一个独立的 Renderer 进程。Renderer 进程负责加载、显示网页内容、执行 JavaScript 代码和处理用户交互。
- GPU 进程：GPU 进程负责处理图形渲染任务，以加速网页和图形的绘制。
- Plugin 进程：当需要加载插件时，浏览器会创建一个独立的插件进程来处理。
- Utility 进程：Utility 进程执行一些辅助任务，如网络代理、音频。
- Network Service 进程：负责处理网络请求和数据传输等网络相关任务。
### Renderer 进程中的线程
加载、显示网页内容以及执行 JavaScript 代码、处理用户交互等都在渲染进程内执行。而且渲染进程是多线程的。下面是渲染进程中一些较为常用线程。

#### 主线程（Main thread）
主线程是浏览器中的核心线程。作用如下：
- 负责创建并控制事件循环机制及任务队列。
- 当遇到 JavaScript 脚本时，主线程会调用 JavaScript 引擎线程执行 JavaScript 脚本。
- 当遇到用户输入事件和界面渲染事件后，主线程会调用 GUI 线程执行。

#### GUI 线程（Graphical User Interface Thread）
GUI 线程是主线程的一部分，它负责解析 HTML 和 CSS、构建 DOM 树和 CSSOM 树并进行布局计算和生成绘制指令和处理用户输入事件。

**为什么 GUI 线程与 JavaScript 引擎线程互斥？**

GUI 线程与 JavaScript 引擎线程是互斥的。当 JavaScript 引擎执行时，GUI 线程会被挂起。因为 JavaScript 是可以操作 DOM 的，如果修改元素属性的同时渲染界面（即 JavaScript 线程和 GUI 线程同时运行），那么前后获得的元素就可能不一致了。

例如浏览器渲染的时候遇到`<script>`标签，GUI线程 就会停止渲染，然后 JavaScript 引擎线程开始工作，执行里面的是 JavaScript 脚本。等 JavaScript 脚本执行完毕，JavaScript 引擎线程停止工作，GUI 线程继续渲染下面的内容。所以如果 JavaScript 脚本执行时间太长就会造成页面卡顿的情况。
#### JavaScript 引擎线程（JavaScript Engine Thread）
JavaScript 引擎线程是浏览中器的一个独立线程，负责解析和执行 JavaScript 代码。它独立于主线程，在主线程的请求下执行 JavaScript 代码，并返回执行结果。

常见的 JavaScript 引擎有：
- V8引擎（用于Chrome浏览器）
- SpiderMonkey引擎（用于Firefox浏览器）

#### 事件线程（event thread）
事件线程负责接收用户的输入事件（例如鼠标点击、键盘输入等）以及系统的通知事件（例如窗口大小化、定时器触发、网络请求返回等）。事件线程会将事件信息进行封装，并将回调任务添加到任务队列（也称为消息队列）中。

需要注意的是，事件线程主要是将事件放入任务队列中，但事件循环机制本身及任务队列是由主线程创建并控制的。事件线程将事件放入任务队列后，主线程会根据事件的优先级和顺序，从任务队列中取出事件并执行相应的操作。事件线程和主线程通过任务队列来传递任务。

#### 定时器线程（Timer thread）
当开发者在 JavaScript 代码中使用`setTimeout`或`setInterval`时，主线程会将定时器的相关信息（如回调函数、延迟时间等）传递给定时器线程。定时器线程负责管理所有的定时器。它会维护一个定时器队列，并按照定时器的触发时间进行排序。当定时器的触发时间到达时，定时器线程会将相应的定时器回调函数通过事件线程放入任务队列中。

需要注意的是，定时器任务的触发时间不是严格精确的，而是在指定的时间间隔到达后尽可能快地添加到任务队列中。这也意味着，当定时器任务的执行时间过长或在执行时发生阻塞，可能会导致后续定时器任务的触发延迟。

#### 异步 HTTP 请求线程（Asynchronous HTTP Request Thread）
异步 HTTP 请求线程是指在进行网络请求时，为了避免阻塞主线程而单独开辟的线程，负责发送异步的网络请求。并在请求完成时通过事件线程将对应的回调函数放入任务队列中，供主线程处理。

在 Web 开发中，当需要发起网络请求（如 AJAX 请求）时，如果直接在主线程中执行网络请求，会导致主线程被阻塞，用户界面无响应，给用户产生不良体验。为了解决这个问题，一般会使用异步 HTTP，将网络请求和响应处理发到一个独立的线程中进行。这个独立的线程就是异步 HTTP 请求线程。

#### 工作线程（Worker Thread）
工作线程是一种特殊的线程，它可以在后台运行，独立于主线程。工作线程主要执行一些耗时的用于任务如，大量计算、文件操作、网络请求等，以避免阻塞主线程的执行。Web Worker 使用的就是工作线程。
#### 垃圾回收线程（Garbage Collection Thread）
负责回收不再使用的内存空间，以提高内存的利用效率。它会定期检查内存中的对象，并回收那些不再被引用的对象，释放内存资源。
## 浏览器事件循环机制（Event Loop）
事件循环机制是一种实现异步编程的机制。简单来说，事件循环机制用于处理浏览器中的各种事件，包括用户输入、计时器、网络请求等。在事件循环机制中，主线程会不断地从任务队列中取出任务并执行，直到队列为空。这种机制可以保证异步任务的有序执行，并避免页面阻塞。

1. 主线程中会先执行同步任务（宏任务）
   1. 如果是 JavaScript 脚本主线程会通知 JavaScript 引擎线程执行，并产生一个`执行栈`，用于存储执行上下文。
   2. 如果是 DOM 任务主线程会交由 GUI 线程处理。
2. 当遇到事件绑定和一些异步操作时 JavaScript 引擎线程将对应的事件添加到对应线程中，等异步事件有了结果，对应线程便把他们的回调通过事件线程添加到`任务队列`。
4. 在每个同步任务（宏任务）执行结束前，JavaScript 引擎线程会检查全局执行上下文中的`微任务队列`，然后按顺序执行`微任务队列`中的微任务。
5. 当宏任务和微任务执行完毕，JavaScript 引擎线程退出，主线程开始检查渲染，然后 GUI 线程开始渲染页面。
   1. JavaScript 引擎线程和 GUI 线程是互斥的关系，浏览器为了能够使宏任务和DOM任务有序的进行，会在一个宏任务执行结果后，在下一个宏任务执行前，让 GUI 线程渲染页面。
6. 渲染完毕后，主线程会轮询`任务队列`中是否有待执行的任务，如果有就会按上述顺序继续轮询。
### 宏任务（macrotask）
在事件循环机制中，主线程不断地从任务队列中取出任务并执行任务。我们把这些在任务队列中的任务称为宏任务（macrotask）。
#### 常见的宏任务
- 主代码块(`<script>`标签内的同步代码)
- `setTimeout`、`setInterval`
- 浏览器 API：`requestAnimationFrame`
- 用户交互事件（如鼠标点击、滚动页面、放大缩小等）
- 网络请求完成的回调、文件读写完成的回调

### 微任务（microtask）
ES6新引入了 Promise 标准，同时浏览器实现上多了一个 microtask 微任务概念，在 ECMAScript 中，microtask 也被称为 jobs。

#### 常见微任务
- `Promise.then`
- `catch`、`finally`
- `Object.observe`
- `MutationObserver`

#### 微任务执行时机
V8 引擎每执行一个宏任务（JS 脚本）都会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在全局执行上下文内部创建一个微任务队列。也就是说每个宏任务都关联了一个微任务队列（Jobs Queue）。

通常情况下，在当前宏任务中的 JavaScript 快执行完成时，也就在 V8 引擎准备退出全局执行上下文并清空调用栈的时候，V8 引擎会检查全局执行上下文中的微任务队列，然后按顺序执行队列中的微任务。也就是说在宏任务结束之前，会执行所有微任务，所以说微任务要早于宏任务。

WHATWG 把执行微任务的时间点称为**检查点**。

#### 微任务内执行微任务
如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。

#### 微任务优势
因为宏任务需要先被放到任务队列中，如果某些宏任务的执行时间过久，那么就会影响到任务队列后面的宏任务的执行，而且这个影响是不可控的，因为无法知道前面的宏任务需要多久才能执行完成。所以为了解决效率和时效性问题引入了微任务。
### 单任务队列的队头阻塞问题
在单任务队列架构下，存在着低优先级任务会阻塞高优先级任务的情况。

比如用户发出一个点击事件或者缩放页面的事件，而在此时，该任务前面可能还有很多不太重要的任务在排队等待着被执行，诸如 V8 的垃圾回收、DOM 定时器等任务，如果执行这些任务需要花费的时间过久的话，那么就会让用户产生卡顿的感觉。

<img src="https://github.com/zygg1512/myBlog/raw/master/images/V8引擎/单任务队列的队头阻塞问题.webp" width="400px" />

#### Chromium 是如何解决队头阻塞问题的？
通过给不同类型的任务创建不同的任务队列，并配合动态调度策略，基于不同场景动态调整各任务队列的执行优先级。

常用的任务队列如下：
- 用户交互的任务队列：用来存放用户交互、输入事件。
- 合成任务的任务队列：用来存放合成事件。
- 默认任务队列：用来保存如页面解析、资源加载、定时器回调、JavaScript 脚本执行等事件。
- 空闲任务队列：用来存放 V8 的垃圾自动垃圾回收这一类实时性不高的事件。

动态策略如下：

<img src="https://github.com/zygg1512/myBlog/raw/master/images/V8引擎/任务队列的动态策略.webp" width="500px" />

首先是页面加载阶段，用户的最高诉求是在尽可能短的时间内看到页面，至于交互和合成并不是这个阶段的核心诉求。因此在加载阶段将默认任务队列调整为优先级最高的队列，降低合成任务的任务队列的优先级。

页面加载完成之后，就进入了交互阶段，用户的输入事件是最高优先级，当渲染进程接收到用户交互的任务后，接下来大概率是要进行绘制合成操作，因此在执行用户交互的任务时，将合成任务的任务队列的优先级调整到最高。

处理完成 DOM，计算好布局和绘制，就需要将信息提交给合成线程来合成最终图片了，然后合成线程进入工作状态。那么就可以把下个合成任务的优先级调整为最低，并将默认任务队列优先级提升。从合成结束到下个 VSync 周期内，就进入了一个空闲时间阶段，那么就可以在这段空闲时间内执行一些不那么紧急的任务，比如 V8 的垃圾回收，或者通过`window.requestIdleCallback()`设置的回调任务等，都会在这段空闲时间内执行。
#### 任务饿死
在某个状态下，一直有新的高优先级的任务加入到队列中，这样就会导致其他低优先级的任务得不到执行，这称为任务饿死。

Chromium 为了解决任务饿死的问题，给每个队列设置了执行权重，也就是如果连续执行了一定个数的高优先级的任务后中间会执行一次低优先级的任务，这样就缓解了任务饿死的情况。
## Node 事件循环机制（Event Loop）
Node 的异步语法比浏览器更复杂，因为它可以跟内核对话，不得不搞了一个专门的库 libuv 做这件事。这个库负责各种回调函数的执行时间，异步任务最后基于事件循环机制还是要回到主线程，一个个排队执行。
### 本轮循环与次轮循环
严格意义上说，Node 没有微任务和宏任务的概念，取而代之的是本轮循环和次轮循环。

- 本轮循环：追加在本轮循环的异步任务
- 次轮循环：追加在下一轮循环的异步任务
- **本轮循环一定早于次轮循环执行**

Node 规定，`process.nextTick`和`Promise`的回调函数，追加在本轮循环，即同步任务一旦执行完成，就开始执行它们。而`setTimeout`、`setInterval`、`setImmediate`的回调函数，追加在次轮循环。

### 事件循环流程
1. Node 开始执行脚本时，会先进行事件循环的初始化。
2. 开始执行同步任务，发出异步请求、规划定时器生效的时间等等。
3. 执行完所有同步任务，接下来就会执行本轮循环中的异步任务：
   1. 先执行`process.nextTick`的任务队列
   2. 再执行`Promise`任务队列
4. 本轮循环中的异步任务执行完之后，开始执行次轮循环中的异步任务。每次次轮循环都会经过六个阶段。
5. 每个阶段执行完回调后，都会执行一次 nextTick队列 和 Promise队列。

一次「次轮循环」要经过六个阶段：
1. timers：本阶段执行已经被`setTimeout`、`setInterval`调度的回调函数。
2. pending callbacks：此阶段执行某些系统操作的回调。比如 TCP 错误的类型。如果TCP套接字在尝试连接时收到 ECONNREFUSED，则某些`*nix`系统希望等待报告错误。这操作将在该阶段执行。
3. idle, prepare：仅 Node 内部使用。
4. poll：轮询队列，除timers、check之外的回调存放在这里。例如操作读取文件等等，适当的条件下 Node 将阻塞在这里。
5. check：检查阶段，使用 setImmediate 的回调会直接进入这个队列。
6. close callbacks：关闭阶段，一些关闭的回调函数，如：`socket.on('close', ...)`。
```text
   ┌───────────────────────────┐
┌─>│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │<─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘
```

#### timers
timers 并非真正意义上的队列，他内部存放的是计时器。每次到达这个队列，会检查计时器线程内的所有计时器，计时器线程内部多个计时器按照时间顺序排序。

检查过程：每个`setTimeout`、`setInterval`会指定一个下限时间而不是准确时间。每次达到这个队列时会将每一个计时器按顺序分别计算一遍，计算该计时器开始计时的时间到当前时间是否满足计时器设置的下限时间。在达到这个下限时间后会在 poll 阶段控制 timers 执行回调。但系统调度或者其它回调的执行可能会延迟它们。
- 注意点1：技术上来说，poll 阶段控制 timers 什么时候执行。
- 注意点2：这个下限时间有个范围：`[1, 2147483647]`，如果设定的时间不在这个范围，将被设置为`1`。

比如下面这个例子：
```javascript
setTimeout(() => console.log(1))
setImmediate(() => console.log(2))
```
由于`setTimeout`在 timers 阶段执行，而`setImmediate`在 check 阶段执行。所以，`setTimeout`会早于`setImmediate`完成。所以上面代码应该先输出 1，再输出 2，但是实际执行的时候，结果却是不确定，有时还会先输出 2，再输出 1。

这是因为 setTimeout 的第二个参数默认为 0。但是实际上，Node 做不到 0 毫秒，最少也需要 1 毫秒，也就是说，`setTimeout(f, 0)`等同于`setTimeout(f, 1)`。

实际执行的时候，进入事件循环以后，有可能到了 1 毫秒，也可能还没到 1 毫秒，取决于系统当时的状况。如果没到 1 毫秒，那么 timers 阶段就会跳过，进入 check 阶段，先执行`setImmediate`的回调函数。
#### poll
poll 阶段有两个主要功能：
1. 执行下限时间已经达到的 timers 的回调。
2. 然后处理 poll 队列里的事件。

当 event loop 进入 poll 阶段，并且 没有设定的 timers（there are no timers scheduled）时，其流程如下：
- 如果 poll 队列中有回调函数需要执行，依次执行回调，直到清空队列或执行的回调数到达系统上限。
- 如果 poll 队列为空，则发生以下两件事之一：
  - 如果接下来的阶段设置了回调，则 event loop 将结束 poll 阶段进入下一阶段，直至完成本次循环，并进入下一次循环。
    - 比如：设置了`setImmediate`回调，event loop 将结束 poll 阶段进入 check 阶段来执行 check 队列。
  - 如果其他队列也都没有回调，则持续在 poll 队列等待，直到任何一个队列出现回调后再进行工作。
    - 比如当 poll 队列为空的一段时间内，如果有 1 个或多个 timers 的下限时间已经到达，event loop 会结束本次循环，并开始下一次循环执行 timer 队列。

比如下面这个例子：
```javascript
const fs = require('fs')
fs.readFile('test.js', () => {
  setTimeout(() => console.log(1))
  setImmediate(() => console.log(2))
  process.nextTick(() => {
    console.log('nextTick')
  })
  // 打印 :nextTick  2  1
})
```
上面代码会先在 poll 阶段持续等待。因为`fs`各个函数的回调是放在 poll 队列中的。

所以当`readFile`回调触发时，会在 poll 阶段立即执行。回调内执行`setTimeout`和`setImmediate`的函数后，check队列立即增加了回调。`readFile`回调执行完毕，会执行 nextTick 队列中的回调。

nextTick 队列的所有回调执行完成后，轮询检查其他队列有内容，程序结束 poll 阶段的等待状态，并进入 check 阶段，执行执行`setImmediate`回调，然后结束该轮循环，并进入下一轮循环。新一轮循环到达 timers 阶段后，检查`setTimeout`计时器符合条件，则定时器回调被执行。
#### check
这个阶段允许在 poll 阶段结束后立即执行回调。如果 poll 阶段空闲，并且有被`setImmediate()`设定的回调，event loop会转到 check 阶段而不是继续等待。

>`setImmediate()`实际上是一个特殊的timer，跑在 event loop 中一个独立的阶段。它使用 libuv 的 API 来设定在 poll 阶段结束后立即执行回调。

#### close callbacks
 如果一个`socket`或`handle`被突然关掉，比如`socket.destroy()`、`close事件`，将在这个阶段被触发，否则将通过`process.nextTick()`触发

>注意，只有前一个队列全部清空以后，才会执行下一个队列。
### nextTick 递归的危害
由于`nextTick`具有插队的机制，`nextTick`的递归会让事件循环机制无法进入下一个阶段. 导致I/O处理完成或者定时任务超时后仍然无法执行, 导致了其它事件处理程序处于饥饿状态. 为了防止递归产生的问题, Node.js 提供了一个`process.maxTickDepth`(默认 1000)。用于设置 nextTick 队列执行次数的上限。


## 使用 setTimeout 的一些注意事项
1. 如果当前任务执行时间过久，会影响定时器任务的执行
2. 如果`setTimeout`存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒
   - 在 Chrome 中，定时器被嵌套调用 5 次以上，系统会判断该函数方法被阻塞了，如果定时器的调用时间间隔小于 4 毫秒，那么浏览器会将每次调用的时间间隔设置为 4 毫秒。
3. 未激活的页面，`setTimeout`执行最小间隔是 1000 毫秒
4. 延时执行时间有最大值
   - Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果`setTimeout`设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，那么相当于延时值被设置为 0 了，这导致定时器会被立即执行。
5. `setTimeout`中回调函数内的`this`指向全局
