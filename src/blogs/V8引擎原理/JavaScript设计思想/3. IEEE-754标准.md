# IEEE-754 64位双精度浮点数

## 十进制转换为二进制

- **十进制整数转换为二进制整数**：采用”除2取余，逆序排列”法。
  - 具体做法是：用 2 去除十进制整数，可以得到一个商和余数；再用 2 去除商，又会得到一个商和余数，如此进行，直到商为零时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。
- **十进制小数转换成二进制小数**：采用”乘2取整，顺序排列”法。
  - 具体做法是：用 2 乘十进制小数，可以得到积，将积的整数部分取出，再用 2 乘余下的小数 部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的精度为止。然后把取出的整数部分按顺序排列起来，先取的整数作为二进制小数的高位有效位，后取的整数作为低位有效位。

如下图，将十进制`173.8125`转换为二进制：

<img src="https://github.com/zygg1512/myBlog/raw/master/images/V8引擎/十进制转换二进制.png" height="400px" />


## IEEE-754 标准
> [IEEE754生成器](https://www.binaryconvert.com/convert_double.html)

IEEE-754双精度浮点数(double floating-point)存储为64bit，由符号位(s)、偏差指数(e)、小数部分(f)组成：

<img src="https://github.com/zygg1512/myBlog/raw/master/images/V8引擎/IEEE754.png" />

组成       | 描述           | 位数    | 位置    |
| -------- | ------------ | ----- | ----- |
| sign     | 符号，0表示正，1表示负 | 1bit  | 63    |
| exponent | 偏差指数   | 11bit | 52-62 |
| fraction | 小数部分，有效数精度  | 52bit | 0-51 |

### 存储规则
```bash
V = (-1)^S * 2^(E - 1023) * (F + 1)
```
- `V`：需要存储的二进制数
- `S`：数值正负，0表示正数，1表示负数，对应1bit的符号位
- `E - 1023`：将二进制用科学计数法表示后的指数部分。即`a * 2^n`，其中 a 是由 0 和 1 组成的二进制表示，n 是整数。
  - E 是一个无符号整数，在 64 位浮点数中，指数位`E`的长度是 11 位，取值范围是`[0~2047]`。由于科学计数法中指数可正可负，所以，中间数是1023，`[0,1022]`表示为负，`[1024,2047]`表示为正
- `F`：为52位有效位，其中的每一位是 0 或 1，对应 52bit 的**小数部分**（不足 52 位补 0 ）。
  - 因为`F`表示的是二进制形式的浮点数，也就是说 M 的整数位始终是 1，所以可以舍去，只保留后面的小数部分，这样就能表示 53 位了。
  - 本质是 52 位显式存储，加 1 个隐藏位（值固定是 1），所以能表示 53 位。
#### 存储示例
比如计算`2.25`的双精度浮点数：
1. 2.25 转为二进制为 10.01
2. 数值为正，因此符号位 S 是 0
3. 10.01转为科学技术法后表示为 1.001 * 2^1，因此通过 E-1023 = 1，得出偏差指数 E 为 1024，二进制值为 10000000000（11位）
4. 将 1.001 的整数位 1 省略，保留小数位，小数位的值为 001，不足 52 位，补 0，得到`0010000000000000000000000000000000000000000000000000`, 001 后面有 49 个 0，共 52 位。

综上，将 1 位符号、11 位指数、52 位小数整合可得到 2.25 的双精度浮点数表示：
```bash
     0 10000000000 0010000000000000000000000000000000000000000000000000
#    S      E                               F
```
#### 小数部分的舍入问题
上面这个例子中，小数部分不存在舍入的问题（位数小于52位），那么如果小数超出了52位，有以下几种情况：
```txt
1. 第 53 位是 0，无需处理。
2. 第53位是 1 且 53 位之后全是 0：
  2-1. 若第 52 位是 0，无需处理。
  2-2. 若第 52 位是 1，那么向上舍入。
3. 第 53 位是 1，且之后不全是 0：那么向上舍入。
```

再看一个例子，计算`23.3`的双精度浮点数：

23.3 转为二进制为
```bash
10111.0100110011001100110011001100110011001100110011001100...(1100 循环)
```
数值为正，因此符号位 S 是 0。指数`E - 1023 = 4`，转为二进制后`E = 1027 = 10000000011`，因此偏差指数是`10000000011`。

小数位无限循环，53 位是 1 且之后不全是 0，符合上述规则 3，因此向上舍入，第 52 位由 0 变为 1，最终小数部分为：
```bash
0111010011001100110011001100110011001100110011001101
```
整合后得到 23.3 的双精度浮点数表示：

```bash
     0 10000000011 0111010011001100110011001100110011001100110011001101
#    S      E                               F
```

### 数值类型
11位的偏差指数可存储 00000000000 ~ 11111111111（十进制范围为0 ~ 2047），可分为3种情况：
- **规格化**：偏差指数不为 00000000000 和 11111111111，即在 00000000001 ~ 11111111110（1 ~ 2046）范围。
- **非规格化**：小数部分`F`和偏差指数`E`均为 0。
- **特殊值**：偏差指数为 11111111111（2047），有两种情况：
  - 当`F = 0`，且`S = 0`时，表示 +Infinity (正无穷)。
  - 当`F = 0`，且`S = 1`时，表示 -Infinity (正无穷)。
  - 当`F > 0`时，表示 NaN (Not a Number)。

## JavaScript 中的二进制问题

### toPrecision 和 toFixed
- `toPrecision`方法：以指定的精度返回该数值的字符串。精度是从左至右第一个不为 0 的数开始数起，支持四舍五入。
- `toFixed`方法：使用定点表示法返回该数值的字符串。是小数点后指定位数取整，从小数点开始数起，支持四舍五入。
```javascript
const x = 1.235
x.toPrecision(3) // "1.24"
const y = 1.2356
y.toFixed(3) // "1.236"
```
#### 问题点
这两个方法在截取数字时，都有进行四舍五入处理，但是都存在 BUG
```javascript
const a = 1.005
a.toPrecision(3) // 理论上应该返回 "1.01"，但实际上返回的是 "1.00"
const b = 1.005
b.toFixed(2) // 理论上应该返回 "1.01"，但实际上返回的是 "1.00"
```
原因是：1.005 实际对应的数字是 1.00499999999999989，在四舍五入时全部被舍去了。

### `0.1 + 0.2 = 0.30000000000000004`
在计算`0.1 + 0.2`的时候，会先将其转换为二进制，得到的结果也是二进制，然后再将其转换为十进制。

通过上述公式，`0.1`和`0.2`的二进制如下：
```bash
0.1: 0 01111111011 10011001100110011001100110011001100110011001100110011（53位）
# 0.1 的二进制会无限循环1100，且53位是1，之后不全是 0，符合上述规则3，向上取整后如下：
=>   0 01111111011 1001100110011001100110011001100110011001100110011010（52位）


0.2: 0 01111111100 10011001100110011001100110011001100110011001100110011（53位）
# 0.2 的二进制会无限循环1100，且53位是1，之后不全是 0，符合上述规则3，向上取整后如下：
=>   0 01111111100 1001100110011001100110011001100110011001100110011010（52位）
```
由于精度问题，存储`0.1`和`0.2`的二进制时会被向上取整，导致最后累加计算之后不等于`0.3`，而是等于`0.30000000000000004`。

**可通过扩大倍数再缩减倍数的方式解决。**
### 为什么`x = 0.1`能得到`0.1`？
0.1 的实际值是`0.100000000000000005551...`。
```javascript
0.1.toPrecision(21) // 0.100000000000000005551
```
因为 小数部分 固定长度是 52 位，再加上截取策略，最多可以表示的数是`2^53 - 1 = 9007199254740992`，这也是 JS 最多能表示的精度。它的长度是 16。所以仅展示至第 16 位。抹掉末尾的零后正好为 0.1。
```javascript
0.10000000000000000555.toPrecision(16) // 返回 0.1000000000000000，去掉末尾的零后正好为 0.1
```

### 数值范围
根据浮点数算术标准，偏差指数最大值为 2047，`E = 2047 -1023 = 1024`。

所以 JavaScript 能表示的数值范围是：`[-(2^1024-1), +(2^1024-1)]`，即：正负`1.7976931348623157 * 10^308`，但实际情况并不是这样：
```javascript
Math.pow(2, 1023) // 8.98846567431158e+307
Math.pow(2, 1024) // Infinity
```
#### 最大安全正整数和最小安全负整数
当`E - 1023 = 52`，即`E = 1075`，小数`F`最大（52 位全为 1 ）时，能表示出最大安全正整数为：
```bash
  1.111...11 * 2^52 = 111111.....1111
#   52个1                 53个1
```
转为十进制值为`2^53 - 1 = 9007199254740991`，相应的最小安全负整数为`-9007199254740991`。

JavaScript 规定能安全的表示数字(进行精确算术运算)的范围在：`[-2^53 - 1, +2^53 - 1]`。

对于超过这个范围的整数，JavaScript 依旧可以进行运算，但却不保证运算结果的准确性，这也是 JavaScript 中安全整数的两个边界：
- `Number.MIN_SAFE_INTEGER`
- `Number.MAX_SAFE_INTEGER`

超过安全整数范围的，计算不保证正确，例如：
```javascript
Math.pow(2, 53) // 9007199254740992
Math.pow(2, 53) + 1 // 9007199254740992
Math.pow(2, 53) + 2 // 9007199254740994
```
对于不在`[-2^53, +2^53]`范围中的数字，例如`(2^53, 2^63)`之间的数会出现什么情况呢？
- `(2^53, 2^54)`之间的数会两个选一个，只能精确表示偶数
- `(2^54, 2^55)`之间的数会四个选一个，只能精确表示 4 的倍数
- ...依次跳过更多 2 的倍数

## V8 是怎么执行加法操作的？
V8 会提供了一个 ToPrimitive 方法，其作用是将 a 和 b 转换为原生数据类型，其转换流程如下：
- 先检测该对象中是否存在`valueOf`方法，如果有并返回了原始类型，那么就使用该值进行强制类型转换。
- 如果`valueOf`没有返回原始类型，那么就使用`toString`方法的返回值。
- 如果`vauleOf`和`toString`两个方法都不返回基本类型值，便会触发一个`TypeError`的错误。

<img src="https://github.com/zygg1512/myBlog/raw/master/images/V8引擎/V8加法原理.webp" height="300px" />