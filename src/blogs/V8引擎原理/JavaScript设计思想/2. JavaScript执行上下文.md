# JavaScript执行上下文
执行上下文是 JavaScript 执行一段代码时的运行环境，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如`this`、变量、对象以及函数等。

JavaScript执行上下文主要包含4部分：
- 变量环境
- 词法环境
- 外部环境（存放在变量环境中）
- this

<img src="https://github.com/zygg1512/myBlog/raw/master/images/V8引擎/执行上下文总览.png" height="300px" />

## 什么时候会创建执行上下文
- 全局执行上下文：当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。
- 函数执行上下文：当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。
- eval执行上下文：当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。

### 全局执行上线文特点
全局执行上下文存储在堆中。

在V8引擎中，全局执行上下文是一个特殊的执行上下文，用于存储全局作用域中的变量和函数。与函数执行上下文不同，全局执行上下文不会存储在栈中，而是存储在堆中。

堆是一块用于动态分配内存的区域，用于存储对象和数据结构。全局执行上下文被视为一个特殊的对象，它包含了全局作用域中的变量和函数，并且在整个 V8 的生命周期中都存在。

当程序启动时，V8引擎会为全局执行上下文分配内存，并将全局变量和函数添加到该执行上下文中。这些全局变量和函数的值会一直保存在堆中，直到程序结束。

因此，全局执行上下文存储在堆中，而不是存储在栈中。
## 基于变量环境的变量提升
所谓的变量提升，是指在 JavaScript 代码执行过程中，V8 引擎把通过`var`关键字声明的变量的声明部分和函数的声明部分提升到代码开头的“行为”。

`var`声明的变量被提升后，会给变量设置默认值，这个默认值就是`undefined`。

### JavaScript 代码的执行流程
JavaScript 的执行机制：先编译，再执行。

<img src="https://github.com/zygg1512/myBlog/raw/master/images/V8引擎/JavaScript代码的执行流程.webp" width="600px" />

下面是一段 JavaScript 代码的执行流程

<img src="https://github.com/zygg1512/myBlog/raw/master/images/V8引擎/JavaScript代码的执行流程示例.webp"  height="400px"/>

从上图可以看出，JavaScript 代码执行过程如下：
1. JavaScript 代码执行过程中，需要先做变量提升，而之所以需要实现变量提升，是因为 JavaScript 代码在执行之前需要先编译。
2. 在编译阶段，代码被编译后，会生成两部分内容：**执行上下文（Execution context）**和**可执行代码**。变量和函数会被存放到变量环境中，变量的默认值会被设置为`undefined`。
   1. 在执行上下文中存在一个**变量环境的对象（Viriable Environment）**，该对象中保存了变量提升的内容，比如上面代码中的变量`myname`和函数`showName`，都保存在该对象中。
3. 生成了变量环境对象后。接下来 V8 引擎会把声明以外的代码编译为字节码。然后就是执行阶段。
4. 在代码执行阶段，V8 引擎会从变量环境中去查找自定义的变量和函数。如果在编译阶段存在两个相同的函数，那么最终存放在变量环境中的是最后定义的那个，这是因为后定义的会覆盖掉之前定义的。

#### 变量环境对象是如何生成的？
```javascript
showName()
console.log(myname)
var myname = '极客时间'
function showName() {
    console.log('函数showName被执行');
}
```
一行一行来分析上述代码：
- 第 1 行和第 2 行，由于这两行代码不是声明操作，所以 V8 引擎不会做任何处理；
- 第 3 行，由于这行是经过`var`声明的，因此 V8 引擎将在环境对象中创建一个名为`myname`的属性，并使用`undefined`对其初始化；
- 第 4 行，V8 引擎发现了一个通过`function`定义的函数，所以它将函数定义存储到堆（HEAP）中，并在环境对象中创建一个`showName`的属性，然后将该属性值指向堆中函数的位置

#### 调用栈
调用栈就是用来管理栈帧的。符合后进先出的规则。

每个函数在执行时会创建一个栈帧。栈帧（stack frame）是用来存储函数调用相关信息的数据结构，包括函数的参数、局部变量、临时变量等。本质上栈帧和函数执行上下文是同一概念。

在栈帧创建好后，V8 引擎会将栈帧压入栈中，通常把这种用来管理栈帧（执行上下文）的栈称为**执行上下文栈**，又称**调用栈**。
#### 变量提升的缺陷
**变量容易被覆盖掉**
```javascript
var myname = "极客时间"
function showName(){
  console.log(myname);
  if(0){
   var myname = "极客邦"
  }
  console.log(myname);
}
showName()
```
执行上面这段代码，打印出来的是`undefined`，在执行`showName`函数的时候由于变量提升导致`myname`的变量值不是全局变量中的`myname`，而是函数内的`myname`变量。

**本应销毁的变量没有被销毁**
```javascript
function foo(){
  for (var i = 0; i < 7; i++) {
  }
  console.log(i); 
}
foo()
```
执行上面这段代码后，变量`i`的值并未被销毁，所以最后打印出来的是 7。这同样也是由变量提升而导致的，在创建执行上下文阶段，变量`i`就已经被提升了，所以当`for`循环结束之后，变量`i`并没有被销毁。
## 基于词法环境的块级作用域
为了解决变量提升的这些问题，ES6 引入了`let`和`const`关键字，并引入了块级作用域。
- `var`的创建和初始化被提升，赋值不会被提升。
- `let`、`const`的创建被提升，初始化和赋值不会被提升。
  - 在块作用域内，`let`、`const`声明的变量被提升，但变量只是创建被提升，初始化并没有被提升，在初始化之前使用变量，就会形成一个暂时性死区。
- `function`的创建、初始化和赋值均会被提升。
### JavaScript 是如何支持块级作用域的
>ES6 是如何做到既要支持`var`的变量提升的特性，又要支持`let`、`const`的块级作用域的呢？

```javascript
function foo(){
    var a = 1
    let b = 2
    {
      let b = 3
      var c = 4
      let d = 5
      console.log(a)
      console.log(b)
    }
    console.log(b) 
    console.log(c)
    console.log(d)
}   
foo()
```
接下来一步步分析上面这段代码的执行流程。

**第一步是编译并创建`foo`函数的执行上下文。**

<img src="https://github.com/zygg1512/myBlog/raw/master/images/V8引擎/词法环境.webp" height="300px" />

通过上图，可以得出以下结论：
- 函数内部通过`var`声明的变量，在编译阶段全都被存放到**变量环境**里面了。
- 通过`let`、`const`声明的变量，在编译阶段会被存放到**词法环境（Lexical Environment）** 中。

**第二步继续执行代码**，当执行到块级作用域里面时，变量环境中`a`的值已经被设置成了 1，词法环境中`b`的值已经被设置成了 2，这时候函数的执行上下文就如下图所示：

<img src="https://github.com/zygg1512/myBlog/raw/master/images/V8引擎/词法环境2.webp" height="300px" />

从图中可以看出，当进入函数的作用域块时，作用域块中通过`let`声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量 `b`，在该作用域块内部也声明了变量`b`，当执行到作用域内部时，它们都是独立的存在。

其实，在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。

再接下来，当执行到作用域块中的`console.log(a)`这行代码时，就需要在词法环境和变量环境中查找变量`a`的值了。

具体查找方式是：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 V8 引擎，如果没有查找到，那么继续在变量环境中查找。

<img src="https://github.com/zygg1512/myBlog/raw/master/images/V8引擎/变量查找顺序.webp" height="300px" />

从上图可以清晰地看出变量在一个执行上下文中的查找流程。当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出，最终执行上下文如下图所示：

<img src="https://github.com/zygg1512/myBlog/raw/master/images/V8引擎/词法环境3.webp" height="300px" />

通过上面的分析，已经理解了词法环境的结构和工作机制：
- 块级作用域就是通过词法环境的栈结构来实现的。
- 而变量提升是通过变量环境来实现。

通过这两者的结合，V8 引擎也就同时支持了变量提升和块级作用域了。

## 基于外部环境的作用域链
### 作用域链是什么
当在 JavaScript 中使用一个变量的时候，首先 V8 引擎会尝试在当前词法作用域下去寻找该变量，如果没找到，再到它的上层词法作用域寻找，以此类推直到找到该变量或是已经到了全局作用域。

如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错。

#### 词法作用域
词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找变量。

也就是说词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系。

### 作用域链存储方式
**每个执行上下文的变量环境中，都包含了一个外部引用**，用来指向外部的执行上下文，我们把这个外部引用称为`outer`或`[[Scopes]]`。

当一段代码使用了一个变量时，JavaScript 引擎首先会在“当前的执行上下文”中查找该变量，如果没有查找到，那么 V8 引擎会继续在`outer`所指向的执行上下文中查找。
```javascript
function bar() {
    console.log(myName)
}
function foo() {
    var myName = "极客邦"
    bar()
}
var myName = "极客时间"
foo()
```
上述代码的作用域链如下所示：

<img src="https://github.com/zygg1512/myBlog/raw/master/images/V8引擎/调用栈.webp" height="400px" />

### 闭包
在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包（closure）。闭包是为了解决子函数晚于父函数销毁的问题。

```javascript
function foo() {
    var myName = "极客时间"
    let test1 = 1
    const test2 = 2
    var innerBar = {
        getName:function(){
            console.log(test1)
            return myName
        },
        setName:function(newName){
            myName = newName
        }
    }
    return innerBar
}
var bar = foo()
bar.setName("极客邦")
bar.getName()
console.log(bar.getName())
```
当上述代码执行到`bar.setName`方法中的`myName = "极客邦"`这句代码时，JavaScript 引擎会沿着“当前执行上下文–>foo 函数闭包–> 全局执行上下文”的顺序来查找 myName 变量

<img src="https://github.com/zygg1512/myBlog/raw/master/images/V8引擎/闭包.webp" height="400px" />

#### 闭包原理
在父函数执行过程中，会预解析子函数内容。如果在子函数中用到了在父函数中定义的变量，会在父函数销毁时把子函数引用到的变量打成 Closure 包存储在堆中，并将子函数`[[Scopes]]`属性指向 Closure 包
#### eval 的闭包
通过上面闭包原理我们知道，闭包的形成依赖预解析子函数内容，但`eval`的内容来源可能是网络文件、磁盘读取等，内容是动态的，无法做预解析。所以`eval`会直接将整个作用域打包成 Closure。所以尽量不要用`eval`。会导致闭包保存内容过多。

但是 V8 引擎只处理了直接调用，也就是说直接调用`eval`才会打包整个作用域，如果不直接调用`eval`，就没法分析引用，也就没法形成闭包了。比如下面的代码
```javascript
const a = 'g1'
const b = 'g2'
const c = 'g3'
const ee = eval
function test (){
    const a = 'test1'
    const b = 'test2'
    return function () {
        const c = 'test3'
        ee('console.log(a, b, c)')
    }
}
const t = test()() // g1 g2 g3
```
此时`eval`的父级作用域是全局作用域。

#### 闭包是怎么回收的
如果闭包使用不正确，会很容易造成内存泄漏。

通常，如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。

如果引用闭包的函数是个局部变量，等函数销毁后，在下次 V8 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 V8 引擎的垃圾回收器就会回收这块内存。

所以在使用闭包的时候，要尽量注意一个原则：**如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。**

## this
关于`this`，还是得先从执行上下文说起。在前几节中，我们提到执行上下文中包含了**变量环境**、**词法环境**、**外部环境**，但其实还有一个`this`没有提及。

this 是和执行上下文绑定的，也就是说每个执行上下文中都有一个 this。
### this 的类型
执行上下文主要分为三种——全局执行上下文、函数执行上下文和 eval 执行上下文，所以对应的 this 也只有这三种——全局执行上下文中的 this、函数中的 this 和 eval 中的 this。

### this 的缺陷和应对方案
#### 嵌套函数中的 this 不会从外层函数中继承
```javascript
var myObj = {
  name : "极客时间", 
  showThis: function(){
    console.log(this)
    function bar(){console.log(this)}
    bar()
  }
}
myObj.showThis()
```
上述代码中`bar`函数的`this`指向全局对象，解决方式如下：
- 第一种是把 this 保存为一个 self 变量，再利用变量的作用域机制传递给嵌套函数。
- 第二种是继续使用 this，但是要把嵌套函数改为箭头函数，因为箭头函数没有自己的执行上下文，所以它会继承调用函数中的 this。

#### 普通函数中的 this 默认指向全局对象 window
默认情况下调用一个函数，其执行上下文中的 this 是默认指向全局对象 window 的。解决方式如下：
- 通过`call`、`bind`、`apply`方法调用函数