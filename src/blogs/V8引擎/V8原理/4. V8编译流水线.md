# V8编译流水线
<img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/编译流水线.webp"  height="400px"/>

简要流程如下：
1. 宿主环境启动 V8，并初始化运行时环境，如堆空间和栈空间、全局执行上下文、事件循环系统等。
2. 将 JavaScript 的顶层代码转换成 AST 并生成作用域，当遇到函数时会预解析函数内容。用于检查是否存在语法错误和检查函数内部是否引用了外部变量，如果引用了外部的变量，解析器会将栈中的变量复制到堆（closure）中。
3. AST 生成之后会交由解释器解析并执行字节码，并输出结果。
4. 当发现有热点代码（HotSpot）时，后台的编译器 TurboFan 就会把该段字节码编译为机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码。

## 编译器和解释器
之所以存在编译器和解释器，是因为机器不能直接理解高级语言的代码，所以在执行程序之前，需要将高级语言的代码“翻译”成机器能读懂的机器语言。按语言的执行流程，可以把语言划分为编译型语言和解释型语言。
- 编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。比如 C/C++、GO 等都是编译型语言。
- 解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。比如 Python、JavaScript 等都属于解释型语言。

流程如下：

<img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/编译器和解释器.webp" height="400px" />

- 在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。
- 在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。
## 初始化运行时环境
V8的执行需要有一个宿主环境，宿主环境可以是浏览器中的渲染进程，可以是 Node.js 进程, 也可以是其他的定制开发的环境。

宿主在启动 V8 时，会初始化一部分基础环境给 V8 使用，这包括了堆空间和栈空间、全局执行上下文、事件循环系统。除了需要宿主提供的一些基础环境之外，V8 自身会提供 JavaScript 的核心功能和垃圾回收系统。

<img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/V8初始化环境.webp" height="300px" />

宿主环境在启动过程中，会构造堆空间，用来存放一些对象数据，还会构造栈空间，用来存放原生数据。由于堆空间中的数据不是线性存储的，所以堆空间可以存放很多数据，但是读取的速度会比较慢，而栈空间是连续的，所以堆空间中的查找速度非常快，但是要在内存中找到一块连续的区域却显得有点难度，于是所有的程序都限制栈空间的大小，这就是我们经常容易出现栈溢出的一个主要原因。

如果在浏览器中，JavaScript 代码会频繁操作 `window`、操作 dom 等内容，如果在 Node 中，JavaScript 会频繁使用 `global`、File API 等内容，这些内容都会在启动过程中准备好，我们把这些内容称之为全局执行上下文。

全局执行上下文中和函数的执行上下文生命周期是不同的，函数执行上下文在函数执行结束之后，就会被销毁，而全局执行上下文则和 V8 的生命周期是一致的，所以在实际项目中，如果不经常使用的变量或者数据，最好不要放到全局执行上下文中。

另外，宿主环境还需要构造事件循环系统，事件循环系统主要用来处理任务的排队和任务的调度。
## 解析 JavaScript 代码

<img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/解析JavaScript代码.webp" height="300px" />

V8 执行 JavaScript 代码前会先将 JavaScript 代码转换成 AST（抽象语法树），并生成作用域。然后再将 AST（抽象语法树）通过解释器 Ignition 解析为中间代码。

### 解析方式
在解析 JavaScript 代码的过程中，V8 并不会一次性将所有的 JavaScript 解析为中间代码，这主要是基于以下两点：
- 首先，如果一次解析和编译所有的 JavaScript 代码，过多的代码会增加编译时间，这会严重影响到首次执行 JavaScript 代码的速度，让用户感觉到卡顿。因为有时候一个页面的 JavaScript 代码都有 10 多兆，如果要将所有的代码一次性解析编译完成，那么会大大增加用户的等待时间；
- 其次，解析完成的字节码和编译之后的机器代码都会存放在内存中，如果一次性解析和编译所有 JavaScript 代码，那么这些中间代码和机器代码将会一直占用内存，特别是在手机普及的年代，内存是非常宝贵的资源。

基于以上的原因，所有主流的 JavaScript 虚拟机通过解析器和预解析器实现了**惰性解析**。

所谓惰性解析是指**解析器**只会为顶层代码生成 AST 和字节码。如果遇到函数声明，V8会引用**预解析器**，**预解析器**会对该函数做一次快速的预解析，不会为函数生成 AST 和中间代码。

预解析的目的有两个：
1. 判断当前函数是不是存在一些语法上的错误。
2. 检查函数内部是否引用了外部变量，如果引用了外部的变量，解析器会将栈中的变量复制到堆（closure）中，在下次执行到该函数的时候，直接使用堆中的引用，这样就解决了闭包所带来的问题。

### AST 生成流程
通常，生成 AST 需要经过两个阶段（先分词，再解析）。
- **第一阶段是分词（tokenize），又称为词法分析。**
  - 其作用是将一行行的源码拆解成一个个 token。所谓 token，指的是语法上不可能再分的、最小的单个字符或字符串。

<img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/V8AST生成流程.webp" height="200px" />

- **第二阶段是解析（parse），又称为语法分析。**
  - 作用是将上一步生成的 token 数据，根据语法规则转为 AST。如果源码符合语法规则，这一步就会顺利完成。但如果源码存在语法错误，这一步就会终止，并抛出一个“语法错误”。

### 字节码
字节码就是介于 AST 和机器码之间的一种代码。字节码是平台无关的，机器码针对不同的平台都是不一样的。

字节码的优势有如下三点：
- **解决启动问题：生成字节码的时间很短。**
  - 解释器可以快速生成字节码，但字节码通常效率不高。生成机器代码比生成字节码需要花费更久的时间，但是直接执行机器代码却比解释执行字节码要更高效。

- **解决空间问题：字节码占用内存不多，缓存字节码会大大降低内存的使用。**
  - 下图是高级代码、字节码和机器码的比对关系
 
<img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/字节码和机器码.webp" height="200px"/>

- **代码架构清晰：采用字节码，可以简化程序的复杂度，使得 V8 移植到不同的 CPU 架构平台更加容易。**
  - 引入了字节码，就可以统一将字节码转换为不同平台的二进制代码。因为字节码的执行过程和 CPU 执行二进制代码的过程类似，相似的执行流程，那么将字节码转换为不同架构的二进制代码的工作量也会大大降低，这就降低了转换底层代码的工作量。

## 解释器解释执行字节码
生成字节码之后，接下来就要进入执行阶段了。通常，如果有一段**第一次执行的字节码**，解释器 Ignition 会逐条解释执行。解释器 Ignition 除了负责生成字节码之外，它还有另外一个作用，就是解释执行字节码。

在 Ignition 执行字节码的过程中，如果发现有热点代码（HotSpot），比如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码，然后当再次执行这段被优化的代码时，只需要执行编译后的机器码就可以了，这样就大大提升了代码的执行效率。
### 即时编译（JIT）
具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。

<img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/即时编译流程.webp" height="500px" />