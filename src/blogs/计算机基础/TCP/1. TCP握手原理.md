# TCP握手原理
## TCP基础
<img height="300px" src="https://github.com/zygg1512/myBlog/raw/master/assets/http/tcp/tcp组成.png" />

TCP首部主要有两部分组成：
- 20字节（1字节 = 8位）的固定首部部分
- 长度可变的其他选项；所以TCP首部长度可变，但最多40个字节

首部又分为5部分，每部分4个字节（32位），如图中的前5行，每行表示32位。
### 首部构成
#### 其他首部字段
- **源端口和目的端口字段**：端口是运输层与应用层的服务接口。运输层的复用和分用功能都要通过端口才能实现

- **数据偏移（即首部长度）**：TCP首部的长度。最大二进制是 1111（60），即表示TCP首部最大长度为60个字节，因此“选项”部分最多40个字节

- **保留字段**：保留为今后使用，但目前应置为 0

- **标志位**：
  - ACK：TCP规定，在连接建立后传送的所有报文段都必须把ACK置为1
    - 仅当ACK = 1时**确认应答号**才有效，当ACK = 0时**确认应答号**无效

  - RST：该位为 1 时，表示 TCP 连接中出现异常必须强制断开连接

  - SYN：在连接建立时用来同步序号；**SYN=1**就表示这是一个连接请求或连接接受报文
    - 当**SYN=1**而**ACK=0**时，表明这是一个**连接请求报文段**，对方若同意建立连接，则应在响应的报文段中使SYN=1和ACK=1

  - FIN：该位为 1 时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换 FIN 位为 1 的 TCP 段

  - URG —— 当 URG = 1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快传送(相当于高优先级的数据)。 即URG=1的数据包不用排队直接优先传输

- **窗口大小** ：用来让对方设置发送窗口的依据

- **检验和**：检验和字段检验的范围包括首部和数据这两部分。在计算检验和时，要在TCP 报文段的前面加上 12 字节的伪首部

- **紧急指针字段**：指出在本报文段中紧急数据共有多少个字节（紧急数据放在本报文段数据的最前面）

- **确认应答号**：指服务端下一次「期望」收到的数据的序列号，客户端收到这个确认应答以后可以认为在这个序号以前的数据都已经被正常接收。用来解决丢包的问题

-  **序列号**：用来解决网络包乱序问题

#### 序列号字段
序列号和确认应答号是 TCP 实现可靠传输的依赖。TCP 使用序列号来记录发送数据包的顺序。

- 对发送方而言，传送一个数据包后，只有在指定时间里收到这个包的确认信息，才会将其从队列中删除，否则会重新发送该数据包

- 对接收方而言，通过数据分段中的序列号可以保证数据能够按照正常的顺序进行重组

##### 和SYN标志位的关系
- 在 SYN 设置为 1 时，当前序列号表示的是连接的初始序列号（ISN）

- 在 SYN 设置为 0 时，当前序列号表示的是当前报文段中的第一个字节的序列号

##### 序列号的规则
- 握手阶段，`[SYN]` 包即使没有传送数据，也会消耗一个序列号。因此，建立连接后的序列号从 `ISN+1` 开始

- 挥手阶段，`[FIN/ACK]` 包即使没有传送数据，也会消耗掉一个序列号

- 数据传输阶段，序列号 = 第一个报文段的序列号 + 已经发送的字节数
    - 比如第一个报文段的序列号为 `S`，已经发送了 100 个字节，则下一个报文段的序列号为 `S+100`

    - 如果某个报文段不携带数据，不会消耗序列号，下一个报文段还是用相同的序列号发送

    - 正常情况下，B 给 A 的确认号，就是 A 下一个报文段的序列号

- 客户端三次握手第三步的 `[ACK]` 包，和传输阶段的第一个报文段，有相同的序列号

## TCP三次握手

<img height="400px" src="https://github.com/zygg1512/myBlog/raw/master/assets/http/tcp/三次握手.png" />

### 详情

#### 第一次握手：客户端发送 SYN 包给服务端

>SYN-SENT 状态：发送了连接请求，等待远端的确认

客户端向服务端发起连接请求，请求发送后，客户端便进入 SYN-SENT 状态。向服务端发送的报文段包含：
- SYN标志位(也就是SYN=1)

- 序列号seq=100。客户端随机生成一个起始序列号ISN(比如是100)

#### 第二次握手：服务端回应（SYN + ACK）包
>SYN-RECEIVED 状态：收到了连接请求并发送了确认报文，等待最终的确认

服务端收到客户端发过来的报文后，发现SYN=1，知道这是一个连接请求，于是将客户端的起始序列号100存起来，并且随机生成一个服务端的起始序列号(比如是300)。然后给客户端回复一段报文，发送完成后便进入 SYN-RECEIVED 状态。回复报文包含

- SYN和ACK标志(也就是SYN=1,ACK=1)

- 序列号seq=300

- 确认号ack=101(客户端发过来的序列号+1)

#### 第三次握手：客户端回应 ACK 包给服务端
>ESTABLISHED 状态：socket 已经建立了连接，这是数据传输阶段的状态

客户端收到服务端的回复后发现ACK=1并且ack=101,于是知道服务端已经收到了序列号为100的那段报文；同时发现SYN=1，知道了服务端同意了这次连接，于是就将服务端的序列号300给存下来。然后客户端再回复一段报文给服务端，报文包含ACK标志位(ACK=1)、ack=301(服务端序列号+1)、seq=101。

当服务端收到报文后发现ACK=1并且ack=301，就知道客户端收到序列号为300的报文了，就这样客户端和服务端通过TCP建立了连接。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态。

**TCP规定：**ACK报文可以携带数据。但是，如果不携带数据，则不消耗序号，这时，下一数据报文段的序号仍是**seq=x+1**。

### SYN 泛洪攻击

TCP 只有经过三次握手才能连接，而 SYN 泛洪攻击就是针对 TCP 握手过程进行攻击：
- 攻击者发送大量的 SYN 包给服务器（第一次握手成功）

- 服务器回应（SYN + ACK）包（第二次握手成功）

- 但是攻击者不回应 ACK 包（第三次握手不进行）

导致服务器存在大量的半开连接，这些半连接可以耗尽服务器资源，使被攻击服务器无法再响应正常 TCP 连接，从而达到攻击的目的

幸运的是，一种称为 SYN cookie 的有效防御现在已部署在大多数主要的操作系统中：

- 在客户端发送 SYN 报文给服务器（第一次握手），服务端收到连接请求报文段后，服务器不会为此SYN创建半开连接，而是生成一个序列号（所谓的 cookie）一起发送给客户端（第二次握手），在这个阶段，服务器不会为该连接分配任何资源
- 客户端返回 ACK 报文给服务器（第三次握手），服务器会验证这个 cookie 值，只有验证成功才创建 TCP 连接，分配资源
- 如果客户端没有返回 ACK 报文给服务器，也不会对服务器造成任何的伤害，因为服务器没有分配任何资源给它

## TCP四次挥手

<img height="400px" src="https://github.com/zygg1512/myBlog/raw/master/assets/http/tcp/四次挥手.png" />

### 详情
#### 第一次挥手：客户端发送 FIN + ACK 包给服务端
>FIN_WAIT1状态：发送了连接终止请求，等待确认，通常持续时间较短

客户端向服务端发送**连接释放报文**（FIN=1，ACK=1），主动关闭连接，同时等待服务端的确认，进入FIN_WAIT1状态

- 序列号 seq = m，即客户端上次发送的报文的最后一个字节的序号 + 1

- 确认号 ack = k, 即服务端上次发送的报文的最后一个字节的序号 + 1

#### 第二次挥手：服务端发送 ACK 包给服务端

服务端收到连接释放报文后，立即发出**确认报文**（ACK=1），序列号 seq = n，确认号 ack = m + 1

这时 TCP 连接处于半关闭，即客户端到服务端的连接已经释放了，但是服务端到客户端的连接还未释放。这表示客户端已经没有数据发送了，但是服务端可能还要给客户端发送数据。

此时客户端进入FIN_WAIT2 状态，服务端进入CLOSE_WAIT 状态
- FIN_WAIT2 状态：发送了连接终止请求并收到了远程的确认，等待远程 TCP 的连接终止请求，这个状态表明远程在收到此 socket 的连接终止请求后，没有立刻关闭它的 socket

- CLOSE_WAIT 状态：收到了远程的连接终止请求，正在等待本地的应用程序发出连接终止请求

#### 第三次挥手：服务端发送 FIN + ACK 包给服务端

服务端向客户端发送**连接释放报文**（FIN=1，ACK=1），主动关闭连接，同时等待客户端的确认

- 序列号 seq = p，即服务端上次发送的报文的最后一个字节的序号 + 1。如果半关闭状态，服务端没有发送数据，那么 w == k
- 确认号 ack = m + 1，与第二次挥手相同，因为这段时间客户端没有发送数据

此时客户端进入TIME_WAIT状态，服务端进入LAST_ACK状态
- TIME_WAIT状态：等待足够的时间，以确保远程 TCP 收到其连接终止请求的确认

- LAST_ACK状态：等待先前发送的连接终止请求的确认，只有在发送连接终止请求前先收到了远程的连接终止请求时，才会进入此状态

#### 第四次挥手：服务端发送 ACK 包给服务端

客户端收到服务端的连接释放报文后，立即发出**确认报文**（ACK=1），序列号 seq = m + 1，确认号为 ack = p + 1

此时，客户端就进入了 `TIME-WAIT` 状态。注意此时客户端到服务端的 TCP 连接还没有释放，必须经过 2*MSL（最长报文段寿命）的时间后，才进入 `CLOSED` 状态。而服务端只要收到客户端发出的确认，就立即进入 `CLOSED` 状态。可以看到，服务端结束 TCP 连接的时间要比客户端早一些。

- CLOSED状态：发送了连接终止请求后，收到了远程的连接终止请求，正在等待远程对连接终止请求的确认，这个状态表明双方同时进入关闭状态。socket 已经没有连接状态

TCP 规定，`[FIN/ACK]` 包即使没有传送数据，也会消耗掉一个序列号。`[FIN/ACK]` 包是第一、三次挥手：

- 第一次挥手时，客户端的序列号 seq = u，消耗一个序列号。因此：
    - 第二次挥手时，服务端的确认号 ack = u + 1
    - 第四次挥手时，客户端的序列号 seq = u + 1
- 第三次挥手时，服务端的序列号 seq = w，消耗一个序列号。因此：
    - 第四次挥手时，客户端的确认号 ack = w + 1

### 为什么需要四次挥手

因为 **TCP 是全双工的**，一方关闭连接后，另一方还可以继续发送数据。所以四次挥手，将断开连接分成两个独立的过程。

### 第四次挥手，为什么客户端的 TIME-WAIT 状态必须等待 2MSL 的时间才能返回到 CLOSED 状态？

主要有两个原因：

**(1) 确保 ACK 报文能够到达服务端，从而使服务端正常关闭连接。**

第四次挥手时，客户端第四次挥手的 ACK 报文不一定会到达服务端。服务端会超时重传 FIN/ACK 报文，此时如果客户端已经断开了连接，那么就无法响应服务端的二次请求，这样服务端迟迟收不到 FIN/ACK 报文的确认，就无法正常断开连接。

MSL 是报文段在网络上存活的最长时间（RFC 973指定 MSL 为 2 分钟，然而，在实现中的常用值是30s、1分钟、2分钟）。客户端等待 2MSL 时间，即「客户端 ACK 报文 1MSL + 服务端 FIN 报文 1MSL」，就能够收到服务端重传的 FIN/ACK 报文，然后客户端重传一次 ACK 报文，并重新启动 2MSL 计时器。如此保证服务端能够正常关闭。

那如果服务端重发的 FIN 没有成功地在 2MSL 时间里传给客户端，服务端会继续超时重试直到断开连接。

**(2) 防止已失效的连接请求报文段出现在之后的连接中。**

TCP 要求在 2MSL 内不使用相同的序列号。客户端在发送完最后一个 ACK 报文段后，再经过时间 2MSL，就可以保证本连接持续的时间内产生的所有报文段都从网络中消失。这样就可以使下一个连接中不会出现这种旧的连接请求报文段。或者即使收到这些过时的报文，也可以不处理它。

### 如果已经建立了连接，但是客户端出现故障了怎么办？

或者说，如果三次握手阶段、四次挥手阶段的包丢失了怎么办？比如上面描述的“服务端重发 FIN”的问题。

简而言之，通过**定时器 + 超时重试机制**，尝试获取确认，直到最后会自动断开连接。

具体而言，TCP 设有一个保活计时器。服务器每收到一次客户端的数据，都会重新复位这个计时器，时间通常是设置为 2 小时。若 2 小时还没有收到客户端的任何数据，服务器就开始重试：每隔 75 秒发送一个探测报文段，若一连发送 10 个探测报文后客户端依然没有回应，那么服务器就认为连接已经断开了。

### TIME_WAIT 是主动断开连接的一方、还是被动断开连接的一方会进入的状态？
`TIME_WAIT` 是主动断开连接的一方会进入的状态。

`TIME_WAIT` 需要等待 2MSL，在大量短连接的情况下，`TIME_WAIT` 会太多，这也会消耗很多系统资源。对于服务器来说，在 HTTP 协议里指定 KeepAlive（浏览器重用一个 TCP 连接来处理多个 HTTP 请求），由浏览器来主动断开连接，可以一定程度上减少服务器的这个问题。

### 如果已经建立了连接，但是服务端的进程崩溃会发生什么？

TCP 的连接信息是由内核维护的，所以当服务端的进程崩溃后，内核需要回收该进程的所有 TCP 连接资源，于是内核会发送第一次挥手 FIN 报文，后续的挥手过程也都是在内核完成，并不需要进程的参与，所以即使服务端的进程退出了，还是能与客户端完成 TCP 四次挥手的过程。

## TCP 和 UDP的区别
- TCP 是面向连接的、可靠的、有序的、速度慢的协议；UDP 是无连接的、不可靠的、无序的、速度快的协议
- TCP 开销比 UDP 大，TCP 头部需要 20 字节，UDP 头部只要 8 个字节
- TCP 无界有拥塞控制，UDP 有界无拥塞控制

| 特性 |TCP|UDP|解释|
| --- | --- |--- |--- |
|连接性|面向连接|无连接| TCP 发送数据前使用三次握手建立连接，UDP 发送数据前不需要建立连接<br/>- 面向连接举例：两个人之间通过电话进行通信<br/>- 面向无连接举例：邮政服务，用户把信函放在邮件中期待邮政处理流程来传递邮政包裹。显然，不可达代表不可靠|
|报文|面向字节流|面向报文| |
|可靠性|可靠|不可靠|TCP 丢包会自动重传，UDP 不会。<br/>TCP 可靠性由三个机制保证：<br/>1. 序号（TCP 报文的序号）<br/>2. 确认（ACK 机制）<br/>3. 重传（超时或者冗余的 ACK）|
|有序性|有序|无序|消息在传输过程中可能会乱序，后发送的消息可能会先到达，TCP 会对其进行重新排序，UDP 不会|
|有界性|有界|无界|TCP 通过字节流传输，UDP 中每一个包都是单独的<br/>- 对于TCP协议，客户端连续发送数据，只要服务端的缓冲区足够大，会一次性接收过来<br/>- 而对于UDP协议，客户端连续发送数据，即使服务端的缓冲区足够大，也只会一次一次的接收，发送多少次接收多少次，即客户端分几次发送过来，服务端就必须按几次接收|
|拥塞控制、流量控制|有|无|TCP 通过流量和拥塞控制机制确保发送方不会过快地传输过多的数据，以免压垮接收方。而UDP没有提供流量和拥塞控制，数据包要么按连续顺序接收，要么被丢弃。|
|传输速度|慢|快|因为 TCP 需要建立连接、保证可靠性和有序性，所以比较耗时。这就是为什么视频流、广播电视、在线多媒体游戏等选择使用 UDP|
|量级|重量级|轻量级|TCP 要建立连接、保证可靠性和有序性，就会传输更多的信息，如 TCP 的包头比较大|
|头部大小|大|小|TCP 头部需要 20 字节，UDP 头部只要 8 个字节|

### 何时使用 TCP 和 UDP？
UDP适用于效率和速度比可靠性更为重要的应用程序：
- 简单文件传输协议（TFTP）
- 域名系统（DNS）
- VPN隧道
- 网络语音传输协议（VoIP）
- 在线游戏
- 流媒体传输
TCP适用于可靠性比时效性更重要的应用程序：
- 电子邮件（POP、SMTP和IMAP）
- 安全外壳协议（SSH）
- 网页浏览（HTTP和HTTPS）
- 文件传输协议（FTP）