import{_ as s,c as i,o as a,a4 as n}from"./chunks/framework.BOW58p_D.js";const F=JSON.parse('{"title":"node_modules目录结构","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/前端基础/Node/包管理工具/NPM/2. node_modules目录结构.md","filePath":"blogs/前端基础/Node/包管理工具/NPM/2. node_modules目录结构.md"}'),e={name:"blogs/前端基础/Node/包管理工具/NPM/2. node_modules目录结构.md"},l=n(`<h1 id="node-modules目录结构" tabindex="-1">node_modules目录结构 <a class="header-anchor" href="#node-modules目录结构" aria-label="Permalink to &quot;node_modules目录结构&quot;">​</a></h1><p>假设项目<code>App</code>中有如下三个依赖：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dependencies&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;A&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1.0.0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;B&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1.0.0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;C&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1.0.0&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>A、B、C三个模块又有如下依赖：</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>A@1.0.0 -&gt; D@1.0.0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>B@1.0.0 -&gt; D@2.0.0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>C@1.0.0 -&gt; D@1.0.0</span></span></code></pre></div><h2 id="npm-2-x-嵌套结构" tabindex="-1">npm 2.x - 嵌套结构 <a class="header-anchor" href="#npm-2-x-嵌套结构" aria-label="Permalink to &quot;npm 2.x - 嵌套结构&quot;">​</a></h2><p><code>npm 2.x</code>安装依赖方式比较简单直接，以递归的方式，按照包依赖的树形结构下载填充本地目录结构，也就是说每个包都会将该包的依赖安装到当前包所在的<code>node_modules</code>目录中。执行<code>npm install</code>后，项目<code>App</code>的<code>node_modules</code>会变成如下目录结构：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">├──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node_modules</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">│</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   ├──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> A@1.0.0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">│</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   │</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   └──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node_modules</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">│</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   │</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   │</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   └──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> D@1.0.0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">│</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   ├──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> B@1.0.0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">│</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   │</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   └──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node_modules</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">│</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   │</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   │</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   └──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> D@2.0.0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">│</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   └──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> C@1.0.0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">│</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   │</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   └──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node_modules</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">│</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   │</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   │</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   └──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> D@1.0.0</span></span></code></pre></div><p>很显然这样的依赖组织结构，有如下优点：</p><ul><li>层级结构明显</li><li>简单的实现了多版本兼容</li><li>保证了对依赖包无论是安装还是删除都会有统一的行为和结构</li></ul><p>但是缺点也一样很明显：</p><ul><li>可能造成相同模块大量冗余问题</li><li>可能造成目录结构嵌套比较深的问题</li></ul><h2 id="npm-3-x-扁平结构" tabindex="-1">npm 3.x - 扁平结构 <a class="header-anchor" href="#npm-3-x-扁平结构" aria-label="Permalink to &quot;npm 3.x - 扁平结构&quot;">​</a></h2><p><code>npm 3.x</code>则采用了扁平化的结构来安装组织<code>node_modules</code>也就是在执行<code>npm install</code>的时候，按照<code>package.json</code>里依赖的顺序依次解析，<strong>遇到新的包就把它安装在第一级目录，后续安装如果遇到一级目录已经存在的包，会先按照约定版本判断版本，如果符合版本约定则忽略，否则会按照<code>npm 2.x</code>的方式依次挂在依赖包目录下</strong>假设有如下两个包，都依赖<code>xxx</code>：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">├──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> foo</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">│</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   ├──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> xxx@1.2.1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">├──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bar</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">│</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   └──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> xxx@1.3.0</span></span></code></pre></div><p>通过 npm/yarn 扁平化之后他的结构可能是下面两种：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 种类一</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">├──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> foo</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">├──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> xxx@1.2.1</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">├──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bar</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">│</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   └──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> xxx@1.3.0</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 种类二</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">├──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bar</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">├──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> xxx@1.3.0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">├──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> foo</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">│</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   └──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> xxx@1.2.1</span></span></code></pre></div><p>具体顺序取决于<code>foo</code>和<code>bar</code>在<code>package.json</code>中的位置，如果<code>foo</code>声明在前面，那么就是前面的结构，否则是后面的结构，也就是说 <strong>npm3.x 存在依赖结构不确定的问题。</strong></p><p><strong>这也是 lock 文件诞生的原因，无论是<code>package-lock.json</code>(npm 5.x才出现)还是<code>yarn.lock</code>，都是为了保证 install 之后都产生确定的 node_modules 的目录结构。</strong></p><h2 id="npm-5-x-package-lock-json" tabindex="-1">npm 5.x - package-lock.json <a class="header-anchor" href="#npm-5-x-package-lock-json" aria-label="Permalink to &quot;npm 5.x - package-lock.json&quot;">​</a></h2><p>从<code>npm 5.x</code>开始，安装<code>node_modules</code>和<code>npm 3.x</code>一样采用了扁平化的方式。</p><p>最大的变化是增加了<code>package-lock.json</code>文件。<code>package-lock.json</code>的作用是锁定依赖结构，即只要目录下有<code>package-lock.json</code>文件，那么每次执行<code>npm install</code>后 <strong>生成的<code>node_modules</code>目录结构一定是完全相同的</strong></p><blockquote><p><strong>包版本锁定文件保证了<code>node_modules</code>的目录结构。</strong></p></blockquote><p><code>npm</code>为了让开发者在安全的前提下使用最新的依赖包，在<code>package.json</code>中通常做了 <strong>锁定大版本</strong> 的操作。这样在每次<code>npm install</code>的时候都会拉取依赖包 <strong>大版本下的最新的版本</strong>。</p><h3 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ul><li>当有依赖包有 <strong>小版本更新</strong> 时，可能会出现 <strong>协同开发者的依赖包不一致的问题。</strong></li><li>扁平化算法复杂。</li><li>package 非法访问，即项目内可以直接使用依赖包的依赖项。 ###<code>package-lock.json</code>文件 <code>package-lock.json</code>文件精确描述了<code>node_modules</code>目录下所有的包的树状依赖结构，每个包的版本号都是完全精确的。以<code>sass-loader</code>在<code>package-lock.json</code>中为例：</li></ul><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dependencies&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;sass-loader&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;version&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;7.1.0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;resolved&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;http://registry.npm.taobao.org/sass-loader/download/sass-loader-7.1.0.tgz&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;integrity&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;sha1-Fv1ROMuLQkv4p1lSihly1yqtBp0=&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;dev&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;requires&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;clone-deep&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;^2.0.1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;loader-utils&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;^1.0.1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;lodash.tail&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;^4.1.1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;neo-async&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;^2.5.0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;pify&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;^3.0.0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;semver&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;^5.5.0&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    &quot;dependencies&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      &quot;pify&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        &quot;version&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;3.0.0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        &quot;resolved&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;http://registry.npm.taobao.org/pify/download/pify-3.0.0.tgz&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        &quot;integrity&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;sha1-5aSs0sEB/fPZpNB/DbxNtJ3SgXY=&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        &quot;dev&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>package-lock.json</code>的详细描述主要由下面几个字段构成： -<code>version</code>：包唯一的版本号 -<code>resolved</code>：安装源 -<code>integrity</code>：表明包完整性的<code>hash</code>值（验证包是否已失效） -<code>dev</code>：如果依赖项在<code>devDependencies</code>中声明，其本身以及子依赖都会被设置为<code>dev: true</code> -<code>requires</code>：依赖包中<code>package.json</code>文件中的<code>dependencies</code>列表，版本号也一致 -<code>dependencies</code>：如果根目录<code>node_modules</code>中的大版本与依赖包所需大版本不同时，会将依赖包的<code>dependencies</code>中的依赖项安装到依赖包的<code>node_modules</code>中，而<code>dependencies</code>属性就是存储安装在依赖包的<code>node_modules</code>中的所有子依赖</p><ul><li>这里注意，并不是所有的子依赖都有<code>dependencies</code>属性，只有子依赖包的依赖和当前已安装在根目录的<code>node_modules</code>中的依赖包冲突之后，才会有这个属性。</li></ul><p><code>package-lock.json</code>文件和<code>node_modules</code>目录结构是一一对应的，即项目目录下存在<code>package-lock.json</code>可以让每次安装生成的 <strong>依赖目录结构保持相同</strong>。</p><h3 id="使用建议" tabindex="-1">使用建议 <a class="header-anchor" href="#使用建议" aria-label="Permalink to &quot;使用建议&quot;">​</a></h3><ul><li>在开发一个应用时，建议把<code>package-lock.json</code>文件提交到代码版本仓库。</li><li>在开发一个库时，则不应把<code>package-lock.json</code>文件发布到仓库中。</li></ul><p>实际上，<code>npm</code>也默认不会把<code>package-lock.json</code>文件发布出去。之所以这么做，是因为库项目一般是被其他项目依赖的，在不写死的情况下，就可以复用主项目已经加载过的包，而一旦库依赖的是精确的版本号那么可能会造成包的冗余。</p><h3 id="关于不同开发者安装依赖导致package-lock-json发生变化的原因" tabindex="-1">关于不同开发者安装依赖导致package-lock.json发生变化的原因 <a class="header-anchor" href="#关于不同开发者安装依赖导致package-lock-json发生变化的原因" aria-label="Permalink to &quot;关于不同开发者安装依赖导致package-lock.json发生变化的原因&quot;">​</a></h3><p><code>npm 2.x/3.x</code>已成为过去式，在<code>npm 5.x</code>以上环境下（版本最好在<code>5.6</code>以上，因为在<code>5.0 ~ 5.6</code>中间对<code>package-lock.json</code>的处理逻辑更新过几个版本，<code>5.6</code>以上才开始稳定），以<code>^</code>版本为例，其他类型版本按版本限制规则参照即可：</p><h4 id="在大版本相同的前提下" tabindex="-1">在大版本相同的前提下 <a class="header-anchor" href="#在大版本相同的前提下" aria-label="Permalink to &quot;在大版本相同的前提下&quot;">​</a></h4><p>如果一个模块在<code>package.json</code>中的小版本、补丁版本大于<code>package-lock.json</code>中的小版本、补丁版本时：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// package.json</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;clipboard&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;^1.5.12&quot;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// package-lock.json</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;clipboard&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;version&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1.5.10&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>在执行<code>npm install</code>时，会将该模块更新到大版本下的最新的版本，并将版本号更新至<code>package-lock.json</code>，且<code>package.json</code>中的版本号保持不变。</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 执行完 npm install 后：</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// package-lock.json 中 version 更新到大版本下的最新版本，变为 &quot;1.7.1&quot;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// package.json 保持不变，但实际安装的包版本是 &quot;1.7.1&quot;</span></span></code></pre></div><p>如果小于，则会沿用<code>package-lock.json</code>中的版本。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// package-lock.json</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;vue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;version&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;2.6.10&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// package.json</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dependencies&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;vue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;^2.5.6&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 执行完 npm install 后：</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// package-lock.json 中版本没发生改变，依然是 &quot;2.6.10&quot;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// package.json 保持不变，但实际安装的包版本是 &quot;2.6.10&quot;</span></span></code></pre></div><h4 id="在大版本不同的情况下" tabindex="-1">在大版本不同的情况下 <a class="header-anchor" href="#在大版本不同的情况下" aria-label="Permalink to &quot;在大版本不同的情况下&quot;">​</a></h4><p>在执行<code>npm install</code>时，都将根据<code>package.json</code>中大版本下的最新版本进行更新，并将版本号更新至<code>package-lock.json</code></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// package-lock.json</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;clipboard&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;version&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;2.0.4&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// package.json</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dependencies&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;clipboard&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;^1.6.1&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 执行完 npm install 后，package-lock.json 中 </span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;clipboard&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;version&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1.7.1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 更新到大版本下的最新版本</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="在package-json中有记录-而在package-lock-json中无记录" tabindex="-1">在package.json中有记录，而在package-lock.json中无记录 <a class="header-anchor" href="#在package-json中有记录-而在package-lock-json中无记录" aria-label="Permalink to &quot;在package.json中有记录，而在package-lock.json中无记录&quot;">​</a></h4><p>执行<code>npm install</code>后，则会在<code>package-lock.json</code>生成该模块的详细记录。</p><p>同理，一个模块在<code>package.json</code>中无记录，而在<code>package-lock.json</code>中有记录，执行<code>npm install</code>后，会在<code>package-lock.json</code>删除该模块的详细记录。</p><h2 id="依赖包安装原理" tabindex="-1">依赖包安装原理 <a class="header-anchor" href="#依赖包安装原理" aria-label="Permalink to &quot;依赖包安装原理&quot;">​</a></h2><p>从一幅图入手</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/Node/依赖包安装流程.jpeg" height="400px"><ul><li>执行<code>npm install</code></li><li>检查<code>.npmrc</code>文件；优先级为： <ul><li>项目级的<code>.npmrc</code>文件</li><li>用户级的<code>.npmrc</code>文件</li><li>全局级的<code>.npmrc</code>文件</li><li>npm 内置的<code>.npmrc</code>文件</li></ul></li><li>检查项目中有无<code>lock</code>文件</li><li>无<code>lock</code>文件 <ul><li>从<code>npm</code>远程仓库获取包信息</li><li>根据<code>package.json</code>构建依赖树，构建过程： <ul><li>构建依赖树时，不管其是直接依赖还是子依赖的依赖，优先将其放置在<code>node_modules</code>根目录。</li><li>当遇到相同模块时，判断已放置在依赖树的模块版本是否符合新模块的版本范围，如果符合则跳过，不符合则在当前模块的<code>node_modules</code>下放置该模块。</li><li>注意这一步只是确定逻辑上的依赖树，<strong>并非真正的安装</strong>，后面会根据这个依赖结构去下载或拿到缓存中的依赖包。</li></ul></li><li>在缓存中依次查找依赖树中的每个包： <ul><li>存在缓存：将缓存按照依赖结构解压到<code>node_modules</code>。</li><li>如果不存在缓存：从<code>npm</code>远程仓库下载包，并校验包的完整性；如果校验不通过则重新下载；反之将下载的包复制到<code>npm</code>缓存目录并按照依赖结构解压到<code>node_modules</code>。</li></ul></li><li>此时包已经解压到<code>node_modules</code>，并生成<code>lock</code>文件。</li></ul></li><li>有<code>lock</code>文件，检查<code>package.json</code>中的依赖版本是否和<code>package-lock.json</code>中的依赖有冲突： <ul><li>如果没有冲突，跳过构建包信息和构建依赖树过程，直接在缓存中查找包信息。然后继续图中流程。</li><li>如果有冲突则和上述一致，依次走每个流程。</li></ul></li></ul><h3 id="缓存依赖包" tabindex="-1">缓存依赖包 <a class="header-anchor" href="#缓存依赖包" aria-label="Permalink to &quot;缓存依赖包&quot;">​</a></h3><p>在执行<code>npm install</code>或<code>npm update</code>命令下载依赖后，除了将依赖包安装在<code>node_modules</code>目录下外，还会在本地的缓存目录缓存一份。通过<code>npm config get cache</code>命令可以查询到： -<code>Mac</code>默认是用户主目录下的<code>.npm/_cacache</code>目录。在这个目录下又存在两个目录：<code>content-v2</code>、<code>index-v5</code> -<code>content-v2</code>目录用于存储<code>tar</code>包的缓存 -<code>index-v5</code>目录用于存储<code>tar</code>包的<code>hash</code></p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">├──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> .npm</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">│</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   ├──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> _cacache</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">│</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   │</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   ├──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> content-v2</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">│</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   │</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   └──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> index-v5</span></span></code></pre></div><p>npm 在执行安装时，可以根据<code>package-lock.json</code>中存储的<code>integrity、version、name</code>生成一个唯一的<code>key</code>对应到<code>index-v5</code>目录下的缓存记录，从而找到<code>tar</code>包的<code>hash</code>，然后根据<code>hash</code>再去找缓存的<code>tar</code>包。可以直接使用<code>npm</code>提供了几个命令来管理缓存数据： -<code>npm cache add</code>：官方解释说这个命令主要是<code>npm</code>内部使用，但是也可以用来手动给一个指定的 package 添加缓存。 -<code>npm cache clean</code>：删除缓存目录下的所有数据，为了保证缓存数据的完整性，需要加上<code>--force</code>参数。 -<code>npm cache verify</code>：验证缓存数据的有效性和完整性，清理垃圾数据。</p><p>基于缓存数据，npm 提供了离线安装模式，分别有以下几种： -<code>--prefer-offline</code>：优先使用缓存数据，如果没有匹配的缓存数据，则从远程仓库下载。 -<code>--prefer-online</code>：优先使用网络数据，如果网络数据请求失败，再去请求缓存数据，这种模式可以及时获取最新的模块。 -<code>--offline</code>：不请求网络，直接使用缓存数据，一旦缓存数据不存在，则安装失败。</p><h3 id="校验文件完整性" tabindex="-1">校验文件完整性 <a class="header-anchor" href="#校验文件完整性" aria-label="Permalink to &quot;校验文件完整性&quot;">​</a></h3><p>在下载依赖包之前，一般就能拿到<code>npm</code>对该依赖包计算的<code>hash</code>值，例如执行<code>npm info</code>命令，可以看到有一个<code>shasum</code>字段，这个字段就是依赖包的<code>hash</code>值。</p><p>当用户下载依赖包到本地后，需要确定在下载过程中没有出现错误，所以在下载完成之后会在本地再计算一次文件的<code>hash</code>值，如果两个<code>hash</code>值是相同的，说明下载的依赖是完整的，如果不同，则进行重新下载。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><ul><li>npm2.x：递归下载，会造成包重复下载和结构嵌套太深。</li><li>npm3.x：扁平化，由于按照<code>package.json</code>里依赖的顺序依次解析，而在<code>package.json</code>通常只会锁定大版本，这意味着在某些依赖包小版本更新后，同样可能造成依赖结构的改动，依赖结构的不确定性可能会给程序带来不可预知的问题。</li><li>npm5.x：新增了<code>package-lock.json</code>文件，而安装方式还沿用扁平化的方式。保证<code>node_modules</code>目录结构是完全相同。但是当小版本不同时，会出现协同开发者的依赖包不一致的问题。而且还有一个问题就是<code>package 非法访问</code>和<code>扁平化算法复杂</code>。</li></ul>`,62),p=[l];function t(o,h,k,d,c,r){return a(),i("div",null,p)}const E=s(e,[["render",t]]);export{F as __pageData,E as default};
