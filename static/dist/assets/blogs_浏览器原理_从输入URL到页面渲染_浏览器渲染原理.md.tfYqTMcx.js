import{_ as a,c as i,o as s,a4 as t}from"./chunks/framework.BOW58p_D.js";const E=JSON.parse('{"title":"浏览器渲染原理","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/浏览器原理/从输入URL到页面渲染/浏览器渲染原理.md","filePath":"blogs/浏览器原理/从输入URL到页面渲染/浏览器渲染原理.md"}'),e={name:"blogs/浏览器原理/从输入URL到页面渲染/浏览器渲染原理.md"},l=t(`<h1 id="浏览器渲染原理" tabindex="-1">浏览器渲染原理 <a class="header-anchor" href="#浏览器渲染原理" aria-label="Permalink to &quot;浏览器渲染原理&quot;">​</a></h1><h2 id="开始" tabindex="-1">开始 <a class="header-anchor" href="#开始" aria-label="Permalink to &quot;开始&quot;">​</a></h2><p>浏览器渲染原理主要包含如下几个阶段</p><ul><li><a href="#dom">构建DOM树</a></li><li><a href="#styleSheets">样式计算</a></li><li><a href="#layout">布局阶段</a></li><li><a href="#layer">分层</a></li><li><a href="#paint">绘制</a></li><li><a href="#tile">分块</a></li><li><a href="#raster">栅格化</a></li><li><a href="#compositor">合成</a></li><li><a href="#ch">关于回流、重绘、合成</a></li></ul><hr><p>你可以想象一下，从0，1字节流到最后页面展现在你面前，这里面渲染机制肯定很复杂，所以渲染模块把执行过程中化为很多的子阶段，渲染引擎从网络进程拿到字节流数据后，经过这些子阶段的处理，最后输出像素，这个过程可以称为<code>渲染流水线</code></p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/http/浏览器渲染原理/渲染流水线.webp"><h2 id="构建dom树" tabindex="-1"><span id="dom">构建DOM树</span> <a class="header-anchor" href="#构建dom树" aria-label="Permalink to &quot;&lt;span id=&quot;dom&quot;&gt;构建DOM树&lt;/span&gt;&quot;">​</a></h2><p>这个过程主要工作就是 <strong>将HTML内容转换为浏览器DOM树结构</strong></p><h3 id="什么是-dom" tabindex="-1">什么是 DOM <a class="header-anchor" href="#什么是-dom" aria-label="Permalink to &quot;什么是 DOM&quot;">​</a></h3><p><strong>从网络传给渲染引擎的 HTML 文件字节流是无法直接被渲染引擎理解的</strong>，所以要将其转化为渲染引擎能够理解的内部结构，这个结构就是 DOM</p><p>DOM树和HTML内容几乎是一样的，但是和 HTML 不同的是，DOM 是保存在内存中树状结构，可以通过 JavaScript 来查询或修改其内容，下图是HTML和DOM树的区别</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/http/浏览器渲染原理/dom树构建过程.webp"><h3 id="dom-树的作用" tabindex="-1">DOM 树的作用 <a class="header-anchor" href="#dom-树的作用" aria-label="Permalink to &quot;DOM 树的作用&quot;">​</a></h3><ul><li>从页面的视角来看，DOM 是生成页面的基础数据结构。</li><li>从 JavaScript 脚本视角来看，DOM 提供给 JavaScript 脚本操作的接口，通过这套接口，JavaScript 可以对 DOM 结构进行访问，从而改变文档的结构、样式和内容。</li><li>从安全视角来看，DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就被拒之门外了。</li></ul><p><strong>简言之，DOM 是表述 HTML 的内部数据结构，它会将 Web 页面和 JavaScript 脚本连接起来，并过滤一些不安全的内容</strong></p><h3 id="dom树是怎么生成的" tabindex="-1">DOM树是怎么生成的 <a class="header-anchor" href="#dom树是怎么生成的" aria-label="Permalink to &quot;DOM树是怎么生成的&quot;">​</a></h3><p>在渲染引擎内部，有一个 <strong>HTML 解析器（HTMLParser）</strong>，它的职责就是负责将 HTML 字节流转换为 DOM 结构</p><p>前面我们说过代码从网络传输过来是字节流的形式，那么后续字节流是如何转换为 DOM 的呢？参考下图</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/http/浏览器渲染原理/HTMLParser.webp" width="50%"><p>从图中可以看出，字节流转换为 DOM 需要三个阶段。</p><h4 id="转换token" tabindex="-1">转换Token <a class="header-anchor" href="#转换token" aria-label="Permalink to &quot;转换Token&quot;">​</a></h4><p>第一个阶段，通过分词器将字节流转换为 Token，分为 Tag Token 和文本 Token。</p><p>上述 HTML 代码通过词法分析生成的 Token 如下所示：</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/http/浏览器渲染原理/HTMLParserToken.webp" width="50%"><p>由图可以看出，Tag Token 又分 StartTag 和 EndTag，比如图中的蓝色块就是 StartTag、红色块就是EndTag，文本 Token 对应的绿色块。</p><h4 id="解析和添加" tabindex="-1">解析和添加 <a class="header-anchor" href="#解析和添加" aria-label="Permalink to &quot;解析和添加&quot;">​</a></h4><p>至于后续的第二个和第三个阶段是同步进行的，<strong>将 Token 解析为 DOM 节点</strong>，<strong>并将 DOM 节点添加到 DOM 树中</strong>。</p><p>HTML 解析器维护了一个 <strong>Token 栈结构</strong>，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中。具体的处理规则如下所示：</p><ul><li>HTML 解析器开始工作时，会默认创建了一个根为 document 的空 DOM 结构，同时会将一个 StartTag document 的 Token 压入栈底</li><li>如果压入到栈中的是 <code>StartTag Token</code>，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。</li><li>如果分词器解析出来是<code>文本 Token</code>，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。</li><li>如果分词器解析出来的是 <code>EndTag Token</code>，比如是 EndTag div，HTML 解析器会查看 Token 栈顶的元素是否是 StarTag div，如果是，就将 StartTag div 从栈中弹出，表示该 div 元素解析完成。</li></ul><p>通过分词器产生的新 Token 就这样不停地压栈和出栈，整个解析过程就这样一直持续下去，直到分词器将所有字节流分词完成。</p><p>以下面HTML为例，看下整个过程</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">html</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;1&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;test&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">html</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>HTML 解析器开始工作时，会默认创建了一个根为 document 的空 DOM 结构，同时会将一个 StartTag document 的 Token 压入栈底。然后经过分词器解析出来的第一个 StartTag html Token 会被压入到栈中，并创建一个 html 的 DOM 节点，添加到 document 上，如下图所示：</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/http/浏览器渲染原理/HTMLParse栈1.webp" width="50%"><p>然后按照同样的流程解析出来 StartTag body 和 StartTag div，其 Token 栈和 DOM 的状态如下图所示：</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/http/浏览器渲染原理/HTMLParse栈2.webp" width="50%"><p>接下来解析出来的是第一个 div 的文本 Token，渲染引擎会为该 Token 创建一个文本节点，并将该 Token 添加到 DOM 中，它的父节点就是当前 Token 栈顶元素对应的节点，如下图所示：</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/http/浏览器渲染原理/HTMLParse栈3.webp" width="50%"><p>再接下来，分词器解析出来第一个 EndTag div，这时候 HTML 解析器会去判断当前栈顶的元素是否是 StartTag div，如果是则从栈顶弹出 StartTag div，如下图所示：</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/http/浏览器渲染原理/HTMLParse栈4.webp" width="50%"><p>按照同样的规则，一路解析，最终结果如下图所示：</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/http/浏览器渲染原理/HTMLParse栈5.webp" width="50%"><h2 id="样式计算" tabindex="-1"><span id="styleSheets">样式计算</span> <a class="header-anchor" href="#样式计算" aria-label="Permalink to &quot;&lt;span id=&quot;styleSheets&quot;&gt;样式计算&lt;/span&gt;&quot;">​</a></h2><p>样式计算的目的是为了计算出 DOM 节点中每个元素的具体样式，这个阶段大体可分为三步来完成</p><ul><li>格式化样式表</li><li>标准化样式表</li><li>计算每个DOM节点具体样式</li></ul><h3 id="格式化样式表" tabindex="-1">格式化样式表 <a class="header-anchor" href="#格式化样式表" aria-label="Permalink to &quot;格式化样式表&quot;">​</a></h3><p>对于CSS，浏览器拿到的也就是0，1字节流数据，浏览器无法直接去识别的，所以渲染引擎收到CSS文本数据后，会执行一个操作，转换为浏览器可以理解的结构 styleSheets（CSSOM）</p><h4 id="stylesheets-cssom-作用" tabindex="-1">styleSheets（CSSOM） 作用 <a class="header-anchor" href="#stylesheets-cssom-作用" aria-label="Permalink to &quot;styleSheets（CSSOM） 作用&quot;">​</a></h4><ul><li>第一个是提供给 JavaScript 操作样式表的能力。</li><li>第二个是为布局树的合成提供基础的样式信息。</li></ul><h3 id="标准化样式表" tabindex="-1">标准化样式表 <a class="header-anchor" href="#标准化样式表" aria-label="Permalink to &quot;标准化样式表&quot;">​</a></h3><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">font-size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">em</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">blue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;}</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">span</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">none</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">font-weight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">bold</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>上面的 CSS 文本中有很多属性值，如 2em、blue、bold，这些类型数值不容易被渲染引擎理解，所以需要将所有值转换为渲染引擎容易理解的、标准化的计算值，这个过程就是属性值标准化，下面是转换后的属性</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">font-size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">36</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; }</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">rgb</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">255</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);}</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">span</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">none</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;}</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">font-weight</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">700</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;}</span></span></code></pre></div><h3 id="计算每个dom节点具体样式" tabindex="-1">计算每个DOM节点具体样式 <a class="header-anchor" href="#计算每个dom节点具体样式" aria-label="Permalink to &quot;计算每个DOM节点具体样式&quot;">​</a></h3><p>主要分为两点</p><ul><li>继承规则：每个子节点会默认去继承父节点的样式，如果父节点中找不到，就会采用浏览器默认的样式，也叫UserAgent样式</li><li>层叠规则：层叠是 CSS 的一个基本特征，比如：<code>.box p {}</code></li></ul><p>在计算完样式之后，所有的样式值会被挂在到<code>window.getComputedStyle</code>当中，也就是可以 <strong>通过JS来获取计算后的样式</strong></p><p><strong>样式计算的整个过程就是完成了DOM节点中每个元素的具体样式，计算过程中要遵循CSS的继承和层叠两条规则，最终输出的内容是每个节点DOM的样式，被保存在<code>ComputedStyle</code>中</strong></p><h2 id="生成布局树" tabindex="-1"><span id="layout">生成布局树</span> <a class="header-anchor" href="#生成布局树" aria-label="Permalink to &quot;&lt;span id=&quot;layout&quot;&gt;生成布局树&lt;/span&gt;&quot;">​</a></h2><p>现在，我们有 DOM 树和 DOM 树中元素的样式，但这还不足以显示页面，因为我们还不知道 DOM 元素的几何位置信息。那么接下来就需要计算出 DOM 树中可见元素的几何位置，也就是生成一颗<strong>布局树（Layout Tree）</strong>,之前说法叫<strong>渲染树（Render Tree）</strong></p><p>Chrome 在布局阶段需要完成两个任务：创建 Layout Tree 和 布局计算</p><h3 id="创建布局树-layout-tree" tabindex="-1">创建布局树（Layout Tree） <a class="header-anchor" href="#创建布局树-layout-tree" aria-label="Permalink to &quot;创建布局树（Layout Tree）&quot;">​</a></h3><p>DOM 树还含有很多不可见的元素，比如 <code>head</code> 标签，还有使用了 <code>display:none </code>属性的元素。所以在显示之前，我们还要 <strong>额外地构建一棵只包含可见元素的布局树<code>Layout Tree</code></strong></p><p>结合下图来看看Layout Tree的构造过程：</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/http/浏览器渲染原理/布局树.webp" width="50%"><p>从上图可以看出，DOM 树中所有不可见的节点都没有包含到布局树中</p><p>为了构建布局树，浏览器大体上完成了下面这些工作：</p><ul><li>遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中</li><li>而不可见的节点会被布局树忽略掉，如 <code>head</code> 标签下面的全部内容，再比如<code> body.p.span</code> 这个元素，因为它的属性包含 <code>dispaly:none</code>，所以这个元素也没有被包进布局树</li></ul><h3 id="布局计算" tabindex="-1">布局计算 <a class="header-anchor" href="#布局计算" aria-label="Permalink to &quot;布局计算&quot;">​</a></h3><p>浏览器根据 Layout Tree 所体现的节点、各个节点的 CSS 定义以及它们的从属关系，计算出每个节点在屏幕中的位置</p><p>Web 页面中元素的布局是相对的，在页面元素位置、大小发生变化，往往会导致其他节点联动，需要重新计算布局，这时候的布局过程一般被称为<strong>回流（Reflow）</strong></p><h2 id="分层-layer" tabindex="-1"><span id="layer">分层（Layer）</span> <a class="header-anchor" href="#分层-layer" aria-label="Permalink to &quot;&lt;span id=&quot;layer&quot;&gt;分层（Layer）&lt;/span&gt;&quot;">​</a></h2><p>浏览器在构建完布局树后，还需要进行一系列操作，这样子可能考虑到一些复杂的场景，如一些复杂的 3D 变换、页面滚动，或者使用 z-index 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的<strong>图层树（Layer Tree）</strong></p><p>看看图层树与布局树之间关系</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/http/浏览器渲染原理/图层树.webp" width="50%"><p>上图中的每一层，叫做<strong>渲染层（PaintLayers）</strong></p><p>通常情况下，并不是布局树的每个节点都包含一个图层，如果一个节点没有对应的层，那么这个节点就从属于父节点的图层。如上图中的 span 标签没有专属图层，那么它们就从属于它们的父节点图层。但不管怎样，最终每一个节点都会直接或者间接地从属于一个层</p><p>那么需要满足什么条件，渲染引擎才会为特定的节点创建新的图层呢？</p><h3 id="渲染层" tabindex="-1">渲染层 <a class="header-anchor" href="#渲染层" aria-label="Permalink to &quot;渲染层&quot;">​</a></h3><p>这是浏览器渲染期间构建的第一个层模型，处于相同坐标空间（z轴空间）的渲染对象，都将归并到同一个渲染层中，因此根据层叠上下文，不同坐标空间的的渲染对象将形成多个渲染层，以体现它们的层叠关系</p><p>浏览器自动创建新的渲染层的条件有两个，一个是<strong>满足层叠上下文</strong></p><h4 id="满足层叠上下文" tabindex="-1">满足层叠上下文 <a class="header-anchor" href="#满足层叠上下文" aria-label="Permalink to &quot;满足层叠上下文&quot;">​</a></h4><ul><li>根元素 document</li><li>有明确的定位属性（relative、fixed、sticky、absolute）</li><li>opacity &lt; 1</li><li>当前有对于 opacity、transform、fliter、backdrop-filter 应用动画</li><li>overflow 不为 visible</li><li>有 CSS transform 属性且值不为 none</li><li>有 CSS fliter 属性</li><li>有 CSS mask 属性</li><li>有 CSS mix-blend-mode 属性且值不为 normal</li><li>backface-visibility 属性为 hidden</li><li>有 CSS reflection 属性</li><li>有 CSS column-count 属性且值不为 auto或者有 CSS column-width 属性且值不为 auto</li></ul><h2 id="绘制图层绘制-paint" tabindex="-1"><span id="paint">绘制图层绘制（Paint）</span> <a class="header-anchor" href="#绘制图层绘制-paint" aria-label="Permalink to &quot;&lt;span id=&quot;paint&quot;&gt;绘制图层绘制（Paint）&lt;/span&gt;&quot;">​</a></h2><p>在完成渲染层的构建之后，渲染引擎会对每个渲染层进行绘制，本质上是一个像素填充的过程。这个过程也出现于回流或一些不影响布局的 CSS 修改引起的屏幕局部重画，这时候它被称为 <strong>重绘（Repaint）</strong></p><p>渲染引擎会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个待绘制列表</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/http/浏览器渲染原理/绘制列表.webp" width="50%"><p>从图中可以看出，绘制列表中的指令其实非常简单，就是让其执行一个简单的绘制操作，比如绘制粉色矩形或者黑色的线等。而绘制一个元素通常需要好几条绘制指令，因为每个元素的背景、前景、边框都需要单独的指令去绘制。所以在图层绘制阶段，<strong>输出的内容就是这些待绘制列表</strong></p><p>到此 Paint 阶段执行完毕，开始 Compsite 阶段</p><p>绘制列表只是用来记录绘制顺序和绘制指令的列表，而实际上绘制操作是由渲染引擎中的合成线程来完成的。你可以结合下图来看下渲染主线程和合成线程之间的关系：</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/http/浏览器渲染原理/渲染进程.webp" width="50%"><p>如上图所示，当图层的绘制列表准备好之后，主线程会把该绘制列表提交给<strong>合成线程</strong></p><h2 id="分块-tile" tabindex="-1"><span id="tile">分块（tile）</span> <a class="header-anchor" href="#分块-tile" aria-label="Permalink to &quot;&lt;span id=&quot;tile&quot;&gt;分块（tile）&lt;/span&gt;&quot;">​</a></h2><p>通常一个页面可能很大，但是用户只能看到其中的一部分，我们把用户可以看到的这个部分叫做视口（viewport）</p><p>在有些情况下，有的图层可以很大，比如有的页面你使用滚动条要滚动好久才能滚动到底部，但是通过视口，用户只能看到页面的很小一部分，所以在这种情况下，要绘制出所有图层内容的话，就会产生太大的开销，而且也没有必要</p><p>基于这个原因，<strong>合成线程会将图层划分为图块（tile）</strong>，这些图块的大小通常是 256x256 或者 512x512，然后合成线程会<strong>按照视口附近的图块来优先生成位图</strong>，实际生成位图的操作是由栅格化来执行的</p><h2 id="栅格化-raster" tabindex="-1"><span id="raster">栅格化（raster）</span> <a class="header-anchor" href="#栅格化-raster" aria-label="Permalink to &quot;&lt;span id=&quot;raster&quot;&gt;栅格化（raster）&lt;/span&gt;&quot;">​</a></h2><p>所谓栅格化，是指将图块转换为位图。即将这些信息进行位图填充，转化为像素值。渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的</p><p>光栅化可以分为软件光栅化（Software Rasterization）和硬件光栅化（Hardware Rasterization）， 区别在于位图的生成是在 CPU 中进行，之后再上传至 GPU 合成，还是直接在 GPU 中进行绘图和图像素填充</p><p>当满足某些特殊条件的渲染层会被提升为合成层，而合成层的栅格化操作是在GPU中进行的。使用 GPU 生成位图的过程叫快速栅格化或硬件光栅化，生成的位图被保存在 GPU 内存中</p><p>GPU 操作是运行在 GPU 进程中，如果栅格化操作使用了 GPU，那么最终生成位图的操作是在 GPU 中完成的，这就涉及到了跨进程操作。具体形式可以参考下图：</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/http/浏览器渲染原理/渲染进程和gpu.webp" width="50%"><p>从图中可以看出，渲染进程把生成图块的指令发送给 GPU，然后<strong>在 GPU 中执行生成图块的位图（CompositingLayer）</strong>，并保存在 GPU 的内存中</p><h3 id="合成层-compositinglayer" tabindex="-1">合成层（CompositingLayer） <a class="header-anchor" href="#合成层-compositinglayer" aria-label="Permalink to &quot;合成层（CompositingLayer）&quot;">​</a></h3><p>满足某些特殊条件的渲染层，会被浏览器自动提升为合成层。合成层拥有单独的 GraphicsLayer，而其他不是合成层的渲染层，则和其第一个拥有 GraphicsLayer 的父层共用一个。需要注意的点是 document 是渲染层，不是合成层</p><p>那么一个渲染层满足哪些特殊条件时，才能被提升为合成层呢？这里列举了一些常见的情况：</p><ul><li>3D transforms：translate3d、translateZ 等</li><li>video、canvas、iframe 等元素</li><li>通过 Element.animate() 实现的 opacity 动画转换</li><li>通过 СSS 动画实现的 opacity 动画转换</li><li>position: fixed</li><li>具有 will-change 属性</li><li>对 opacity、transform、fliter、backdropfilter 应用了 animation 或者 transition（需要是 正在执行 的 animation 或者 transition，当 animation 或者 transition 效果未开始或结束后，提升合成层也会失效）</li><li>will-change 设置为 opacity、transform、top、left、bottom、right（其中 top、left 等需要设置明确的定位属性，如 relative 等）</li><li>需要<strong>剪裁</strong>(clip)的地方</li></ul><h4 id="需要裁剪的地方" tabindex="-1">需要裁剪的地方 <a class="header-anchor" href="#需要裁剪的地方" aria-label="Permalink to &quot;需要裁剪的地方&quot;">​</a></h4><p>比如一个div标签很小，<code>50*50</code>像素，你在里面放了非常多的文字，那么超出的文字部分就需要被剪裁。当然如果出现了滚动条，那么滚动条也会被单独提升为一个图层，也就是说这里会有三个图层，分别是div、文字、滚动条。如下图</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/http/浏览器渲染原理/内容裁剪.webp" width="70%"><h4 id="合成层优缺点" tabindex="-1">合成层优缺点 <a class="header-anchor" href="#合成层优缺点" aria-label="Permalink to &quot;合成层优缺点&quot;">​</a></h4><p>优点</p><ul><li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快得多</li><li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li><li>元素提升为合成层后，transform 和 opacity 才不会触发 repaint，如果不是合成层，则其依然会触发 repaint</li></ul><p>缺点</p><ul><li>绘制的图层必须传输到 GPU，这些层的数量和大小达到一定量级后，可能会导致传输非常慢，进而导致一些低端和中端设备上出现闪烁</li><li>隐式合成容易产生过量的合成层，每个合成层都占用额外的内存，而内存是移动设备上的宝贵资源，过多使用内存可能会导致浏览器崩溃，让性能优化适得其反。这个也叫做层爆炸（后面题目中会介绍）</li></ul><h4 id="图形层-graphicslayer" tabindex="-1">图形层（GraphicsLayer） <a class="header-anchor" href="#图形层-graphicslayer" aria-label="Permalink to &quot;图形层（GraphicsLayer）&quot;">​</a></h4><p>GraphicsLayer 其实是一个负责生成最终准备呈现的内容图形的层模型，它拥有一个图形上下文（GraphicsContext），GraphicsContext 会负责输出该层的位图。存储在共享内存中的位图将作为纹理上传到 GPU，最后由 GPU 将多个位图进行合成，然后绘制到屏幕上，此时，我们的页面也就展现到了屏幕上，<strong>也就是说不会触发重绘和回流</strong>。</p><p>所以 GraphicsLayer 是一个重要的渲染载体和工具，但它 <strong>并不直接处理渲染层，而是处理合成层</strong></p><h2 id="合成和显示" tabindex="-1"><span id="compositor">合成和显示</span> <a class="header-anchor" href="#合成和显示" aria-label="Permalink to &quot;&lt;span id=&quot;compositor&quot;&gt;合成和显示&lt;/span&gt;&quot;">​</a></h2><p>渲染进程的合成线程接收到图层的绘制消息时，会通过光栅化线程池将其提交给GPU进程，在GPU进程中执行光栅化操作，一旦所有图块都被光栅化，会将结果返回给渲染进程的合成线程，执行合成图层操作（也就是创建合成层），图层合成完成后就会生成一个绘制的命令——“DrawQuad”，然后将该命令提交给浏览器进程</p><p>浏览器进程里面有一个叫 viz 的组件，用来接收合成线程发过来的 DrawQuad 命令，然后根据 DrawQuad 命令，浏览器进程里会执行显示合成(Display Compositor)，也就是将<strong>所有的图层</strong>合成为页面内容。并将其绘制到显卡的后缓冲区。到这里，经过这一系列的阶段，编写好的 HTML、CSS、JavaScript 等文件，经过浏览器就会显示出漂亮的页面了</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/http/浏览器渲染原理/完成的渲染流水线.webp" width="50%"><h3 id="显示器显示图像的原理解释" tabindex="-1">显示器显示图像的原理解释: <a class="header-anchor" href="#显示器显示图像的原理解释" aria-label="Permalink to &quot;显示器显示图像的原理解释:&quot;">​</a></h3><p>当通过渲染流水线通过GPU生成一张图片之后，会将图片存储到<strong>显卡的后缓冲区</strong>，一旦显卡把合成的图像写到后缓冲区，系统就会让后缓冲区和前缓冲区互换；此时显示器会从前缓冲区中获取最新图片。一般情况下显示器的刷新频率是 60HZ，也就是每秒更新 60 张图片。</p><p>也就是说渲染流水线需要在16.66667ms内就要生成一张图片。显卡每16.66667ms就要交换一次缓冲区；如果生成图片过久，显示器就会读取不到新的图片，并保持上一帧图片；从而给用户造成视觉上的卡顿。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>一个完整的渲染流程大致可总结为如下：</p><ul><li>渲染进程将 HTML 字节流转换为 DOM 树</li><li>渲染引擎将 CSS 样式表转化成styleSheets并根据层叠规则和继承规则计算出 DOM 节点的样式</li><li>创建布局树（Layout Tree），并计算元素的在页面中的几何信息</li><li>对Layout Tree进行分层，并生成图层树（Layer Tree）</li><li>为每个渲染层生成绘制列表，并将其提交到合成线程</li><li>合成线程将渲染层分成图块，并在光栅化线程池中通过 GPU 将图块转换成位图</li><li>合成线程发送绘制图块命令 DrawQuad 给浏览器进程</li><li>浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上</li></ul>`,129),n=[l];function r(p,h,o,d,k,g){return s(),i("div",null,n)}const y=a(e,[["render",r]]);export{E as __pageData,y as default};
