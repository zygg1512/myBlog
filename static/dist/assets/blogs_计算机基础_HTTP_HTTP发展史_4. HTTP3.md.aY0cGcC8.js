import{_ as a,c as t,o as e,a4 as T}from"./chunks/framework.BOW58p_D.js";const C=JSON.parse('{"title":"HTTP/3 QUIC 协议","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/计算机基础/HTTP/HTTP发展史/4. HTTP3.md","filePath":"blogs/计算机基础/HTTP/HTTP发展史/4. HTTP3.md"}'),r={name:"blogs/计算机基础/HTTP/HTTP发展史/4. HTTP3.md"},h=T('<h1 id="http-3-quic-协议" tabindex="-1">HTTP/3 QUIC 协议 <a class="header-anchor" href="#http-3-quic-协议" aria-label="Permalink to &quot;HTTP/3 QUIC 协议&quot;">​</a></h1><p>HTTP/2 存在一些比较严重的与 TCP 协议相关的缺陷，但由于 TCP 协议僵化，几乎不可能通过修改 TCP 协议自身来解决这些问题，那么解决问题的思路是绕过 TCP 协议，发明一个 TCP 和 UDP 之外的新的传输协议。</p><p>但是这也面临着和修改 TCP 一样的挑战，因为中间设备的僵化，这些设备只认 TCP 和 UDP，如果采用了新的协议，新协议在这些设备同样不被很好地支持。</p><p>因此，HTTP/3 选择了一个折衷的方法——UDP 协议，基于 UDP 实现了类似于 TCP 的多路数据流、传输可靠性等功能，我们把这套功能称为 QUIC 协议。关于 HTTP/2 和 HTTP/3 协议栈的比较，可以参考下图：</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/http/http发展史/quic协议.webp" height="300px"><p>通过上图我们可以看出，HTTP/3 中的 QUIC 协议集合了以下几点功能</p><h2 id="http-3特点" tabindex="-1">HTTP/3特点 <a class="header-anchor" href="#http-3特点" aria-label="Permalink to &quot;HTTP/3特点&quot;">​</a></h2><h3 id="实现了类似-tcp-的流量控制、传输可靠性的功能" tabindex="-1">实现了类似 TCP 的流量控制、传输可靠性的功能 <a class="header-anchor" href="#实现了类似-tcp-的流量控制、传输可靠性的功能" aria-label="Permalink to &quot;实现了类似 TCP 的流量控制、传输可靠性的功能&quot;">​</a></h3><p>虽然 UDP 不提供可靠性的传输，但 QUIC 在 UDP 的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些 TCP 中存在的特性。</p><h3 id="集成了-tls-加密功能" tabindex="-1">集成了 TLS 加密功能 <a class="header-anchor" href="#集成了-tls-加密功能" aria-label="Permalink to &quot;集成了 TLS 加密功能&quot;">​</a></h3><p>目前 QUIC 使用的是 TLS1.3，相较于早期版本 TLS1.3 有更多的优点，其中最重要的一点是减少了握手所花费的 RTT 个数。</p><h3 id="实现了-http-2-中的多路复用功能" tabindex="-1">实现了 HTTP/2 中的多路复用功能 <a class="header-anchor" href="#实现了-http-2-中的多路复用功能" aria-label="Permalink to &quot;实现了 HTTP/2 中的多路复用功能&quot;">​</a></h3><p><strong>和 TCP 不同，QUIC 实现了在同一物理连接上可以有多个独立的逻辑数据流。实现了数据流的单独传输，就解决了 TCP 中队头阻塞的问题。</strong></p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/http/http发展史/quic通信.webp"><h3 id="实现了快速握手功能" tabindex="-1">实现了快速握手功能 <a class="header-anchor" href="#实现了快速握手功能" aria-label="Permalink to &quot;实现了快速握手功能&quot;">​</a></h3><p>由于 QUIC 是基于 UDP 的，所以 QUIC 可以实现使用 0-RTT 或者 1-RTT 来建立连接，这意味着 QUIC 可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。</p><h2 id="http-3-的挑战" tabindex="-1">HTTP/3 的挑战 <a class="header-anchor" href="#http-3-的挑战" aria-label="Permalink to &quot;HTTP/3 的挑战&quot;">​</a></h2><p>不过要将 HTTP/3 应用到实际环境中比较困难，这些困难点主要来自于以下三个方面。</p><h3 id="服务器和浏览器端都没有对-http-3-提供比较完整的支持" tabindex="-1">服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持 <a class="header-anchor" href="#服务器和浏览器端都没有对-http-3-提供比较完整的支持" aria-label="Permalink to &quot;服务器和浏览器端都没有对 HTTP/3 提供比较完整的支持&quot;">​</a></h3><p>Chrome 虽然在数年前就开始支持 Google 版本的 QUIC，但是这个版本的 QUIC 和官方的 QUIC 存在着非常大的差异。</p><h3 id="部署-http-3-也存在着非常大的问题" tabindex="-1">部署 HTTP/3 也存在着非常大的问题 <a class="header-anchor" href="#部署-http-3-也存在着非常大的问题" aria-label="Permalink to &quot;部署 HTTP/3 也存在着非常大的问题&quot;">​</a></h3><p>因为系统内核对 UDP 的优化远远没有达到 TCP 的优化程度，这也是阻碍 QUIC 的一个重要原因。</p><h3 id="中间设备僵化的问题" tabindex="-1">中间设备僵化的问题 <a class="header-anchor" href="#中间设备僵化的问题" aria-label="Permalink to &quot;中间设备僵化的问题&quot;">​</a></h3><p>这些设备对 UDP 的优化程度远远低于 TCP，据统计使用 QUIC 协议时，大约有 3%～7% 的丢包率。</p>',24),o=[h];function P(i,s,p,l,c,n){return e(),t("div",null,o)}const _=a(r,[["render",P]]);export{C as __pageData,_ as default};
