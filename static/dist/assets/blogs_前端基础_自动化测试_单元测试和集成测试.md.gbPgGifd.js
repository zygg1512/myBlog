import{_ as a,c as i,o as e,a4 as l}from"./chunks/framework.BOW58p_D.js";const b=JSON.parse('{"title":"单元测试和集成测试","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/前端基础/自动化测试/单元测试和集成测试.md","filePath":"blogs/前端基础/自动化测试/单元测试和集成测试.md"}'),t={name:"blogs/前端基础/自动化测试/单元测试和集成测试.md"},h=l(`<h1 id="单元测试和集成测试" tabindex="-1">单元测试和集成测试 <a class="header-anchor" href="#单元测试和集成测试" aria-label="Permalink to &quot;单元测试和集成测试&quot;">​</a></h1><p>近几年，前端发展越来越迅猛，各类框架层出不穷，前端实现的业务逻辑也越来越复杂，前端单元测试也越来越受重视。那么前端应该如何做好单元测试？</p><h2 id="单元测试" tabindex="-1">单元测试 <a class="header-anchor" href="#单元测试" aria-label="Permalink to &quot;单元测试&quot;">​</a></h2><h3 id="什么是单元测试" tabindex="-1">什么是单元测试 <a class="header-anchor" href="#什么是单元测试" aria-label="Permalink to &quot;什么是单元测试&quot;">​</a></h3><h4 id="单测的定义" tabindex="-1">单测的定义 <a class="header-anchor" href="#单测的定义" aria-label="Permalink to &quot;单测的定义&quot;">​</a></h4><p>来自维基百科的定义：</p><blockquote><p>在计算机编程中，单元测试（Unit Testing）又称为模块测试，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。</p></blockquote><p>程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。</p><p>定义里面指出，单元测试针对的是程序的最小单元，因此我们应该针对最小单元来写单测。</p><h4 id="单测完善程度的衡量" tabindex="-1">单测完善程度的衡量 <a class="header-anchor" href="#单测完善程度的衡量" aria-label="Permalink to &quot;单测完善程度的衡量&quot;">​</a></h4><p>单测完善程度用覆盖率来衡量</p><p>关于测试覆盖率，我们大致了解下以下几个常见的计算维度：</p><ul><li>行覆盖率：可执行语句执行的比例</li><li>函数覆盖率：函数被调用的比例</li><li>分支覆盖率：判断语句分支被执行的比例</li></ul><p>来看下面这个例子：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>对于<code>foo(4)</code>来说：</p><ul><li>行覆盖率：100%</li><li>函数覆盖率：100%</li><li>分支覆盖率：50%</li></ul><p>对于测试用例<code>foo(4)</code>，分支覆盖率只有<code>50%</code>，原因是<code>foo(4)</code>只测试了<code>if</code>为<code>true</code>的情况，没有测试到<code>if</code>为<code>false</code>的情况。</p><p>如果想要分支覆盖率达到100%，还应该测试<code>foo(5)</code></p><h3 id="为什么需要单测" tabindex="-1">为什么需要单测 <a class="header-anchor" href="#为什么需要单测" aria-label="Permalink to &quot;为什么需要单测&quot;">​</a></h3><h4 id="现状与问题" tabindex="-1">现状与问题 <a class="header-anchor" href="#现状与问题" aria-label="Permalink to &quot;现状与问题&quot;">​</a></h4><ul><li>缺乏意识：没有单测意识，很多代码没有单测</li><li>缺乏设计：模块缺乏设计，相互耦合，写单测困难</li><li>测试困难：升级公共 API，人工测试验证困难</li><li>测试不全面：部分代码分支众多，人工测试没办法覆盖所有分支</li></ul><h4 id="单测的价值与意义" tabindex="-1">单测的价值与意义 <a class="header-anchor" href="#单测的价值与意义" aria-label="Permalink to &quot;单测的价值与意义&quot;">​</a></h4><ul><li>能力建设：一个具备开发经验的开发人员，基本上都会编写单元测试。即便不会，可以通过培训来快速达成。从学习曲线上看，单元测试很容易上手。</li><li>提升效率：能够通过 mock 数据，及早发现问题，而越早发现Bug，造成的浪费就会越小。</li><li>追求卓越：单元测试可以充当一个设计工具，它有助于开发人员去思考代码结构的设计，让代码更加有利于测试。</li><li>测试更全面：能够覆盖 QA 测试覆盖不到的情况，比如各种 if 分支、异常处理。</li><li>更有信心：升级公共 API 时，如果依赖这个 API 的所有代码单测都能通过，那我们对这次代码升级是更有信心的。</li></ul><h3 id="怎样写单测" tabindex="-1">怎样写单测 <a class="header-anchor" href="#怎样写单测" aria-label="Permalink to &quot;怎样写单测&quot;">​</a></h3><h4 id="单测的原则-first" tabindex="-1">单测的原则：FIRST <a class="header-anchor" href="#单测的原则-first" aria-label="Permalink to &quot;单测的原则：FIRST&quot;">​</a></h4><img height="300px" src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/自动化测试/单测的原则.png"><h4 id="单测需要测什么-right-bicep" tabindex="-1">单测需要测什么：RIGHT BICEP! <a class="header-anchor" href="#单测需要测什么-right-bicep" aria-label="Permalink to &quot;单测需要测什么：RIGHT BICEP!&quot;">​</a></h4><img height="300px" src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/自动化测试/单测需要测什么.png"><h5 id="结果正确" tabindex="-1">结果正确 <a class="header-anchor" href="#结果正确" aria-label="Permalink to &quot;结果正确&quot;">​</a></h5><p>这个是最基本的检查，如果单测的运行结果都不正确，那其他的都免谈。</p><h5 id="边界条件检查" tabindex="-1">边界条件检查 <a class="header-anchor" href="#边界条件检查" aria-label="Permalink to &quot;边界条件检查&quot;">​</a></h5><p>边界检查尤为重要，很多错误都是发生在边界上。边界检查遵循 CORRECT</p><img height="300px" src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/自动化测试/边界条件检查.webp"><ul><li>有序性：如果一组值是有序的，那么在向其中删除或者添加时，需要校验这组值是否仍然是有序的</li><li>引用/耦合性：对于类的状态、其他对象的状态等需要做一些假设，程序员就需要对代码进行测试，保证在假设未满足的情况下运行良好。</li><li>存在性：当数据不存在的时候，程序是否运行良好，例如null，空字符串等</li><li>基数性：这里的基数主要强调的是计数，考虑以“0-1-N 原则”，当数值分别为0、1、N 时，可能出现的结果，其中N 为最大值。</li><li>时间性：要充分考虑与时间相关的问题，涉及到并发、异步、超时等这些情况需要特别注意，所有事情的发生时间是否在预期范围内。</li></ul><h5 id="反向关联检查" tabindex="-1">反向关联检查 <a class="header-anchor" href="#反向关联检查" aria-label="Permalink to &quot;反向关联检查&quot;">​</a></h5><ul><li>例：对于加密算法，使用解密算法反向检查其输出，验证解密后明文是否正确。</li><li>例：对于写操作API，使用读操作API来反向检查验证</li></ul><h5 id="交叉检查" tabindex="-1">交叉检查 <a class="header-anchor" href="#交叉检查" aria-label="Permalink to &quot;交叉检查&quot;">​</a></h5><ul><li>例： 对性能优化的算法，使用性能差但验证过的算法交叉检查</li></ul><h5 id="强制错误条件发生" tabindex="-1">强制错误条件发生 <a class="header-anchor" href="#强制错误条件发生" aria-label="Permalink to &quot;强制错误条件发生&quot;">​</a></h5><ul><li>例： Mock依赖系统不可用 或者 Mock系统时间错误</li><li>例：甚至可以直接throw error，来验证程序对错误的处理</li></ul><h5 id="满足性能要求" tabindex="-1">满足性能要求 <a class="header-anchor" href="#满足性能要求" aria-label="Permalink to &quot;满足性能要求&quot;">​</a></h5><p>当某个程序升级的时候，是否会对性能造成影响？这需要我们对程序的性能进行测试</p><h2 id="集成测试" tabindex="-1">集成测试 <a class="header-anchor" href="#集成测试" aria-label="Permalink to &quot;集成测试&quot;">​</a></h2><h3 id="写单测的时机" tabindex="-1">写单测的时机 <a class="header-anchor" href="#写单测的时机" aria-label="Permalink to &quot;写单测的时机&quot;">​</a></h3><p>写单测的时机主要有以下三种，大家可以根据自己的实际情况来进行选择。</p><h4 id="具体实现代码之前-tdd" tabindex="-1">具体实现代码之前（TDD） <a class="header-anchor" href="#具体实现代码之前-tdd" aria-label="Permalink to &quot;具体实现代码之前（TDD）&quot;">​</a></h4><p>即测试驱动开发（TDD）：编写某个功能的代码之前先编写测试代码，然后编写使测试通过的功能代码，重复这个过程，通过测试来推动整个开发的进行。</p><p>特点：UT 能够更好的实践我们的代码设计。对于某些复杂度较高的接口（甚至是一些私有方法），建议使用 TDD 进行开发。</p><h5 id="tdd开发流程-red-creen-development" tabindex="-1">TDD开发流程（Red-Creen Development） <a class="header-anchor" href="#tdd开发流程-red-creen-development" aria-label="Permalink to &quot;TDD开发流程（Red-Creen Development）&quot;">​</a></h5><ol><li>编写测试用例</li><li>运行测试，测试用例无法通过测试</li><li>编写代码，使测试用例通过</li><li>优化代码，完成开发</li><li>当需要开发新需求新功能时，重复上述步骤</li></ol><img height="300px" src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/自动化测试/TDD开发流程.png"><h5 id="tdd的优势" tabindex="-1">TDD的优势 <a class="header-anchor" href="#tdd的优势" aria-label="Permalink to &quot;TDD的优势&quot;">​</a></h5><ol><li>长期减少回归BUG</li><li>代码质量更好（组织、可维护性）</li><li>测试覆盖率高</li><li>错误测试代码不容易出现</li></ol><h5 id="tdd的缺点" tabindex="-1">TDD的缺点 <a class="header-anchor" href="#tdd的缺点" aria-label="Permalink to &quot;TDD的缺点&quot;">​</a></h5><ul><li>安全感低</li><li>测试用例和代码耦合性较高。当修改代码后，可能需要修改多个测试用例</li></ul><h4 id="与具体实现代码同步进行" tabindex="-1">与具体实现代码同步进行 <a class="header-anchor" href="#与具体实现代码同步进行" aria-label="Permalink to &quot;与具体实现代码同步进行&quot;">​</a></h4><p>先写少量功能代码，紧接着写单元测试（重复这两个过程，直到完成功能代码开发）。</p><p>特点：每个单测比较简单易懂，可读性可维护性都比较好（重构时单测的改动不大）。</p><h4 id="编写完功能代码后-bdd" tabindex="-1">编写完功能代码后（BDD） <a class="header-anchor" href="#编写完功能代码后-bdd" aria-label="Permalink to &quot;编写完功能代码后（BDD）&quot;">​</a></h4><p>BDD（Behavior Driven Developmen）也叫行为驱动开发。这种单元测试“粒度”会比较粗。对同样的功能代码，采取前两种方案的结果可能是用10个“小”的单测来覆盖，而这种方案写的单测，往往是用1个“大”的单测来覆盖。</p><p>特点：逻辑就比较复杂，因为它要测的东西很多，可读性可维护性可能会比较差。</p><h5 id="bdd开发流程" tabindex="-1">BDD开发流程 <a class="header-anchor" href="#bdd开发流程" aria-label="Permalink to &quot;BDD开发流程&quot;">​</a></h5><ol><li>编写业务代码</li><li>根据用户行为编写测试用例</li><li>使测试用例通过</li><li>重复上述步骤</li></ol><h5 id="bdd优势" tabindex="-1">BDD优势 <a class="header-anchor" href="#bdd优势" aria-label="Permalink to &quot;BDD优势&quot;">​</a></h5><ol><li>开发效率和速度会高很多。先写代码再写测试，不会影响业务进度</li><li>测试用例和代码耦合性比较小。重新编写代码后，需修改的测试用例不会特别多</li><li>使业务逻辑更加可靠。当测试用例通过后，基本可以确定面向用户的操作也会成功</li></ol><h5 id="bdd缺点" tabindex="-1">BDD缺点 <a class="header-anchor" href="#bdd缺点" aria-label="Permalink to &quot;BDD缺点&quot;">​</a></h5><ul><li>测试覆盖率低</li></ul><h3 id="bdd和tdd开发流程区别" tabindex="-1">BDD和TDD开发流程区别 <a class="header-anchor" href="#bdd和tdd开发流程区别" aria-label="Permalink to &quot;BDD和TDD开发流程区别&quot;">​</a></h3><table><thead><tr><th>TDD</th><th>BDD</th></tr></thead><tbody><tr><td>先写测试再写代码</td><td>先写代码再写测试</td></tr><tr><td>一般结合单元测试使用，是白盒测试</td><td>一般结合集成测试使用，是黑盒测试</td></tr><tr><td>代码是测试重点</td><td>UI（DOM）是测试重点</td></tr></tbody></table><h3 id="集成测试插件" tabindex="-1">集成测试插件 <a class="header-anchor" href="#集成测试插件" aria-label="Permalink to &quot;集成测试插件&quot;">​</a></h3><p><a href="https://v1.test-utils.vuejs.org/zh/" target="_blank" rel="noreferrer">介绍 | Vue Test Utils</a></p>`,72),r=[h];function s(o,d,n,c,p,u){return e(),i("div",null,r)}const D=a(t,[["render",s]]);export{b as __pageData,D as default};
