import{_ as s,c as i,o as a,a4 as t}from"./chunks/framework.BOW58p_D.js";const E=JSON.parse('{"title":"优化关键请求链","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/浏览器原理/性能优化/页面加载阶段性能优化/1. 优化关键请求链.md","filePath":"blogs/浏览器原理/性能优化/页面加载阶段性能优化/1. 优化关键请求链.md"}'),l={name:"blogs/浏览器原理/性能优化/页面加载阶段性能优化/1. 优化关键请求链.md"},e=t(`<h1 id="优化关键请求链" tabindex="-1">优化关键请求链 <a class="header-anchor" href="#优化关键请求链" aria-label="Permalink to &quot;优化关键请求链&quot;">​</a></h1><h2 id="chrome-的预解析操作" tabindex="-1">Chrome 的预解析操作 <a class="header-anchor" href="#chrome-的预解析操作" aria-label="Permalink to &quot;Chrome 的预解析操作&quot;">​</a></h2><p>先看一个典型的渲染流水线</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/http/性能优化/渲染流水线.webp" width="600px"><p>Chrome 浏览器做了很多优化，其中一个主要的优化是<strong>预解析操作</strong>，如上图所示。当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。</p><p>当使用 TCP 协议传输一个文件时，比如这个文件大小是 0.1M，由于 TCP 的特性，这个数据并不是一次传输到服务端的，而是需要拆分成一个个数据包来回多次进行传输的。RTT 就是这里的往返时延。通常 1 个 HTTP 的数据包在 14KB 左右，所以 1 个 0.1M 的页面就需要拆分成 8 个包来传输了，也就是说需要 8 个 RTT。上图中关键资源请求共花费了 2 个 RTT。</p><p>如上图中的 JavaScript 和 CSS 文件，由于渲染引擎有一个预解析的线程，在接收到 HTML 数据之后，预解析线程会快速扫描 HTML 数据中的关键资源，一旦扫描到了，会立马发起请求，你可以认为 JavaScript 和 CSS 是同时发起请求的，所以它们的请求是重叠的，那么计算它们的 RTT 时，只需要计算体积最大的那个数据就可以了。这里最大的是 CSS 文件（9KB），所以我们就按照 9KB 来计算，同样由于 9KB 小于 14KB，所以 JavaScript 和 CSS 资源也就可以算成 1 个 RTT。</p><h2 id="资源优先级" tabindex="-1">资源优先级 <a class="header-anchor" href="#资源优先级" aria-label="Permalink to &quot;资源优先级&quot;">​</a></h2><p>资源的优先级被分为5级，浏览器内核的5级分别是VeryHigh、High、Medium、Low、VeryLow，如下图</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/http/性能优化/资源优先级.webp" height="500px"><p>浏览器资源优先级顺序的计算过程如下：</p><ul><li>第一步，根据资源的类型来设定默认优先级。 <ol><li>html、css、font这三种类型的资源优先级最高。</li><li>然后是preload资源（通过<code>&lt;link rel=“preload&quot;&gt;</code>标签预加载）、script、xhr请求。</li><li>接着是图片、语音、视频。</li><li>最低的是 prefetch 预读取的资源。</li></ol></li><li>第二步，根据一定的实际规则，对优先级进行调整。来确定出最终的加载优先级顺序。对于几个常见资源类型的调整规则如下： <ol><li><strong>对于XHR请求资源</strong>：将<strong>同步XHR请求</strong>的优先级调整为最高。（XHR请求可以分为同步请求和异步请求）。</li><li><strong>对于图片资源</strong>：会根据图片<strong>是否在可见视图内</strong>来改变优先级。 <ul><li>图片资源的默认优先级为Low。</li><li>现代浏览器为了提高用户首屏的体验，在渲染时会计算图片资源是否在首屏可见视图内，在的话，会将这部分视口可见图片(Image in viewport)资源的优先级提升为High。</li></ul></li><li><strong>对于脚本资源</strong>：浏览器会将根据脚本所处的位置和属性标签分为三类，分别设置优先级。 <ul><li>首先，对于添加了<code>defer</code>/<code>async</code>属性的脚本优先级会全部降为Low。</li><li>然后，对于没有添加该属性的脚本，根据该脚本在文档中的位置是在浏览器展示的第一帧之前还是之后，又可分为两类。 <ul><li>在之前的<code>(标记early**)</code>它会被定为 High 优先级。</li><li>在之后的<code>(标记late**)</code>会被设置为 Medium 优先级。</li></ul></li></ul></li></ol></li></ul><h3 id="关键请求链是什么" tabindex="-1">关键请求链是什么 <a class="header-anchor" href="#关键请求链是什么" aria-label="Permalink to &quot;关键请求链是什么&quot;">​</a></h3><p><strong>关键请求链（Critical-Request-Chains）</strong> 的概念。可视区域渲染完毕（首屏），并对于用户来说可用时，必须加载的资源请求队列，就叫做<strong>关键请求链</strong>。这样，我们可以通过<strong>关键请求链</strong>，来确定优先加载的资源以及加载顺序，以实现浏览器尽可能快地加载页面。</p><p>说白了就是首屏需要加载的图片、js、css等资源。关键请求链的报告如下图所示：</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/http/性能优化/关键请求链的报告.png" height="400px"><h3 id="如何查找页面的关键请求链" tabindex="-1">如何查找页面的关键请求链 <a class="header-anchor" href="#如何查找页面的关键请求链" aria-label="Permalink to &quot;如何查找页面的关键请求链&quot;">​</a></h3><ol><li>通过首屏快照获取关键image资源，如下图所示，我们通过首屏快照，来获取首屏所要加载的图片资源。(红框内)</li></ol><img height="300px" src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/http/性能优化/关键请求链示例.png"><ol start="2"><li>通过<strong>LightHouse</strong>插件获取关键请求链中的关键js和css资源</li></ol><p><strong>关键请求链</strong>最常见的一个例子是，某些样式表内部加载了在初始页面视口显示的字体或背景图像。</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@font-face</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    font-family</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: d-din;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">url</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;//res.xxx.com/resources/D-DIN.otf&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">url</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;//res.xxx.com/resources/D-DIN.woff&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="如何优化关键请求链" tabindex="-1">如何优化关键请求链 <a class="header-anchor" href="#如何优化关键请求链" aria-label="Permalink to &quot;如何优化关键请求链&quot;">​</a></h3><ul><li>减少请求的数量</li><li>使用压缩和最小化来减少资源的大小</li><li>将非关键脚本标记为异步</li><li>考虑将<code>@font-face</code>声明直接内联到 HTML 中</li><li>使用压缩的字体格式，如 WOFF2 或 variable fonts（可变形字体）</li><li>避免使用 CSS 背景图片或<code>@import</code></li><li>检查哪些请求<strong>必须</strong>在用户看到完整渲染的页面之前发出。使用 <code>&lt;link rel=&quot;preload&quot; /&gt;</code> 对这些关键请求进行优先处理</li><li>使用 Resource-Hints，优化可能在下一个导航中使用的资源<div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">资源预加载：&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;prefetch&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;test.css&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">DNS预解析：&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dns-prefetch&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;//xxx.com&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">http预连接：&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;preconnect&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;//xxx.com&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;不光会解析 DNS，还会建立 TCP 握手连接和 TLS 协议</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">页面预渲染：&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;prerender&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;//xxx.com&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt; 将会预先加载链接文档的所有资源</span></span></code></pre></div></li><li>利用<strong>LocalStorage</strong>，对部分请求的数据和结果进行缓存，省去发送http请求所消耗的时间，从而提高网页的响应速度。具体方式可以看这里👉<a href="https://juejin.cn/post/6844903545016156174#heading-7" target="_blank" rel="noreferrer">浏览器页面资源加载过程与优化</a>👈</li><li>图片懒加载。可以通过第三方库和手写的方式；现在浏览器原生也支持了懒加载<code>&lt;img loading=&quot;lazy&quot; /&gt;</code>；需要确保设置图像的<code>width</code>和<code>height</code>属性，以避免懒加载的图像在渲染时，页面重新布局</li></ul><h4 id="font-face" tabindex="-1"><code>@font-face</code> <a class="header-anchor" href="#font-face" aria-label="Permalink to &quot;\`@font-face\`&quot;">​</a></h4><p><strong>每个人都目睹过字体出现，然后消失，改变了粗细，页面仿佛被震动了一样。这些移位现在会被累积布局移位（CLS）指标所测量。</strong></p><blockquote><p>可以用 <code>font-display</code> 来优化 Largest Contentful Paint（最大内容绘制）和 Cumulative Layout Shift（累积布局偏移）</p></blockquote><p>所以大部分情况下都应该提高字体请求的优先级；</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;preload&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;d-din.woff&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;font&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> crossorigin </span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">/&gt;</span></span></code></pre></div><p>还可以用 CSS <code>font-display</code>进一步提高渲染速度。这个 CSS 属性允许你控制字体在请求和加载后如何展示。</p><p>有五个<code>font-display</code>选项供我们选择。推荐使用 <code>swap</code> 选项，它可以先立即呈现文本，然后在加载网络字体后立即替换。</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">  font-family</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: Calibre, Helvetica, Arial;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>加上后的提速效果可以看这里👉<a href="https://mp.weixin.qq.com/s/jwy1pZAKoLeQ4ZPtxZg2kw" target="_blank" rel="noreferrer">Web 性能优化：控制关键请求的优先级</a>👈</p>`,33),h=[e];function n(p,r,o,k,d,g){return a(),i("div",null,h)}const y=s(l,[["render",n]]);export{E as __pageData,y as default};
