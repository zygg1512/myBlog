import{_ as s,c as i,o as a,a4 as t}from"./chunks/framework.BOW58p_D.js";const E=JSON.parse('{"title":"IEEE-754 64位双精度浮点数","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/V8引擎/JavaScript设计思想/3. IEEE-754标准.md","filePath":"blogs/V8引擎/JavaScript设计思想/3. IEEE-754标准.md"}'),e={name:"blogs/V8引擎/JavaScript设计思想/3. IEEE-754标准.md"},h=t(`<h1 id="ieee-754-64位双精度浮点数" tabindex="-1">IEEE-754 64位双精度浮点数 <a class="header-anchor" href="#ieee-754-64位双精度浮点数" aria-label="Permalink to &quot;IEEE-754 64位双精度浮点数&quot;">​</a></h1><h2 id="十进制转换为二进制" tabindex="-1">十进制转换为二进制 <a class="header-anchor" href="#十进制转换为二进制" aria-label="Permalink to &quot;十进制转换为二进制&quot;">​</a></h2><ul><li><strong>十进制整数转换为二进制整数</strong>：采用”除2取余，逆序排列”法。 <ul><li>具体做法是：用 2 去除十进制整数，可以得到一个商和余数；再用 2 去除商，又会得到一个商和余数，如此进行，直到商为零时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。</li></ul></li><li><strong>十进制小数转换成二进制小数</strong>：采用”乘2取整，顺序排列”法。 <ul><li>具体做法是：用 2 乘十进制小数，可以得到积，将积的整数部分取出，再用 2 乘余下的小数 部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，或者达到所要求的精度为止。然后把取出的整数部分按顺序排列起来，先取的整数作为二进制小数的高位有效位，后取的整数作为低位有效位。</li></ul></li></ul><p>如下图，将十进制<code>173.8125</code>转换为二进制： <img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/十进制转换二进制.png" height="400px"></p><h2 id="ieee-754-标准" tabindex="-1">IEEE-754 标准 <a class="header-anchor" href="#ieee-754-标准" aria-label="Permalink to &quot;IEEE-754 标准&quot;">​</a></h2><blockquote><p><a href="https://www.binaryconvert.com/convert_double.html" target="_blank" rel="noreferrer">IEEE754生成器</a></p></blockquote><p>IEEE-754双精度浮点数(double floating-point)存储为64bit，由符号位(s)、偏差指数(e)、小数部分(f)组成：</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/IEEE754.png"><table><thead><tr><th>组成</th><th>描述</th><th>位数</th><th>位置</th></tr></thead><tbody><tr><td>sign</td><td>符号，0表示正，1表示负</td><td>1bit</td><td>63</td></tr><tr><td>exponent</td><td>偏差指数</td><td>11bit</td><td>52-62</td></tr><tr><td>fraction</td><td>小数部分，有效数精度</td><td>52bit</td><td>0-51</td></tr></tbody></table><h3 id="存储规则" tabindex="-1">存储规则 <a class="header-anchor" href="#存储规则" aria-label="Permalink to &quot;存储规则&quot;">​</a></h3><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">V</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (-1)^S </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 2^(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">E</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1023</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">F</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><ul><li><code>V</code>：需要存储的二进制数</li><li><code>S</code>：数值正负，0表示正数，1表示负数，对应1bit的符号位</li><li><code>E - 1023</code>：将二进制用科学计数法表示后的指数部分。即<code>a * 2^n</code>，其中 a 是由 0 和 1 组成的二进制表示，n 是整数。 <ul><li>E 是一个无符号整数，在 64 位浮点数中，指数位<code>E</code>的长度是 11 位，取值范围是<code>[0~2047]</code>。由于科学计数法中指数可正可负，所以，中间数是1023，<code>[0,1022]</code>表示为负，<code>[1024,2047]</code>表示为正</li></ul></li><li><code>F</code>：为52位有效位，其中的每一位是 0 或 1，对应 52bit 的<strong>小数部分</strong>（不足 52 位补 0 ）。 <ul><li>因为<code>F</code>表示的是二进制形式的浮点数，也就是说 M 的整数位始终是 1，所以可以舍去，只保留后面的小数部分，这样就能表示 53 位了。</li><li>本质是 52 位显式存储，加 1 个隐藏位（值固定是 1），所以能表示 53 位。</li></ul></li></ul><h4 id="存储示例" tabindex="-1">存储示例 <a class="header-anchor" href="#存储示例" aria-label="Permalink to &quot;存储示例&quot;">​</a></h4><p>比如计算<code>2.25</code>的双精度浮点数：</p><ol><li>2.25 转为二进制为 10.01</li><li>数值为正，因此符号位 S 是 0</li><li>10.01转为科学技术法后表示为 1.001 * 2^1，因此通过 E-1023 = 1，得出偏差指数 E 为 1024，二进制值为 10000000000（11位）</li><li>将 1.001 的整数位 1 省略，保留小数位，小数位的值为 001，不足 52 位，补 0，得到<code>0010000000000000000000000000000000000000000000000000</code>, 001 后面有 49 个 0，共 52 位。</li></ol><p>综上，将 1 位符号、11 位指数、52 位小数整合可得到 2.25 的双精度浮点数表示：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10000000000</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0010000000000000000000000000000000000000000000000000</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#    S      E                               F</span></span></code></pre></div><h4 id="小数部分的舍入问题" tabindex="-1">小数部分的舍入问题 <a class="header-anchor" href="#小数部分的舍入问题" aria-label="Permalink to &quot;小数部分的舍入问题&quot;">​</a></h4><p>上面这个例子中，小数部分不存在舍入的问题（位数小于52位），那么如果小数超出了52位，有以下几种情况：</p><ol><li>第 53 位是 0，无需处理。</li><li>第53位是 1 且 53 位之后全是 0：</li><li>若第 52 位是 0，无需处理。</li><li>若第 52 位是 1，那么向上舍入。</li><li>第 53 位是 1，且之后不全是 0：那么向上舍入。</li></ol><p>再看一个例子，计算<code>23.3</code>的双精度浮点数：</p><p>23.3 转为二进制为</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">10111.0100110011001100110011001100110011001100110011001100...(1100</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 循环</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>数值为正，因此符号位 S 是 0。指数<code>E - 1023 = 4</code>，转为二进制后<code>E = 1027 = 10000000011</code>，因此偏差指数是<code>10000000011</code>。</p><p>小数位无限循环，53 位是 1 且之后不全是 0，符合上述规则 3，因此向上舍入，第 52 位由 0 变为 1，最终小数部分为：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">0111010011001100110011001100110011001100110011001101</span></span></code></pre></div><p>整合后得到 23.3 的双精度浮点数表示：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">     0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10000000011</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0111010011001100110011001100110011001100110011001101</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#    S      E                               F</span></span></code></pre></div><h3 id="数值类型" tabindex="-1">数值类型 <a class="header-anchor" href="#数值类型" aria-label="Permalink to &quot;数值类型&quot;">​</a></h3><p>11位的偏差指数可存储 00000000000 ~ 11111111111（十进制范围为0 ~ 2047），可分为3种情况：</p><ul><li><strong>规格化</strong>：偏差指数不为 00000000000 和 11111111111，即在 00000000001 ~ 11111111110（1 ~ 2046）范围。</li><li><strong>非规格化</strong>：小数部分<code>F</code>和偏差指数<code>E</code>均为 0。</li><li><strong>特殊值</strong>：偏差指数为 11111111111（2047），有两种情况： <ul><li>当<code>F = 0</code>，且<code>S = 0</code>时，表示 +Infinity (正无穷)。</li><li>当<code>F = 0</code>，且<code>S = 1</code>时，表示 -Infinity (正无穷)。</li><li>当<code>F &gt; 0</code>时，表示 NaN (Not a Number)。</li></ul></li></ul><h2 id="javascript-中的二进制问题" tabindex="-1">JavaScript 中的二进制问题 <a class="header-anchor" href="#javascript-中的二进制问题" aria-label="Permalink to &quot;JavaScript 中的二进制问题&quot;">​</a></h2><h3 id="toprecision-和-tofixed" tabindex="-1">toPrecision 和 toFixed <a class="header-anchor" href="#toprecision-和-tofixed" aria-label="Permalink to &quot;toPrecision 和 toFixed&quot;">​</a></h3><ul><li><code>toPrecision</code>方法：以指定的精度返回该数值的字符串。精度是从左至右第一个不为 0 的数开始数起，支持四舍五入。</li><li><code>toFixed</code>方法：使用定点表示法返回该数值的字符串。是小数点后指定位数取整，从小数点开始数起，支持四舍五入。</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> x</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.235</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">x.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toPrecision</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;1.24&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> y</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.2356</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">y.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toFixed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;1.236&quot;</span></span></code></pre></div><h4 id="问题点" tabindex="-1">问题点 <a class="header-anchor" href="#问题点" aria-label="Permalink to &quot;问题点&quot;">​</a></h4><p>这两个方法在截取数字时，都有进行四舍五入处理，但是都存在 BUG</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.005</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toPrecision</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 理论上应该返回 &quot;1.01&quot;，但实际上返回的是 &quot;1.00&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1.005</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toFixed</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 理论上应该返回 &quot;1.01&quot;，但实际上返回的是 &quot;1.00&quot;</span></span></code></pre></div><p>原因是：1.005 实际对应的数字是 1.00499999999999989，在四舍五入时全部被舍去了。</p><h3 id="_0-1-0-2-0-30000000000000004" tabindex="-1"><code>0.1 + 0.2 = 0.30000000000000004</code> <a class="header-anchor" href="#_0-1-0-2-0-30000000000000004" aria-label="Permalink to &quot;\`0.1 + 0.2 = 0.30000000000000004\`&quot;">​</a></h3><p>在计算<code>0.1 + 0.2</code>的时候，会先将其转换为二进制，得到的结果也是二进制，然后再将其转换为十进制。</p><p>通过上述公式，<code>0.1</code>和<code>0.2</code>的二进制如下：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">0.1:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 01111111011</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 10011001100110011001100110011001100110011001100110011（53位）</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 0.1 的二进制会无限循环1100，且53位是1，之后不全是 0，符合上述规则3，向上取整后如下：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=&gt;   </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 01111111011</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 1001100110011001100110011001100110011001100110011010（52位）</span></span>
<span class="line"></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">0.2:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 01111111100</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 10011001100110011001100110011001100110011001100110011（53位）</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 0.2 的二进制会无限循环1100，且53位是1，之后不全是 0，符合上述规则3，向上取整后如下：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=&gt;   </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 01111111100</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 1001100110011001100110011001100110011001100110011010（52位）</span></span></code></pre></div><p>由于精度问题，存储<code>0.1</code>和<code>0.2</code>的二进制时会被向上取整，导致最后累加计算之后不等于<code>0.3</code>，而是等于<code>0.30000000000000004</code>。</p><p><strong>可通过扩大倍数再缩减倍数的方式解决。</strong></p><h3 id="为什么x-0-1能得到0-1" tabindex="-1">为什么<code>x = 0.1</code>能得到<code>0.1</code>？ <a class="header-anchor" href="#为什么x-0-1能得到0-1" aria-label="Permalink to &quot;为什么\`x = 0.1\`能得到\`0.1\`？&quot;">​</a></h3><p>0.1 的实际值是<code>0.100000000000000005551...</code>。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toPrecision</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">21</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 0.100000000000000005551</span></span></code></pre></div><p>因为 小数部分 固定长度是 52 位，再加上截取策略，最多可以表示的数是<code>2^53 - 1 = 9007199254740992</code>，这也是 JS 最多能表示的精度。它的长度是 16。所以仅展示至第 16 位。抹掉末尾的零后正好为 0.1。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.10000000000000000555</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toPrecision</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 返回 0.1000000000000000，去掉末尾的零后正好为 0.1</span></span></code></pre></div><h3 id="数值范围" tabindex="-1">数值范围 <a class="header-anchor" href="#数值范围" aria-label="Permalink to &quot;数值范围&quot;">​</a></h3><p>根据浮点数算术标准，偏差指数最大值为 2047，<code>E = 2047 -1023 = 1024</code>。</p><p>所以 JavaScript 能表示的数值范围是：<code>[-(2^1024-1), +(2^1024-1)]</code>，即：正负<code>1.7976931348623157 * 10^308</code>，但实际情况并不是这样：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1023</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 8.98846567431158e+307</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1024</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// Infinity</span></span></code></pre></div><h4 id="最大安全正整数和最小安全负整数" tabindex="-1">最大安全正整数和最小安全负整数 <a class="header-anchor" href="#最大安全正整数和最小安全负整数" aria-label="Permalink to &quot;最大安全正整数和最小安全负整数&quot;">​</a></h4><p>当<code>E - 1023 = 52</code>，即<code>E = 1075</code>，小数<code>F</code>最大（52 位全为 1 ）时，能表示出最大安全正整数为：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  1.111...11</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> *</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 2^52</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 111111.....1111</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">#   52个1                 53个1</span></span></code></pre></div><p>转为十进制值为<code>2^53 - 1 = 9007199254740991</code>，相应的最小安全负整数为<code>-9007199254740991</code>。</p><p>JavaScript 规定能安全的表示数字(进行精确算术运算)的范围在：<code>[-2^53 - 1, +2^53 - 1]</code>。</p><p>对于超过这个范围的整数，JavaScript 依旧可以进行运算，但却不保证运算结果的准确性，这也是 JavaScript 中安全整数的两个边界：</p><ul><li><code>Number.MIN_SAFE_INTEGER</code></li><li><code>Number.MAX_SAFE_INTEGER</code></li></ul><p>超过安全整数范围的，计算不保证正确，例如：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">53</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 9007199254740992</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">53</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 9007199254740992</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pow</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">53</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 9007199254740994</span></span></code></pre></div><p>对于不在<code>[-2^53, +2^53]</code>范围中的数字，例如<code>(2^53, 2^63)</code>之间的数会出现什么情况呢？</p><ul><li><code>(2^53, 2^54)</code>之间的数会两个选一个，只能精确表示偶数</li><li><code>(2^54, 2^55)</code>之间的数会四个选一个，只能精确表示 4 的倍数</li><li>...依次跳过更多 2 的倍数</li></ul><h2 id="v8-是怎么执行加法操作的" tabindex="-1">V8 是怎么执行加法操作的？ <a class="header-anchor" href="#v8-是怎么执行加法操作的" aria-label="Permalink to &quot;V8 是怎么执行加法操作的？&quot;">​</a></h2><p>V8 会提供了一个 ToPrimitive 方法，其作用是将 a 和 b 转换为原生数据类型，其转换流程如下：</p><ul><li>先检测该对象中是否存在<code>valueOf</code>方法，如果有并返回了原始类型，那么就使用该值进行强制类型转换。</li><li>如果<code>valueOf</code>没有返回原始类型，那么就使用<code>toString</code>方法的返回值。</li><li>如果<code>vauleOf</code>和<code>toString</code>两个方法都不返回基本类型值，便会触发一个<code>TypeError</code>的错误。</li></ul><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/V8加法原理.webp" height="300px">`,69),l=[h];function n(p,k,d,o,r,c){return a(),i("div",null,l)}const y=s(e,[["render",n]]);export{E as __pageData,y as default};
