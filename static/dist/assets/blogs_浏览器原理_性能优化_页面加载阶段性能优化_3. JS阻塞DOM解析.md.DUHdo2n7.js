import{_ as s,c as a,o as i,a4 as t}from"./chunks/framework.BOW58p_D.js";const y=JSON.parse('{"title":"JavaScript 如何阻塞 DOM 解析","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/浏览器原理/性能优化/页面加载阶段性能优化/3. JS阻塞DOM解析.md","filePath":"blogs/浏览器原理/性能优化/页面加载阶段性能优化/3. JS阻塞DOM解析.md"}'),e={name:"blogs/浏览器原理/性能优化/页面加载阶段性能优化/3. JS阻塞DOM解析.md"},l=t(`<h1 id="javascript-如何阻塞-dom-解析" tabindex="-1">JavaScript 如何阻塞 DOM 解析 <a class="header-anchor" href="#javascript-如何阻塞-dom-解析" aria-label="Permalink to &quot;JavaScript 如何阻塞 DOM 解析&quot;">​</a></h1><p>JavaScript 脚本会阻塞 DOM 解析，当 HTML 解析器解析到<code>script</code>标签时，这时候 HTML 解析器暂停工作，JavaScript 引擎介入，并执行<code>script</code>标签中的脚本。如果通过 JavaScript 文件加载，则会先下载 JavaScript 文件，然后执行，当执行完成后 HTML 解析器继续工作。</p><h2 id="优化方案" tabindex="-1">优化方案 <a class="header-anchor" href="#优化方案" aria-label="Permalink to &quot;优化方案&quot;">​</a></h2><ul><li>使用 CDN 来加速 JavaScript 文件的加载</li><li>压缩 JavaScript 文件的体积</li><li>如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载（async和defer）</li></ul><h3 id="async和defer的区别" tabindex="-1">async和defer的区别 <a class="header-anchor" href="#async和defer的区别" aria-label="Permalink to &quot;async和defer的区别&quot;">​</a></h3><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 绿色 HTML 解析</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 灰色 HTML 解析暂停</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 紫色 下载 js</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># 红色 执行 js</span></span></code></pre></div><ul><li>normal（无属性）：在 DOM 解析阶段开始下载，并且阻塞 DOM 解析，下载完成之后再恢复 DOM 解析。</li></ul><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/http/性能优化/script-normal.webp" width="600px"><ul><li>defer：在 DOM 解析阶段开始下载 JavaScript，不阻塞 DOM 解析，并在 DOM 解析渲染完成之后再执行。需要在<code>DOMContentLoaded</code>事件之前执行。按顺序执行。</li></ul><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/http/性能优化/script-defer.webp" width="600px"><p>虽然理论上 defer 按加载顺序执行，<a href="https://segmentfault.com/a/1190000017257370" target="_blank" rel="noreferrer">但是也有失效的情况</a>。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 特殊情况下，\`2.js\`会失效 --&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 1.js 生成 DOM --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;1.js&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 2.js 操作生成的 DOM --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;2.js&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>《JavaScript 高级程序设计（第三版）》：在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 DOMContentLoaded 事件触发前执行，因此最好只包含一个延迟脚本。</p><p>所以脚本之间有依赖，最好使用一个延迟脚本吧。比如上面那个问题 可以改成这样<code>&lt;script src=&quot;1.js&quot;&gt;&lt;/script&gt;</code></p><ul><li>async：在 DOM 解析阶段开始下载 JavaScript，不阻塞 DOM 解析，在下载完成之后立即执行，如果 DOM 正在解析则阻塞住。不保证执行顺序。</li></ul><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/http/性能优化/script-async.webp" width="600px"><h4 id="区别" tabindex="-1">区别 <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别&quot;">​</a></h4><p>推荐优先级依次是 async、defer、normal：</p><ul><li>如果依赖其他脚本和 DOM 结果，使用 defer</li><li>如果与 DOM 和其他脚本依赖不强时，使用 async</li><li>如果 JavaScript 文件很小且被 async script 依赖，使用正常模式的 script 且放在 async script 前面</li></ul>`,19),p=[l];function n(r,h,c,d,k,o){return i(),a("div",null,p)}const D=s(e,[["render",n]]);export{y as __pageData,D as default};
