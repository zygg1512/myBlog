import{_ as s,c as i,o as a,a4 as n}from"./chunks/framework.BOW58p_D.js";const g=JSON.parse('{"title":"pnpm","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/前端基础/Node/包管理工具/PNPM/1. pnpm.md","filePath":"blogs/前端基础/Node/包管理工具/PNPM/1. pnpm.md"}'),p={name:"blogs/前端基础/Node/包管理工具/PNPM/1. pnpm.md"},l=n(`<h1 id="pnpm" tabindex="-1">pnpm <a class="header-anchor" href="#pnpm" aria-label="Permalink to &quot;pnpm&quot;">​</a></h1><blockquote><p><a href="https://pnpm.io/zh/" target="_blank" rel="noreferrer">pnpm官网</a></p></blockquote><h2 id="pnpm-出现的原因" tabindex="-1">pnpm 出现的原因 <a class="header-anchor" href="#pnpm-出现的原因" aria-label="Permalink to &quot;pnpm 出现的原因&quot;">​</a></h2><h3 id="npm-和-yarn" tabindex="-1">npm 和 Yarn <a class="header-anchor" href="#npm-和-yarn" aria-label="Permalink to &quot;npm 和 Yarn&quot;">​</a></h3><p>Yarn 在 npm3.x 的时候出现的，那个时候 npm 还没有版本锁定文件（<code>package-lock.json</code>），并伴随着不稳定性、安装速度慢等缺点。此时 Yarn 诞生。</p><p>尽管 npm 发展至今，已经在很多方面向 Yarn 看齐，但是 Yarn 提出的安装理念很好的解决了当时 npm 的依赖管理问题， Yarn 有以下优点</p><ul><li><strong>速度快</strong><ul><li>并行安装：无论 npm 还是 Yarn 在执行包的安装时，都会执行一系列任务。npm 是按照队列执行每个 package，也就是说必须要等到当前 package 安装完成之后，才能继续后面的安装。而 Yarn 是同步执行所有任务，提高了性能</li><li>离线模式：如果之前已经安装过一个软件包，用 Yarn 再次安装时会从缓存中获取，npm5.x 之后也有缓存但是读取速度不如 Yarn</li></ul></li><li><strong>版本统一</strong>：为了防止拉取到不同的版本， Yarn 有一个锁定文件 (lock file) 记录了被确切安装上的模块的版本号。每次只要新增了一个模块， Yarn 就会创建（或更新）<code>yarn.lock</code>这个文件。npm5.x 之后也有了锁定文件，但是策略和 Yarn 略有差异</li><li><strong>更简洁的输出</strong>：npm 的输出信息比较冗长。在执行 npm install 的时候，命令行里会不断地打印出所有被安装上的依赖。相比之下， Yarn 简洁太多：默认情况下，结合了 emoji直观且直接地打印出必要的信息，也提供了一些命令供开发者查询额外的安装信息</li><li><strong>更好的语义化</strong>： Yarn 改变了一些npm命令的名称，比如 Yarn add/remove，感觉上比 npm 原本的 install/uninstall 要更清晰</li></ul><h3 id="现阶段的-npm-和-yarn" tabindex="-1">现阶段的 npm 和 Yarn <a class="header-anchor" href="#现阶段的-npm-和-yarn" aria-label="Permalink to &quot;现阶段的 npm 和 Yarn&quot;">​</a></h3><p><strong>相同点：</strong></p><ol><li>package.json 作为项目依赖描述文件</li><li>node_modules 作为依赖存储目录</li><li>lockfile 锁定版本依赖，在 Yarn 中叫<code>yarn.lock</code>，在 npm 中叫 package-lock.json，在 npm v7 也支持了<code>yarn.lock</code>。它确保在不同机器或不同环境中，能够得到稳定的 node_modules 目录结构。</li><li>安装依赖时都会有扁平化操作</li></ol><p><strong>差异：</strong></p><ol><li>依赖管理策略 <ul><li><strong>package-lock.json 自带版本锁定+依赖结构</strong>，生成 package-lock.json 后，如果手动修改 package.json 中的版本，重新执行<code>npm install</code>会根据版本号是否相同去修改</li><li><strong><code>yarn.lock</code>自带版本锁定，并没有确定的依赖结构</strong>，在执行前对比一遍 package.json 和<code>yarn.lock</code>中的版本，如果版本范围完全不符的话会重新安装并更新<code>yarn.lock</code></li></ul></li><li>目前 npm v7 优化了缓存和下载网络策略，性能的差异在缩小</li></ol><h3 id="npm-yarn-痛点" tabindex="-1">npm / Yarn 痛点 <a class="header-anchor" href="#npm-yarn-痛点" aria-label="Permalink to &quot;npm / Yarn 痛点&quot;">​</a></h3><p><strong>共有痛点：</strong></p><ul><li><strong><code>非法访问依赖</code>的问题</strong>：由于 npm / Yarn 都会执行扁平化，就会导致没有在<code>package.json</code>中声明的包，依然可以在项目中引用。</li><li><ul><li>扁平化算法本身的<strong>复杂性</strong>很高，耗时较长。</li></ul></li><li><strong>monorepo 的支持度不高。</strong></li></ul><p><strong>npm独有痛点：</strong></p><ul><li><strong>依赖结构的不确定性</strong>：假设有两个依赖包A、B，他们分别依赖C的1.x和2.x；当通过扁平化处理时，并不能确定会提升 C 的哪个版本。</li><li><strong>会重复安装同一个包</strong>：如果 100 个项目都依赖 lodash，那么 lodash 很可能就被安装了 100 次，磁盘中就有 100 个地方写入了这部分代码。</li></ul><h2 id="什么是-pnpm" tabindex="-1">什么是 pnpm <a class="header-anchor" href="#什么是-pnpm" aria-label="Permalink to &quot;什么是 pnpm&quot;">​</a></h2><p>pnpm 本质上就是一个包管理器，这一点跟 npm / Yarn 没有区别，但它作为杀手锏的两个优势在于：</p><ul><li>包安装速度极快</li><li>磁盘空间利用非常高效</li></ul><h4 id="pnpm特性" tabindex="-1">pnpm特性 <a class="header-anchor" href="#pnpm特性" aria-label="Permalink to &quot;pnpm特性&quot;">​</a></h4><ul><li><strong>速度快</strong></li><li><strong>高效利用磁盘</strong><ul><li>对于不同项目中相同版本号的依赖包，pnpm只会安装一次，使用时都会使用<code>hardlink</code>（硬链接）文件</li><li>即使一个包的不同版本，pnpm 也会极大程度地复用之前版本的代码。</li></ul></li><li><strong>原生支持 monorepo</strong></li><li><strong>规避了<code>非法访问依赖</code>的问题</strong><ul><li>pnpm安装依赖时，生成的<code>node_modules</code>只包含<code>package.json</code>中声明的依赖的软链接，这个软链接指向项目中<code>.pnpm</code>目录；该目录内存放依赖包的硬链接指向全局<code>.pnpm-store</code>目录。如果包依赖其他包，这些被依赖的包会平铺在<code>.pnpm/包名/node_modules</code>下</li></ul></li></ul><h3 id="依赖管理是如何高效利用磁盘的" tabindex="-1">依赖管理是如何高效利用磁盘的 <a class="header-anchor" href="#依赖管理是如何高效利用磁盘的" aria-label="Permalink to &quot;依赖管理是如何高效利用磁盘的&quot;">​</a></h3><h4 id="不会重复安装相同依赖" tabindex="-1">不会重复安装相同依赖 <a class="header-anchor" href="#不会重复安装相同依赖" aria-label="Permalink to &quot;不会重复安装相同依赖&quot;">​</a></h4><p>pnpm 的速度快、高效利用磁盘都体现在依赖管理上。<strong>对于不同项目中相同版本号的依赖包，在使用 pnpm 只会安装一次，磁盘中只有一个地方写入，后面再次使用都会直接使用<code>hardlink</code>（硬链接）文件。</strong> pnpm 会将项目的所有依赖项的<code>hard links</code>（硬连接）文件存储在全局的 store 目录里 ；<code>hard link</code>使得用户可以通过不同的路径引用方式去找到某个文件。</p><p>用 npm 的时候，如果 100 个项目都依赖 lodash，那么 lodash 很可能就被安装了 100 次，磁盘中就有 100 个地方写入了这部分代码。</p><p>举个例子，例如项目里面有个 1MB 的依赖 a，在 pnpm 中，看上去这个 a 依赖同时占用了 1MB 的 node_modules 目录以及全局 store 目录 1MB 的空间(加起来是 2MB)，但因为<code>hard link</code>的机制使得两个目录下相同的 1MB 空间能从两个不同位置进行寻址，因此实际上这个 a 依赖只用占用 1MB 的空间，而不是 2MB。</p><h4 id="不同版本依赖的代码会被复用" tabindex="-1">不同版本依赖的代码会被复用 <a class="header-anchor" href="#不同版本依赖的代码会被复用" aria-label="Permalink to &quot;不同版本依赖的代码会被复用&quot;">​</a></h4><p><strong>即使一个包的不同版本，pnpm 也会极大程度地复用之前版本的代码。</strong></p><p>举个例子，比如 lodash 有 100 个文件，更新版本之后<strong>多了一个文件</strong>，那么磁盘当中并不会重新写入 101 个文件，而是保留原来的 100 个文件的<code>hardlink</code>，仅仅写入那<code>一个新增的文件</code>。</p><h4 id="hard-link-机制" tabindex="-1">hard link 机制 <a class="header-anchor" href="#hard-link-机制" aria-label="Permalink to &quot;hard link 机制&quot;">​</a></h4><blockquote><p><a href="https://blog.csdn.net/stupid56862/article/details/90785420" target="_blank" rel="noreferrer">硬连接解释</a></p></blockquote><p>硬链接(hard link) ： 可以将它理解为一个 “指向原始文件 inode（存储文件的权限与属性）的指针”，系统不为它分配独立的 inode 和 文件。所以，<strong>硬链接文件与原始文件其实是同一个文件，只是名字不同。</strong></p><p>我们每添加一个硬链接，该文件的 inode 连接数就会增加1； 而且只有当该文件的 inode 连接数为0时，才算彻底被将它删除。因此即便删除原始文件，依然可以通过硬链接文件来访问。</p><h3 id="store-目录" tabindex="-1">Store 目录 <a class="header-anchor" href="#store-目录" aria-label="Permalink to &quot;Store 目录&quot;">​</a></h3><p>上一节提到 store 目录用于存储依赖的 hard link 文件，这一节简单介绍一下这个 store 目录。一般 store 目录默认是设置在<code>\${os.homedir}/.pnpm-store</code>这个目录下</p><p>因为这样一个机制导致每次安装依赖的时候，如果是个相同的依赖，且有好多项目都用到这个依赖，那么这个依赖实际上最优情况(即版本相同)只用安装一次。</p><p>如果是 npm 或 Yarn ，那么这个依赖在多个项目中使用，在每次安装的时候都会被重新下载一次。</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/Node/pnpm-store目录.jpeg"><p>如图可以看到在使用 pnpm 对项目安装依赖的时候，如果某个依赖在 sotre 目录中存在的话，那么就会直接从 store 目录里面去 hard-link，避免了二次安装带来的时间消耗，如果依赖在 store 目录里面不存在的话，就会去下载一次。</p><h4 id="清空不被全局项目使用的依赖" tabindex="-1">清空不被全局项目使用的依赖 <a class="header-anchor" href="#清空不被全局项目使用的依赖" aria-label="Permalink to &quot;清空不被全局项目使用的依赖&quot;">​</a></h4><p>pnpm 有一个命令<code>pnpm store prune</code>；他的作用是删除一些不被全局项目引用到的 packages。</p><p>例如有个包<code>axios@1.0.0</code>被一个项目引用了，但是某次修改使得项目里这个包被更新到了<code>1.0.1</code>，那么 store 里面的 1.0.0 的 axios 就成了个不被引用的包，执行<code>pnpm store prune</code>就可以在 store 里面删掉它了。</p><h3 id="node-modules-结构" tabindex="-1">node_modules 结构 <a class="header-anchor" href="#node-modules-结构" aria-label="Permalink to &quot;node_modules 结构&quot;">​</a></h3><p>例如在项目中使用 pnpm 安装了一个叫做<code>express</code>的依赖，那么最后会在 node_modules 中形成这样两个目录结构:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">node_modules/express/...</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">node_modules/.pnpm/express@4.17.1/node_modules/xxx</span></span></code></pre></div><p>第一个路径是 Node.js 正常寻找路径会去找的一个目录，如果去查看这个目录下的内容，会发现里面连个<code>node_modules</code>文件都没有：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">▾</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> express</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    ▸</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> lib</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      History.md</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      index.js</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      LICENSE</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      package.json</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      Readme.md</span></span></code></pre></div><p>实际上这个文件只是个软连接，它生成一个软连接，链接到<code>.pnpm</code>这个目录下的对应内容。这样 Node.js 在找路径的时候，最终会找到<code>.pnpm</code>这个目录下</p><p>其中这个<code>.pnpm</code>是个虚拟磁盘目录，然后 express 这个依赖的一些依赖会被平铺到<code>.pnpm/express@4.17.1/node_modules/</code>这个目录下面，这样保证了依赖能够 require 到，同时也不会形成很深的依赖层级</p><p>也就是说当 Node.js 寻找路径时，他的路线是：</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">引用依赖</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node_modules</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 软链接</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">symlink</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 虚拟磁盘目录下</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.pnpm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 目录</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 硬连接</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hardlink</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 全局Store</span></span></code></pre></div><p>假如有一个项目依赖了<code>bar@1.0.0</code>和<code>foo@1.0.0</code>，那么最后的 node_modules 结构呈现出来的依赖结构可能会是这样的:</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">node_modules</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">└──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bar</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> //</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> symlink</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> to</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> .pnpm/bar@1.0.0/node_modules/bar</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">└──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> foo</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> //</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> symlink</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> to</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> .pnpm/foo@1.0.0/node_modules/foo</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">└──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> .pnpm</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    ├──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bar@1.0.0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    │</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">   └──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node_modules</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    │</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">       └──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">stor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">e</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/bar</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    │</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">           ├──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> index.js</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    │</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">           └──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> package.json</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    └──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> foo@1.0.0</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        └──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> node_modules</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">            └──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> -</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">stor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">e</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/foo</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                ├──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> index.js</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">                └──</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> package.json</span></span></code></pre></div><p><code>node_modules</code>中的 bar 和 foo 两个目录会软连接到<code>.pnpm</code>这个目录下的真实依赖中，而这些真实依赖则是通过 hard link 存储到全局的 Store 目录中。</p><h3 id="规避了非法访问依赖的问题" tabindex="-1">规避了<code>非法访问依赖</code>的问题 <a class="header-anchor" href="#规避了非法访问依赖的问题" aria-label="Permalink to &quot;规避了\`非法访问依赖\`的问题&quot;">​</a></h3><p>pnpm 这种依赖管理的方式也很巧妙地规避了<code>非法访问依赖</code>的问题，也就是只要一个包未在<code>package.json</code>中声明，那么在项目中是无法访问的。因为引用依赖时，会去<code>node_modules</code>中查找，但是 pnpm 生成的<code>node_modules</code>只包含<code>package.json</code>中声明的依赖的软链接。</p><p>这个在 npm / Yarn 中是做不到的，比如 A 依赖 B， B 依赖 C，在 npm / Yarn 中：</p><ul><li>A 就算没有声明 C 的依赖，由于有依赖提升的存在，C 被装到了 A 的<code>node_modules</code>里面，那在 A 里面用 C 是没问题的。</li><li>假如之前B依赖的是<code>C@1.0.1</code>，现在发了新版，新版本的 B 依赖<code>C@2.0.1</code>，那么在项目 A 当中 npm / Yarn 安装之后，装上的是 2.0.1 版本的 C，而 A 当中用的还是 C 当中旧版的 API，可能就直接报错了。</li><li>如果 B 更新之后，可能不需要 C 了，那么安装依赖的时候，C 都不会装到<code>node_modules</code>里面，A 当中引用 C 的代码直接报错。</li></ul><p>这些，都是依赖提升潜在的 bug。npm 也有想过去解决这个问题，指定<code>--global-style</code>参数即可禁止变量提升，但这样做相当于回到了当年嵌套依赖的时代。</p><h2 id="如何使用-pnpm" tabindex="-1">如何使用 pnpm <a class="header-anchor" href="#如何使用-pnpm" aria-label="Permalink to &quot;如何使用 pnpm&quot;">​</a></h2><h3 id="安装-pnpm" tabindex="-1">安装 pnpm <a class="header-anchor" href="#安装-pnpm" aria-label="Permalink to &quot;安装 pnpm&quot;">​</a></h3><ul><li>需要<code>node@12.17.0</code>及以上</li><li>安装命令<code>npm i -g pnpm</code></li><li>安装完成后执行<code>pnpm -v</code>检验是否安装成功</li></ul><h3 id="常用命令" tabindex="-1">常用命令 <a class="header-anchor" href="#常用命令" aria-label="Permalink to &quot;常用命令&quot;">​</a></h3><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 安装依赖包</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pnpm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 安装 xxx</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pnpm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> xxx</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 安装 xxx 并将 xxx 添加至 devDependencies</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pnpm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> xxx</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -D</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 安装 xxx 并将 xxx 添加至 dependencies</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pnpm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> install</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> xxx</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -S</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 根据指定的范围将包更新到最新版本</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pnpm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> update</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 移除指定包</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pnpm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> uninstall</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> xxx</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 将本地项目连接到另一个项目。注意，使用的是硬链接，而不是软链接</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pnpm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> link</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">## 执行命令</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pnpm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> run</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> dev/prod</span></span></code></pre></div>`,65),e=[l];function h(t,o,k,d,r,c){return a(),i("div",null,e)}const m=s(p,[["render",h]]);export{g as __pageData,m as default};
