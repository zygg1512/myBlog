import{_ as a,c as e,o as r,a4 as i}from"./chunks/framework.BOW58p_D.js";const b=JSON.parse('{"title":"JavaScript 事件循环","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/V8引擎/V8原理/1. JavaScript事件循环.md","filePath":"blogs/V8引擎/V8原理/1. JavaScript事件循环.md"}'),t={name:"blogs/V8引擎/V8原理/1. JavaScript事件循环.md"},o=i('<h1 id="javascript-事件循环" tabindex="-1">JavaScript 事件循环 <a class="header-anchor" href="#javascript-事件循环" aria-label="Permalink to &quot;JavaScript 事件循环&quot;">​</a></h1><h2 id="javascript-为什么是单线程" tabindex="-1">JavaScript 为什么是单线程 <a class="header-anchor" href="#javascript-为什么是单线程" aria-label="Permalink to &quot;JavaScript 为什么是单线程&quot;">​</a></h2><p>JavaScript 作为浏览器脚本语言，他主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。</p><p>比如，假定 JavaScript 同时有两个线程，一个线程在某个 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器就很难判断应该以谁为准了。</p><h3 id="worker-线程有没有改变-javascript-是单线程" tabindex="-1">Worker 线程有没有改变 JavaScript 是单线程 <a class="header-anchor" href="#worker-线程有没有改变-javascript-是单线程" aria-label="Permalink to &quot;Worker 线程有没有改变 JavaScript 是单线程&quot;">​</a></h3><p>为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程是完全受主线程控制的，而且不得操作 DOM。</p><p>所以，这个标准并没有改变 JavaScript 是单线程的本质。</p><h2 id="浏览器包含哪些进程" tabindex="-1">浏览器包含哪些进程 <a class="header-anchor" href="#浏览器包含哪些进程" aria-label="Permalink to &quot;浏览器包含哪些进程&quot;">​</a></h2><p>Chrome使用多进程架构，每个进程独立运行，这有助于提高浏览器的稳定性和安全性。不同进程之间通过 IPC（进程间通信）进行数据交互和协调。</p><ul><li>Browser 进程：这是 Chrome 浏器览的主进程，负责管理和协调其他进程。它处理用户界面、安全验证、扩展和插件管理等任务。</li><li>Renderer 进程：每个标签页（标签）和独立的扩展程序都有一个独立的 Renderer 进程。Renderer 进程负责加载、显示网页内容、执行 JavaScript 代码和处理用户交互。</li><li>GPU 进程：GPU 进程负责处理图形渲染任务，以加速网页和图形的绘制。</li><li>Plugin 进程：当需要加载插件时，浏览器会创建一个独立的插件进程来处理。</li><li>Utility 进程：Utility 进程执行一些辅助任务，如网络代理、音频。</li><li>Network Service 进程：负责处理网络请求和数据传输等网络相关任务。</li></ul><h3 id="renderer-进程中的线程" tabindex="-1">Renderer 进程中的线程 <a class="header-anchor" href="#renderer-进程中的线程" aria-label="Permalink to &quot;Renderer 进程中的线程&quot;">​</a></h3><p>加载、显示网页内容以及执行 JavaScript 代码、处理用户交互等都在渲染进程内执行。而且渲染进程是多线程的。下面是渲染进程中一些较为常用线程。</p><h4 id="主线程-main-thread" tabindex="-1">主线程（Main thread） <a class="header-anchor" href="#主线程-main-thread" aria-label="Permalink to &quot;主线程（Main thread）&quot;">​</a></h4><p>主线程是浏览器中的核心线程。作用如下：</p><ul><li>负责创建并控制事件循环机制及任务队列。</li><li>负责处理用户界面的渲染和交互。如解析 HTML 和 CSS 的过程是由主线程负责的，主线程会构建 DOM 树和 CSSOM 树，并进行布局计算和生成绘制指令。</li><li>当遇到 JavaScript 脚本时，主线程会调用 JavaScript 引擎线程执行 JavaScript 脚本。</li><li>当遇到用户输入事件和界面渲染事件后，主线程会调用 GUI 线程执行。</li></ul><h4 id="gui-线程-graphical-user-interface-thread" tabindex="-1">GUI 线程（Graphical User Interface Thread） <a class="header-anchor" href="#gui-线程-graphical-user-interface-thread" aria-label="Permalink to &quot;GUI 线程（Graphical User Interface Thread）&quot;">​</a></h4><p>GUI 线程是主线程的一部分，它负责解析 HTML 和 CSS、构建 DOM 树和 CSSOM 树并进行布局计算和生成绘制指令和处理用户输入事件。</p><p><strong>为什么 GUI 线程与 JavaScript 引擎线程互斥？</strong></p><p>GUI 线程与 JavaScript 引擎线程是互斥的。当 JavaScript 引擎执行时，GUI 线程会被挂起。因为 JavaScript 是可以操作 DOM 的，如果修改元素属性的同时渲染界面（即 JavaScript 线程和 GUI 线程同时运行），那么前后获得的元素就可能不一致了。</p><p>例如浏览器渲染的时候遇到<code>&lt;script&gt;</code>标签，GUI线程 就会停止渲染，然后 JavaScript 引擎线程开始工作，执行里面的是 JavaScript 脚本。等 JavaScript 脚本执行完毕，JavaScript 引擎线程停止工作，GUI 线程继续渲染下面的内容。所以如果 JavaScript 脚本执行时间太长就会造成页面卡顿的情况。</p><h4 id="javascript-引擎线程-javascript-engine-thread" tabindex="-1">JavaScript 引擎线程（JavaScript Engine Thread） <a class="header-anchor" href="#javascript-引擎线程-javascript-engine-thread" aria-label="Permalink to &quot;JavaScript 引擎线程（JavaScript Engine Thread）&quot;">​</a></h4><p>JavaScript 引擎线程是浏览中器的一个独立线程，负责解析和执行 JavaScript 代码。它独立于主线程，在主线程的请求下执行 JavaScript 代码，并返回执行结果。</p><p>常见的 JavaScript 引擎有：</p><ul><li>V8引擎（用于Chrome浏览器）</li><li>SpiderMonkey引擎（用于Firefox浏览器）</li></ul><h4 id="事件线程-event-thread" tabindex="-1">事件线程（event thread） <a class="header-anchor" href="#事件线程-event-thread" aria-label="Permalink to &quot;事件线程（event thread）&quot;">​</a></h4><p>事件线程负责接收用户的输入事件（例如鼠标点击、键盘输入等）以及系统的通知事件（例如窗口大小化、定时器触发、网络请求返回等）。事件线程会将事件信息进行封装，并将回调任务添加到任务队列（也称为消息队列）中。</p><p>需要注意的是，事件线程主要是将事件放入任务队列中，但事件循环机制本身及任务队列是由主线程创建并控制的。事件线程将事件放入任务队列后，主线程会根据事件的优先级和顺序，从任务队列中取出事件并执行相应的操作。事件线程和主线程通过任务队列来传递任务。</p><h4 id="定时器线程-timer-thread" tabindex="-1">定时器线程（Timer thread） <a class="header-anchor" href="#定时器线程-timer-thread" aria-label="Permalink to &quot;定时器线程（Timer thread）&quot;">​</a></h4><p>当开发者在 JavaScript 代码中使用<code>setTimeout</code>或<code>setInterval</code>时，主线程会将定时器的相关信息（如回调函数、延迟时间等）传递给定时器线程。定时器线程负责管理所有的定时器。它会维护一个定时器队列，并按照定时器的触发时间进行排序。当定时器的触发时间到达时，定时器线程会将相应的定时器回调函数通过事件线程放入任务队列中。</p><p>需要注意的是，定时器任务的触发时间不是严格精确的，而是在指定的时间间隔到达后尽可能快地添加到任务队列中。这也意味着，当定时器任务的执行时间过长或在执行时发生阻塞，可能会导致后续定时器任务的触发延迟。</p><h4 id="异步-http-请求线程-asynchronous-http-request-thread" tabindex="-1">异步 HTTP 请求线程（Asynchronous HTTP Request Thread） <a class="header-anchor" href="#异步-http-请求线程-asynchronous-http-request-thread" aria-label="Permalink to &quot;异步 HTTP 请求线程（Asynchronous HTTP Request Thread）&quot;">​</a></h4><p>异步 HTTP 请求线程是指在进行网络请求时，为了避免阻塞主线程而单独开辟的线程，负责发送异步的网络请求。并在请求完成时通过事件线程将对应的回调函数放入任务队列中，供主线程处理。</p><p>在 Web 开发中，当需要发起网络请求（如 AJAX 请求）时，如果直接在主线程中执行网络请求，会导致主线程被阻塞，用户界面无响应，给用户产生不良体验。为了解决这个问题，一般会使用异步 HTTP，将网络请求和响应处理发到一个独立的线程中进行。这个独立的线程就是异步 HTTP 请求线程。</p><h4 id="工作线程-worker-thread" tabindex="-1">工作线程（Worker Thread） <a class="header-anchor" href="#工作线程-worker-thread" aria-label="Permalink to &quot;工作线程（Worker Thread）&quot;">​</a></h4><p>工作线程是一种特殊的线程，它可以在后台运行，独立于主线程。工作线程主要执行一些耗时的用于任务如，大量计算、文件操作、网络请求等，以避免阻塞主线程的执行。Web Worker 使用的就是工作线程。</p><h4 id="垃圾回收线程-garbage-collection-thread" tabindex="-1">垃圾回收线程（Garbage Collection Thread） <a class="header-anchor" href="#垃圾回收线程-garbage-collection-thread" aria-label="Permalink to &quot;垃圾回收线程（Garbage Collection Thread）&quot;">​</a></h4><p>负责回收不再使用的内存空间，以提高内存的利用效率。它会定期检查内存中的对象，并回收那些不再被引用的对象，释放内存资源。</p><h2 id="事件循环-event-loop" tabindex="-1">事件循环（Event Loop） <a class="header-anchor" href="#事件循环-event-loop" aria-label="Permalink to &quot;事件循环（Event Loop）&quot;">​</a></h2><p>是一种实现异步编程的机制。简单来说，事件循环机制用于处理浏览器中的各种事件，包括用户输入、计时器、网络请求等。在事件循环机制中，主线程会不断地从任务队列中取出任务并执行，直到队列为空。这种机制可以保证异步任务的有序执行，并避免页面阻塞。</p><h3 id="浏览器事件循环机制" tabindex="-1">浏览器事件循环机制 <a class="header-anchor" href="#浏览器事件循环机制" aria-label="Permalink to &quot;浏览器事件循环机制&quot;">​</a></h3><ol><li>主线程中会先执行同步任务（宏任务），并产生一个<code>执行栈</code>，用于存储执行上下文。如果是 JavaScript 脚本主线程会通知 JavaScript 引擎线程执行，如果是 DOM 任务主线程会交由 GUI 线程处理。</li><li>当遇到事件绑定和一些异步操作时主线程将对应的事件添加到对应线程中，等异步事件有了结果，对应线程便把他们的回调通过事件线程添加到<code>任务队列</code>。</li><li>所有同步任务（宏任务）执行完毕，主线程会轮询<code>任务队列</code>中是否有待执行的任务，如果有就会按顺序执行。</li><li>在每个同步任务（宏任务）执行结束前，会检查全局执行上下文中的<code>微任务队列</code>，然后按顺序执行<code>微任务队列</code>中的微任务。</li><li>当宏任务和微任务执行完毕，JavaScript 引擎线程退出，主线程开始检查渲染，然后 GUI 线程开始渲染页面。JS引擎线程和 GUI 线程是互斥的关系，浏览器为了能够使宏任务和DOM任务有序的进行，会在一个宏任务执行结果后，在下一个宏任务执行前，让 GUI 线程渲染页面。</li><li>渲染完毕后，JavaScript 引擎线程继续接管，开始下一个宏任务（从任务队列中获取）。</li></ol><h3 id="宏任务-macrotask" tabindex="-1">宏任务（macrotask） <a class="header-anchor" href="#宏任务-macrotask" aria-label="Permalink to &quot;宏任务（macrotask）&quot;">​</a></h3><p>在事件循环机制中，主线程不断地从任务队列中取出任务并执行任务。我们把这些在任务队列中的任务称为宏任务（macrotask）。</p><h4 id="常见的宏任务" tabindex="-1">常见的宏任务 <a class="header-anchor" href="#常见的宏任务" aria-label="Permalink to &quot;常见的宏任务&quot;">​</a></h4><ul><li>主代码块(<code>&lt;script&gt;</code>标签内的同步代码)</li><li><code>setTimeout</code>、<code>setInterval</code></li><li>Node API：<code>setImmediate</code></li><li>浏览器 API：<code>requestAnimationFrame</code></li><li>用户交互事件（如鼠标点击、滚动页面、放大缩小等）</li><li>网络请求完成的回调、文件读写完成的回调</li></ul><h3 id="微任务-microtask" tabindex="-1">微任务（microtask） <a class="header-anchor" href="#微任务-microtask" aria-label="Permalink to &quot;微任务（microtask）&quot;">​</a></h3><p>ES6新引入了 Promise 标准，同时浏览器实现上多了一个 microtask 微任务概念，在 ECMAScript 中，microtask 也被称为 jobs。</p><h4 id="常见微任务" tabindex="-1">常见微任务 <a class="header-anchor" href="#常见微任务" aria-label="Permalink to &quot;常见微任务&quot;">​</a></h4><ul><li>Node API：<code>process.nextTick</code></li><li><code>Promise.then</code></li><li><code>catch</code>、<code>finally</code></li><li><code>Object.observe</code></li><li><code>MutationObserver</code></li></ul><h4 id="微任务执行时机" tabindex="-1">微任务执行时机 <a class="header-anchor" href="#微任务执行时机" aria-label="Permalink to &quot;微任务执行时机&quot;">​</a></h4><p>V8 引擎每执行一个宏任务（JS 脚本）都会为其创建一个全局执行上下文，在创建全局执行上下文的同时，V8 引擎也会在全局执行上下文内部创建一个微任务队列。也就是说每个宏任务都关联了一个微任务队列（Jobs Queue）。</p><p>通常情况下，在当前宏任务中的 JavaScript 快执行完成时，也就在 V8 引擎准备退出全局执行上下文并清空调用栈的时候，V8 引擎会检查全局执行上下文中的微任务队列，然后按顺序执行队列中的微任务。也就是说在宏任务结束之前，会执行所有微任务，所以说微任务要早于宏任务。</p><p>WHATWG 把执行微任务的时间点称为<strong>检查点</strong>。</p><h4 id="微任务内执行微任务" tabindex="-1">微任务内执行微任务 <a class="header-anchor" href="#微任务内执行微任务" aria-label="Permalink to &quot;微任务内执行微任务&quot;">​</a></h4><p>如果在执行微任务的过程中，产生了新的微任务，同样会将该微任务添加到微任务队列中，V8 引擎一直循环执行微任务队列中的任务，直到队列为空才算执行结束。也就是说在执行微任务过程中产生新的微任务并不会推迟到下个宏任务中执行，而是在当前的宏任务中继续执行。</p><h4 id="微任务优势" tabindex="-1">微任务优势 <a class="header-anchor" href="#微任务优势" aria-label="Permalink to &quot;微任务优势&quot;">​</a></h4><p>因为宏任务需要先被放到任务队列中，如果某些宏任务的执行时间过久，那么就会影响到任务队列后面的宏任务的执行，而且这个影响是不可控的，因为无法知道前面的宏任务需要多久才能执行完成。所以为了解决效率和时效性问题引入了微任务。</p><h3 id="单任务队列的队头阻塞问题" tabindex="-1">单任务队列的队头阻塞问题 <a class="header-anchor" href="#单任务队列的队头阻塞问题" aria-label="Permalink to &quot;单任务队列的队头阻塞问题&quot;">​</a></h3><p>在单任务队列架构下，存在着低优先级任务会阻塞高优先级任务的情况。</p><p>比如用户发出一个点击事件或者缩放页面的事件，而在此时，该任务前面可能还有很多不太重要的任务在排队等待着被执行，诸如 V8 的垃圾回收、DOM 定时器等任务，如果执行这些任务需要花费的时间过久的话，那么就会让用户产生卡顿的感觉。</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/单任务队列的队头阻塞问题.webp" width="400px"><h4 id="chromium-是如何解决队头阻塞问题的" tabindex="-1">Chromium 是如何解决队头阻塞问题的？ <a class="header-anchor" href="#chromium-是如何解决队头阻塞问题的" aria-label="Permalink to &quot;Chromium 是如何解决队头阻塞问题的？&quot;">​</a></h4><p>通过给不同类型的任务创建不同的任务队列，并配合动态调度策略，基于不同场景动态调整各任务队列的执行优先级。</p><p>常用的任务队列如下：</p><ul><li>输入事件的任务队列：用来存放输入事件。</li><li>合成任务的任务队列：用来存放合成事件。</li><li>默认任务队列：用来保存如页面解析、资源加载、定时器回调、JavaScript 脚本执行等事件。</li><li>空闲任务队列：用来存放 V8 的垃圾自动垃圾回收这一类实时性不高的事件。</li></ul><p>动态策略如下：</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/任务队列的动态策略.webp" width="500px"><ul><li>页面加载阶段：用户的最高诉求是在尽可能短的时间内看到页面，至于交互和合成并不是这个阶段的核心诉求。因此在加载阶段将默认任务队列调整为优先级最高的队列，降低合成任务的任务队列的优先级。</li><li>交互阶段：当渲染进程接收到用户交互的任务后，接下来大概率是要进行绘制合成操作，因此在执行用户交互的任务时，将合成任务的任务队列的优先级调整到最高。</li><li>空闲阶段：处理完成 DOM，计算好布局和绘制，就需要将信息提交给合成线程来合成最终图片了，然后合成线程进入工作状态。那么就可以把下个合成任务的优先级调整为最低，并将默认任务队列优先级提升。从合成结束到下个 VSync 周期内，就进入了一个空闲时间阶段，那么就可以在这段空闲时间内执行一些不那么紧急的任务，比如 V8 的垃圾回收，或者通过<code>window.requestIdleCallback()</code>设置的回调任务等，都会在这段空闲时间内执行。</li></ul><h4 id="任务饿死" tabindex="-1">任务饿死 <a class="header-anchor" href="#任务饿死" aria-label="Permalink to &quot;任务饿死&quot;">​</a></h4><p>在某个状态下，一直有新的高优先级的任务加入到队列中，这样就会导致其他低优先级的任务得不到执行，这称为任务饿死。</p><p>Chromium 为了解决任务饿死的问题，给每个队列设置了执行权重，也就是如果连续执行了一定个数的高优先级的任务后中间会执行一次低优先级的任务，这样就缓解了任务饿死的情况。</p><h2 id="使用-settimeout-的一些注意事项" tabindex="-1">使用 setTimeout 的一些注意事项 <a class="header-anchor" href="#使用-settimeout-的一些注意事项" aria-label="Permalink to &quot;使用 setTimeout 的一些注意事项&quot;">​</a></h2><ol><li>如果当前任务执行时间过久，会影响定时器任务的执行</li><li>如果<code>setTimeout</code>存在嵌套调用，那么系统会设置最短时间间隔为 4 毫秒 <ul><li>在 Chrome 中，定时器被嵌套调用 5 次以上，系统会判断该函数方法被阻塞了，如果定时器的调用时间间隔小于 4 毫秒，那么浏览器会将每次调用的时间间隔设置为 4 毫秒。</li></ul></li><li>未激活的页面，<code>setTimeout</code>执行最小间隔是 1000 毫秒</li><li>延时执行时间有最大值 <ul><li>Chrome、Safari、Firefox 都是以 32 个 bit 来存储延时值的，32bit 最大只能存放的数字是 2147483647 毫秒，这就意味着，如果<code>setTimeout</code>设置的延迟值大于 2147483647 毫秒（大约 24.8 天）时就会溢出，那么相当于延时值被设置为 0 了，这导致定时器会被立即执行。</li></ul></li><li><code>setTimeout</code>中回调函数内的<code>this</code>指向全局</li></ol>',73),l=[o];function c(h,d,p,s,n,u){return r(),e("div",null,l)}const v=a(t,[["render",c]]);export{b as __pageData,v as default};
