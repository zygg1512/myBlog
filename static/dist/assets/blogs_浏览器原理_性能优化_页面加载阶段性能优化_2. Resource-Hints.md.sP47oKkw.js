import{_ as s,c as i,o as a,a4 as e}from"./chunks/framework.BOW58p_D.js";const E=JSON.parse('{"title":"Resource-Hints（资源提示）","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/浏览器原理/性能优化/页面加载阶段性能优化/2. Resource-Hints.md","filePath":"blogs/浏览器原理/性能优化/页面加载阶段性能优化/2. Resource-Hints.md"}'),n={name:"blogs/浏览器原理/性能优化/页面加载阶段性能优化/2. Resource-Hints.md"},t=e(`<h1 id="resource-hints-资源提示" tabindex="-1">Resource-Hints（资源提示） <a class="header-anchor" href="#resource-hints-资源提示" aria-label="Permalink to &quot;Resource-Hints（资源提示）&quot;">​</a></h1><p>Resource-Hints（资源提示）是辅助浏览器进行资源优化的指令。它包含如下指令</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># PreLoad</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Prefetch</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># DNS prefetch</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Preconnect</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># Prerender</span></span></code></pre></div><p>除了介绍这些之外还会说一下 crossorigin 属性的作用</p><h2 id="preload-预加载" tabindex="-1">PreLoad 预加载 <a class="header-anchor" href="#preload-预加载" aria-label="Permalink to &quot;PreLoad 预加载&quot;">​</a></h2><p>让浏览器提前加载指定资源(加载后并不执行)，在需要执行的时候再执行，这样做的好处是</p><ul><li>将加载和执行分离开，可不阻塞渲染和 document 的 onload 事件</li><li>提前加载指定资源，不再出现依赖的font字体隔了一段时间才刷出</li></ul><p>因为 PreLoad 在浏览器的主渲染机制介入前就进行预加载。这一机制使得资源可以更早的得到加载并可用，且更不易阻塞页面的初步渲染，进而提升性能。</p><p>简单点说就是 告诉浏览器页面<strong>必定</strong>需要的资源，浏览器<strong>一定会</strong>加载这些资源</p><h3 id="如何使用" tabindex="-1">如何使用 <a class="header-anchor" href="#如何使用" aria-label="Permalink to &quot;如何使用&quot;">​</a></h3><h4 id="link-标签创建" tabindex="-1">link 标签创建 <a class="header-anchor" href="#link-标签创建" aria-label="Permalink to &quot;link 标签创建&quot;">​</a></h4><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 使用 link 标签静态标记需要预加载的资源 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;preload&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/path/to/style.css&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> as</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;style&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">&lt;!-- 或使用脚本动态创建一个 link 标签后插入到 head 头部 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  const link = document.createElement(&#39;link&#39;);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  link.rel = &#39;preload&#39;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  link.as = &#39;style&#39;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  link.href = &#39;/path/to/style.css&#39;;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  document.head.appendChild(link);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h4 id="使用-http-响应头的-link-字段创建" tabindex="-1">使用 HTTP 响应头的 Link 字段创建 <a class="header-anchor" href="#使用-http-响应头的-link-字段创建" aria-label="Permalink to &quot;使用 HTTP 响应头的 Link 字段创建&quot;">​</a></h4><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Link:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &lt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">https://example.com/other/styles.cs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">s</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; rel</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">preload</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; as</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">style</span></span></code></pre></div><h3 id="如何判断浏览器是否支持-preload" tabindex="-1">如何判断浏览器是否支持 preload <a class="header-anchor" href="#如何判断浏览器是否支持-preload" aria-label="Permalink to &quot;如何判断浏览器是否支持 preload&quot;">​</a></h3><p>在不支持 preload 的浏览器环境中，会忽略对应的 link 标签，而若需要做特征检测的话，则：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> isPreloadSupported</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> link</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;link&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> relList</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> link.relList;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">relList </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">relList.supports) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> relList.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">supports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;preload&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span></code></pre></div><h3 id="preload-加载跨域资源" tabindex="-1">preload 加载跨域资源 <a class="header-anchor" href="#preload-加载跨域资源" aria-label="Permalink to &quot;preload 加载跨域资源&quot;">​</a></h3><p>在使用 preload 预加载 font 文件时，若不指定 crossorigin 属性，即使同源也会采用匿名模式的 CORS 去加载（即请求头中没有 origin 字段）。这样当使用到 font 文件时会再次请求，而不是使用预加载的 font 文件。</p><h4 id="preload-的缓存" tabindex="-1">preload 的缓存 <a class="header-anchor" href="#preload-的缓存" aria-label="Permalink to &quot;preload 的缓存&quot;">​</a></h4><p>关于preload和prefetch资源的缓存，在Google开发者的一篇文章中是这样说明的：</p><ul><li>如果资源可以被缓存（比如说存在有效的cache-control和max-age），它被存储在HTTP缓存（也就是disk cache)中，可以被现在或将来的任务使用；</li><li>如果资源不能被缓存在HTTP缓存中，作为代替，它被放在 memory cache 中直到被使用。这里的不能被缓存指的是类似于<code>max-age=0</code>这样的属性设置，而非<code>no-store</code></li></ul><h2 id="prefetch-预提取" tabindex="-1">Prefetch 预提取 <a class="header-anchor" href="#prefetch-预提取" aria-label="Permalink to &quot;Prefetch 预提取&quot;">​</a></h2><p>告诉浏览器未来可能会使用到的某个资源，浏览器就会在闲时去加载对应的资源。</p><p>若能预测到用户的行为，比如懒加载、点击到其它页面等；则相当于提前预加载了需要的资源。Prefetch 的资源在 network 中有一个特殊的标记（<code>prefetch cache</code>）</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;prefetch&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;image.png&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p><strong>preload 和 prefetch 混用的话，并不会复用资源，而是会重复加载。preload 和prefetch 都不会阻塞页面的onload</strong></p><h3 id="这种加载方式会浪费用户的带宽吗" tabindex="-1">这种加载方式会浪费用户的带宽吗 <a class="header-anchor" href="#这种加载方式会浪费用户的带宽吗" aria-label="Permalink to &quot;这种加载方式会浪费用户的带宽吗&quot;">​</a></h3><p>使用 preload 或 prefetch，可能会浪费用户的带宽，特别是在资源没有缓存的情况下。</p><p>没有用到的 preload 资源在 Chrome 的 console 里会在 onload 事件 3s 后发生警告。</p><p>原因是，你可能正在使用preload来尝试预加载并缓存其他资源以提高性能，但是如果这些预加载的资源没有被使用，那么你就在毫无理由地做额外的工作。在移动设备上，这相当于浪费用户的流量，所以要注意预加载的内容。</p><h2 id="dns-prefetch-dns-预解析" tabindex="-1">DNS prefetch DNS 预解析 <a class="header-anchor" href="#dns-prefetch-dns-预解析" aria-label="Permalink to &quot;DNS prefetch DNS 预解析&quot;">​</a></h2><p>DNS prefetching 通过指定具体的 URL 来告知客户端未来会用到的相关资源，这样浏览器可以尽早的解析 DNS。也就是说当请求这个域名下的文件时就不需要等待 DNS 查询了</p><p>比如我们需要一个在 example.com 的图片或者视频文件。在<code>&lt;head&gt; </code>就可以这么写：</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dns-prefetch&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;//example.com&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>简单的一行就能让支持的浏览器提前解析 DNS。也就是说在浏览器请求资源时，DNS 查询就已经准备好了。</p><h3 id="用处" tabindex="-1">用处 <a class="header-anchor" href="#用处" aria-label="Permalink to &quot;用处&quot;">​</a></h3><p>项目中有用到第三方的代码时这么做尤其有益，比如：</p><ul><li>当静态资源和 HTML 不在一个域上，而在 CDN 上</li><li>在重定向前可以加上 DNS prefetch</li></ul><h2 id="preconnect" tabindex="-1">Preconnect <a class="header-anchor" href="#preconnect" aria-label="Permalink to &quot;Preconnect&quot;">​</a></h2><p>和 DNS prefetch 类似，preconnect 不光会解析 DNS，还会建立 TCP 握手连接和 TLS 协议（如果需要）。用法如下：</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;preconnect&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;http://css-tricks.com&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h2 id="prerender" tabindex="-1">Prerender <a class="header-anchor" href="#prerender" aria-label="Permalink to &quot;Prerender&quot;">​</a></h2><p>prerender 是一个重量级的选项，它可以让浏览器提前加载指定页面的所有资源。</p><div class="language-xml vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">xml</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;prerender&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/thenextpage.html&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span></code></pre></div><p>prerender 就像是在后台打开了一个隐藏的 tab，会下载所有的资源、创建 DOM、渲染页面、执行 JS 等等。如果用户进入指定的链接，隐藏的这个页面就会进入马上进入用户的视线。但是要注意，一定要在十分确定用户会点某个链接时才用这个特性，否则客户端就会无端的下载很多资源和渲染这个页面。</p><h2 id="html-里面的-crossorigin-属性" tabindex="-1">HTML 里面的 crossorigin 属性 <a class="header-anchor" href="#html-里面的-crossorigin-属性" aria-label="Permalink to &quot;HTML 里面的 crossorigin 属性&quot;">​</a></h2><p>html中拥有 crossorigin 属性的元素有：<code>script</code>，<code>link</code>，<code>img</code>。作用是在加载相关资源时是否必须使用 CORS</p><div class="language-bash vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">bash</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"># crossorigin 属性</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">-</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> anonymous、没有属性值、空属性值:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 如果使用这个值的话就会在请求中的header中的带上Origin属性，但请求不会带上cookie和其他的一些认证信息。</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">-</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> use-credentials:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> 这个会在跨域请求中带上cookie和其他的一些认证信息。</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">上面都需要设置</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> Access-Control-Allow-Origin，如果不设置资源会被限制使用</span></span></code></pre></div><h3 id="script-中-crossorigin-属性作用" tabindex="-1">script 中 crossorigin 属性作用 <a class="header-anchor" href="#script-中-crossorigin-属性作用" aria-label="Permalink to &quot;script 中 crossorigin 属性作用&quot;">​</a></h3><p>当引入跨域的脚本时，如果这个脚本<strong>有错误</strong>，因为浏览器的限制，是<strong>拿不到错误信息的</strong>。当本地尝试使用 <code>window.onerror</code> 去记录脚本的错误时，<strong>跨域脚本的错误只会返回 <code>Script error</code></strong></p><p>而 HTML5 新的规定，是可以允许本地获取到跨域脚本的错误信息的，但有两个条件：</p><ul><li><p>一是跨域脚本的服务器必须通过 <code>Access-Control-Allow-Origin</code> 头信息允许当前域名可以获取错误信息</p></li><li><p>二是网页里的 <code>script</code> 标签也必须指明 <code>src</code> 属性指定的地址是支持跨域的地址，也就是 <code>crossorigin</code> 属性</p></li></ul><p>有了这两个条件，就可以获取跨域脚本的错误信息</p><h3 id="img、link-中-crossorigin-属性作用" tabindex="-1">img、link 中 crossorigin 属性作用 <a class="header-anchor" href="#img、link-中-crossorigin-属性作用" aria-label="Permalink to &quot;img、link 中 crossorigin 属性作用&quot;">​</a></h3><p>img、link添加 crossorigin 属性后，canvas 不仅可以读取另外一个域名下的图片资源的数据，还能对其做操作，就跟操作同个域名下的图片一样了。</p><p>未添加时， canvas 只能按 tainted 方式读取非同域名下的图片资源。</p><p>『taint』就是上色，贴膜的意思，比如给汽车车窗贴膜。我理解浏览器里的『贴膜』方式，应该是指只能将图片贴在 canvas 上，但不能将图片作为数据读出来，从而防止某些隐私信息随着图片传到别的地方。</p>`,58),l=[t];function h(p,r,k,o,d,c){return a(),i("div",null,l)}const y=s(n,[["render",h]]);export{E as __pageData,y as default};
