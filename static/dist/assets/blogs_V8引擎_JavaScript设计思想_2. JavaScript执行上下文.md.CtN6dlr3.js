import{_ as s,c as i,o as a,a4 as n}from"./chunks/framework.BOW58p_D.js";const g=JSON.parse('{"title":"JavaScript执行上下文","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/V8引擎/JavaScript设计思想/2. JavaScript执行上下文.md","filePath":"blogs/V8引擎/JavaScript设计思想/2. JavaScript执行上下文.md"}'),h={name:"blogs/V8引擎/JavaScript设计思想/2. JavaScript执行上下文.md"},l=n(`<h1 id="javascript执行上下文" tabindex="-1">JavaScript执行上下文 <a class="header-anchor" href="#javascript执行上下文" aria-label="Permalink to &quot;JavaScript执行上下文&quot;">​</a></h1><p>执行上下文是 JavaScript 执行一段代码时的运行环境，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如<code>this</code>、变量、对象以及函数等。</p><p>JavaScript执行上下文主要包含4部分：</p><ul><li>变量环境</li><li>词法环境</li><li>外部环境（存放在变量环境中）</li><li>this</li></ul><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/执行上下文总览.png" height="300px"><h2 id="什么时候会创建执行上下文" tabindex="-1">什么时候会创建执行上下文 <a class="header-anchor" href="#什么时候会创建执行上下文" aria-label="Permalink to &quot;什么时候会创建执行上下文&quot;">​</a></h2><ul><li>全局执行上下文：当 JavaScript 执行全局代码的时候，会编译全局代码并创建全局执行上下文，而且在整个页面的生存周期内，全局执行上下文只有一份。</li><li>函数执行上下文：当调用一个函数的时候，函数体内的代码会被编译，并创建函数执行上下文，一般情况下，函数执行结束之后，创建的函数执行上下文会被销毁。</li><li>eval执行上下文：当使用 eval 函数的时候，eval 的代码也会被编译，并创建执行上下文。</li></ul><h3 id="全局执行上线文特点" tabindex="-1">全局执行上线文特点 <a class="header-anchor" href="#全局执行上线文特点" aria-label="Permalink to &quot;全局执行上线文特点&quot;">​</a></h3><p>全局执行上下文存储在堆中。</p><p>在V8引擎中，全局执行上下文是一个特殊的执行上下文，用于存储全局作用域中的变量和函数。与函数执行上下文不同，全局执行上下文不会存储在栈中，而是存储在堆中。</p><p>堆是一块用于动态分配内存的区域，用于存储对象和数据结构。全局执行上下文被视为一个特殊的对象，它包含了全局作用域中的变量和函数，并且在整个 V8 的生命周期中都存在。</p><p>当程序启动时，V8引擎会为全局执行上下文分配内存，并将全局变量和函数添加到该执行上下文中。这些全局变量和函数的值会一直保存在堆中，直到程序结束。</p><p>因此，全局执行上下文存储在堆中，而不是存储在栈中。</p><h2 id="基于变量环境的变量提升" tabindex="-1">基于变量环境的变量提升 <a class="header-anchor" href="#基于变量环境的变量提升" aria-label="Permalink to &quot;基于变量环境的变量提升&quot;">​</a></h2><p>所谓的变量提升，是指在 JavaScript 代码执行过程中，V8 引擎把通过<code>var</code>关键字声明的变量的声明部分和函数的声明部分提升到代码开头的“行为”。</p><p><code>var</code>声明的变量被提升后，会给变量设置默认值，这个默认值就是<code>undefined</code>。</p><h3 id="javascript-代码的执行流程" tabindex="-1">JavaScript 代码的执行流程 <a class="header-anchor" href="#javascript-代码的执行流程" aria-label="Permalink to &quot;JavaScript 代码的执行流程&quot;">​</a></h3><p>JavaScript 的执行机制：先编译，再执行。</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/JavaScript代码的执行流程.webp" width="600px"><p>下面是一段 JavaScript 代码的执行流程</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/JavaScript代码的执行流程示例.webp" height="400px"><p>从上图可以看出，JavaScript 代码执行过程如下：</p><ol><li>JavaScript 代码执行过程中，需要先做变量提升，而之所以需要实现变量提升，是因为 JavaScript 代码在执行之前需要先编译。</li><li>在编译阶段，代码被编译后，会生成两部分内容：<strong>执行上下文（Execution context）<strong>和</strong>可执行代码</strong>。变量和函数会被存放到变量环境中，变量的默认值会被设置为<code>undefined</code>。 <ol><li>在执行上下文中存在一个<strong>变量环境的对象（Viriable Environment）</strong>，该对象中保存了变量提升的内容，比如上面代码中的变量<code>myname</code>和函数<code>showName</code>，都保存在该对象中。</li></ol></li><li>生成了变量环境对象后。接下来 V8 引擎会把声明以外的代码编译为字节码。然后就是执行阶段。</li><li>在代码执行阶段，V8 引擎会从变量环境中去查找自定义的变量和函数。如果在编译阶段存在两个相同的函数，那么最终存放在变量环境中的是最后定义的那个，这是因为后定义的会覆盖掉之前定义的。</li></ol><h4 id="变量环境对象是如何生成的" tabindex="-1">变量环境对象是如何生成的？ <a class="header-anchor" href="#变量环境对象是如何生成的" aria-label="Permalink to &quot;变量环境对象是如何生成的？&quot;">​</a></h4><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">showName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myname)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myname </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;极客时间&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> showName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;函数showName被执行&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>一行一行来分析上述代码：</p><ul><li>第 1 行和第 2 行，由于这两行代码不是声明操作，所以 V8 引擎不会做任何处理；</li><li>第 3 行，由于这行是经过<code>var</code>声明的，因此 V8 引擎将在环境对象中创建一个名为<code>myname</code>的属性，并使用<code>undefined</code>对其初始化；</li><li>第 4 行，V8 引擎发现了一个通过<code>function</code>定义的函数，所以它将函数定义存储到堆（HEAP）中，并在环境对象中创建一个<code>showName</code>的属性，然后将该属性值指向堆中函数的位置</li></ul><h4 id="调用栈" tabindex="-1">调用栈 <a class="header-anchor" href="#调用栈" aria-label="Permalink to &quot;调用栈&quot;">​</a></h4><p>调用栈就是用来管理栈帧的。符合后进先出的规则。</p><p>每个函数在执行时会创建一个栈帧。栈帧（stack frame）是用来存储函数调用相关信息的数据结构，包括函数的参数、局部变量、临时变量等。本质上栈帧和函数执行上下文是同一概念。</p><p>在栈帧创建好后，V8 引擎会将栈帧压入栈中，通常把这种用来管理栈帧（执行上下文）的栈称为<strong>执行上下文栈</strong>，又称<strong>调用栈</strong>。</p><h4 id="变量提升的缺陷" tabindex="-1">变量提升的缺陷 <a class="header-anchor" href="#变量提升的缺陷" aria-label="Permalink to &quot;变量提升的缺陷&quot;">​</a></h4><p><strong>变量容易被覆盖掉</strong></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myname </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;极客时间&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> showName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myname);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">   var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myname </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;极客邦&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myname);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">showName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>执行上面这段代码，打印出来的是<code>undefined</code>，在执行<code>showName</code>函数的时候由于变量提升导致<code>myname</code>的变量值不是全局变量中的<code>myname</code>，而是函数内的<code>myname</code>变量。</p><p><strong>本应销毁的变量没有被销毁</strong></p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(i); </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>执行上面这段代码后，变量<code>i</code>的值并未被销毁，所以最后打印出来的是 7。这同样也是由变量提升而导致的，在创建执行上下文阶段，变量<code>i</code>就已经被提升了，所以当<code>for</code>循环结束之后，变量<code>i</code>并没有被销毁。</p><h2 id="基于词法环境的块级作用域" tabindex="-1">基于词法环境的块级作用域 <a class="header-anchor" href="#基于词法环境的块级作用域" aria-label="Permalink to &quot;基于词法环境的块级作用域&quot;">​</a></h2><p>为了解决变量提升的这些问题，ES6 引入了<code>let</code>和<code>const</code>关键字，并引入了块级作用域。</p><ul><li><code>var</code>的创建和初始化被提升，赋值不会被提升。</li><li><code>let</code>、<code>const</code>的创建被提升，初始化和赋值不会被提升。 <ul><li>在块作用域内，<code>let</code>、<code>const</code>声明的变量被提升，但变量只是创建被提升，初始化并没有被提升，在初始化之前使用变量，就会形成一个暂时性死区。</li></ul></li><li><code>function</code>的创建、初始化和赋值均会被提升。</li></ul><h3 id="javascript-是如何支持块级作用域的" tabindex="-1">JavaScript 是如何支持块级作用域的 <a class="header-anchor" href="#javascript-是如何支持块级作用域的" aria-label="Permalink to &quot;JavaScript 是如何支持块级作用域的&quot;">​</a></h3><blockquote><p>ES6 是如何做到既要支持<code>var</code>的变量提升的特性，又要支持<code>let</code>、<code>const</code>的块级作用域的呢？</p></blockquote><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(b) </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(c)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(d)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}   </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>接下来一步步分析上面这段代码的执行流程。</p><p><strong>第一步是编译并创建<code>foo</code>函数的执行上下文。</strong></p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/词法环境.webp" height="300px"><p>通过上图，可以得出以下结论：</p><ul><li>函数内部通过<code>var</code>声明的变量，在编译阶段全都被存放到<strong>变量环境</strong>里面了。</li><li>通过<code>let</code>、<code>const</code>声明的变量，在编译阶段会被存放到<strong>词法环境（Lexical Environment）</strong> 中。</li></ul><p><strong>第二步继续执行代码</strong>，当执行到块级作用域里面时，变量环境中<code>a</code>的值已经被设置成了 1，词法环境中<code>b</code>的值已经被设置成了 2，这时候函数的执行上下文就如下图所示：</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/词法环境2.webp" height="300px"><p>从图中可以看出，当进入函数的作用域块时，作用域块中通过<code>let</code>声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量，比如在作用域外面声明了变量 <code>b</code>，在该作用域块内部也声明了变量<code>b</code>，当执行到作用域内部时，它们都是独立的存在。</p><p>其实，在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。</p><p>再接下来，当执行到作用域块中的<code>console.log(a)</code>这行代码时，就需要在词法环境和变量环境中查找变量<code>a</code>的值了。</p><p>具体查找方式是：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 V8 引擎，如果没有查找到，那么继续在变量环境中查找。</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/变量查找顺序.webp" height="300px"><p>从上图可以清晰地看出变量在一个执行上下文中的查找流程。当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出，最终执行上下文如下图所示：</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/词法环境3.webp" height="300px"><p>通过上面的分析，已经理解了词法环境的结构和工作机制：</p><ul><li>块级作用域就是通过词法环境的栈结构来实现的。</li><li>而变量提升是通过变量环境来实现。</li></ul><p>通过这两者的结合，V8 引擎也就同时支持了变量提升和块级作用域了。</p><h2 id="基于外部环境的作用域链" tabindex="-1">基于外部环境的作用域链 <a class="header-anchor" href="#基于外部环境的作用域链" aria-label="Permalink to &quot;基于外部环境的作用域链&quot;">​</a></h2><h3 id="作用域链是什么" tabindex="-1">作用域链是什么 <a class="header-anchor" href="#作用域链是什么" aria-label="Permalink to &quot;作用域链是什么&quot;">​</a></h3><p>当在 JavaScript 中使用一个变量的时候，首先 V8 引擎会尝试在当前词法作用域下去寻找该变量，如果没找到，再到它的上层词法作用域寻找，以此类推直到找到该变量或是已经到了全局作用域。</p><p>如果在全局作用域里仍然找不到该变量，它就会在全局范围内隐式声明该变量(非严格模式下)或是直接报错。</p><h4 id="词法作用域" tabindex="-1">词法作用域 <a class="header-anchor" href="#词法作用域" aria-label="Permalink to &quot;词法作用域&quot;">​</a></h4><p>词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找变量。</p><p>也就是说词法作用域是代码编译阶段就决定好的，和函数是怎么调用的没有关系。</p><h3 id="作用域链存储方式" tabindex="-1">作用域链存储方式 <a class="header-anchor" href="#作用域链存储方式" aria-label="Permalink to &quot;作用域链存储方式&quot;">​</a></h3><p><strong>每个执行上下文的变量环境中，都包含了一个外部引用</strong>，用来指向外部的执行上下文，我们把这个外部引用称为<code>outer</code>或<code>[[Scopes]]</code>。</p><p>当一段代码使用了一个变量时，JavaScript 引擎首先会在“当前的执行上下文”中查找该变量，如果没有查找到，那么 V8 引擎会继续在<code>outer</code>所指向的执行上下文中查找。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myName)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;极客邦&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;极客时间&quot;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>上述代码的作用域链如下所示：</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/调用栈.webp" height="400px"><h3 id="闭包" tabindex="-1">闭包 <a class="header-anchor" href="#闭包" aria-label="Permalink to &quot;闭包&quot;">​</a></h3><p>在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包（closure）。闭包是为了解决子函数晚于父函数销毁的问题。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;极客时间&quot;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> test1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> test2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> innerBar </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(test1)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myName</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        setName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            myName </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newName</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> innerBar</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bar </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bar.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;极客邦&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">bar.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(bar.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span></code></pre></div><p>当上述代码执行到<code>bar.setName</code>方法中的<code>myName = &quot;极客邦&quot;</code>这句代码时，JavaScript 引擎会沿着“当前执行上下文–&gt;foo 函数闭包–&gt; 全局执行上下文”的顺序来查找 myName 变量</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/闭包.webp" height="400px"><h4 id="闭包原理" tabindex="-1">闭包原理 <a class="header-anchor" href="#闭包原理" aria-label="Permalink to &quot;闭包原理&quot;">​</a></h4><p>在父函数执行过程中，会预解析子函数内容。如果在子函数中用到了在父函数中定义的变量，会在父函数销毁时把子函数引用到的变量打成 Closure 包存储在堆中，并将子函数<code>[[Scopes]]</code>属性指向 Closure 包</p><h4 id="eval-的闭包" tabindex="-1">eval 的闭包 <a class="header-anchor" href="#eval-的闭包" aria-label="Permalink to &quot;eval 的闭包&quot;">​</a></h4><p>通过上面闭包原理我们知道，闭包的形成依赖预解析子函数内容，但<code>eval</code>的内容来源可能是网络文件、磁盘读取等，内容是动态的，无法做预解析。所以<code>eval</code>会直接将整个作用域打包成 Closure。所以尽量不要用<code>eval</code>。会导致闭包保存内容过多。</p><p>但是 V8 引擎只处理了直接调用，也就是说直接调用<code>eval</code>才会打包整个作用域，如果不直接调用<code>eval</code>，就没法分析引用，也就没法形成闭包了。比如下面的代码</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;g1&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;g2&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> c</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;g3&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ee</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> eval</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;test1&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;test2&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> c</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;test3&#39;</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        ee</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;console.log(a, b, c)&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> test</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()() </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// g1 g2 g3</span></span></code></pre></div><p>此时<code>eval</code>的父级作用域是全局作用域。</p><h4 id="闭包是怎么回收的" tabindex="-1">闭包是怎么回收的 <a class="header-anchor" href="#闭包是怎么回收的" aria-label="Permalink to &quot;闭包是怎么回收的&quot;">​</a></h4><p>如果闭包使用不正确，会很容易造成内存泄漏。</p><p>通常，如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。</p><p>如果引用闭包的函数是个局部变量，等函数销毁后，在下次 V8 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 V8 引擎的垃圾回收器就会回收这块内存。</p><p>所以在使用闭包的时候，要尽量注意一个原则：<strong>如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。</strong></p><h2 id="this" tabindex="-1">this <a class="header-anchor" href="#this" aria-label="Permalink to &quot;this&quot;">​</a></h2><p>关于<code>this</code>，还是得先从执行上下文说起。在前几节中，我们提到执行上下文中包含了<strong>变量环境</strong>、<strong>词法环境</strong>、<strong>外部环境</strong>，但其实还有一个<code>this</code>没有提及。</p><p>this 是和执行上下文绑定的，也就是说每个执行上下文中都有一个 this。</p><h3 id="this-的类型" tabindex="-1">this 的类型 <a class="header-anchor" href="#this-的类型" aria-label="Permalink to &quot;this 的类型&quot;">​</a></h3><p>执行上下文主要分为三种——全局执行上下文、函数执行上下文和 eval 执行上下文，所以对应的 this 也只有这三种——全局执行上下文中的 this、函数中的 this 和 eval 中的 this。</p><h3 id="this-的缺陷和应对方案" tabindex="-1">this 的缺陷和应对方案 <a class="header-anchor" href="#this-的缺陷和应对方案" aria-label="Permalink to &quot;this 的缺陷和应对方案&quot;">​</a></h3><h4 id="嵌套函数中的-this-不会从外层函数中继承" tabindex="-1">嵌套函数中的 this 不会从外层函数中继承 <a class="header-anchor" href="#嵌套函数中的-this-不会从外层函数中继承" aria-label="Permalink to &quot;嵌套函数中的 this 不会从外层函数中继承&quot;">​</a></h4><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> myObj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  name : </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;极客时间&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  showThis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">myObj.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">showThis</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>上述代码中<code>bar</code>函数的<code>this</code>指向全局对象，解决方式如下：</p><ul><li>第一种是把 this 保存为一个 self 变量，再利用变量的作用域机制传递给嵌套函数。</li><li>第二种是继续使用 this，但是要把嵌套函数改为箭头函数，因为箭头函数没有自己的执行上下文，所以它会继承调用函数中的 this。</li></ul><h4 id="普通函数中的-this-默认指向全局对象-window" tabindex="-1">普通函数中的 this 默认指向全局对象 window <a class="header-anchor" href="#普通函数中的-this-默认指向全局对象-window" aria-label="Permalink to &quot;普通函数中的 this 默认指向全局对象 window&quot;">​</a></h4><p>默认情况下调用一个函数，其执行上下文中的 this 是默认指向全局对象 window 的。解决方式如下：</p><ul><li>通过<code>call</code>、<code>bind</code>、<code>apply</code>方法调用函数</li></ul>`,104),t=[l];function p(e,k,r,d,o,E){return a(),i("div",null,t)}const y=s(h,[["render",p]]);export{g as __pageData,y as default};
