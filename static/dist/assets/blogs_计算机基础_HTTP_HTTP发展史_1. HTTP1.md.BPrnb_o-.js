import{_ as a,c as t,o as e,a4 as h}from"./chunks/framework.BOW58p_D.js";const H=JSON.parse('{"title":"HTTP/1","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/计算机基础/HTTP/HTTP发展史/1. HTTP1.md","filePath":"blogs/计算机基础/HTTP/HTTP发展史/1. HTTP1.md"}'),T={name:"blogs/计算机基础/HTTP/HTTP发展史/1. HTTP1.md"},r=h('<h1 id="http-1" tabindex="-1">HTTP/1 <a class="header-anchor" href="#http-1" aria-label="Permalink to &quot;HTTP/1&quot;">​</a></h1><h2 id="超文本传输协议-http-0-9" tabindex="-1">超文本传输协议 HTTP/0.9 <a class="header-anchor" href="#超文本传输协议-http-0-9" aria-label="Permalink to &quot;超文本传输协议 HTTP/0.9&quot;">​</a></h2><p>HTTP/0.9诞生的原因比较简单，用来传输体积很小的 HTML 文件，所以被称为超文本传输协议。</p><h3 id="http-0-9传输流程" tabindex="-1">HTTP/0.9传输流程 <a class="header-anchor" href="#http-0-9传输流程" aria-label="Permalink to &quot;HTTP/0.9传输流程&quot;">​</a></h3><p>完整的请求流程如下：</p><ul><li>客户端先根据 IP 地址、端口和服务器建立 TCP 连接</li><li>建立好连接之后，会发送一个 GET 请求行的信息，如GET /index.html用来获取 index.html</li><li>服务器接收请求信息之后，读取对应的 HTML 文件，并将<strong>数据以 ASCII 字符流返回给客户端</strong></li><li>HTML 文档传输完成后，断开连接</li></ul><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/http/http发展史/http09.webp" width="600px"><h3 id="http-0-9特点" tabindex="-1">HTTP/0.9特点 <a class="header-anchor" href="#http-0-9特点" aria-label="Permalink to &quot;HTTP/0.9特点&quot;">​</a></h3><ul><li>只有一个请求行，并没有 HTTP 请求头和请求体，因为只需要一个请求行就可以完整表达客户端的需求了</li><li>服务器也没有返回头信息，这是因为服务器端并不需要告诉客户端太多信息，只需要返回数据就可以了</li><li>返回的文件内容是以 ASCII 字符流来传输的，因为都是 HTML 格式的文件，所以使用 ASCII 字节码来传输是最合适的</li></ul><h3 id="http-0-9缺陷" tabindex="-1">HTTP/0.9缺陷 <a class="header-anchor" href="#http-0-9缺陷" aria-label="Permalink to &quot;HTTP/0.9缺陷&quot;">​</a></h3><p>首先在浏览器中展示的不单是 HTML 文件了，还包括了 JavaScript、CSS、图片、音频、视频等不同类型的文件。</p><p>因此支持多种类型的文件下载是一个核心诉求，而且文件格式不仅仅局限于 ASCII 编码，还有很多其他类型编码的文件。</p><h2 id="被浏览器推动的-http-1-0" tabindex="-1">被浏览器推动的 HTTP/1.0 <a class="header-anchor" href="#被浏览器推动的-http-1-0" aria-label="Permalink to &quot;被浏览器推动的 HTTP/1.0&quot;">​</a></h2><p>HTTP/0.9这种简单的交流型形式无疑不能满足传输多种类型文件的需求，那为了让客户端和服务器能更深入地交流，HTTP/1.0 引入了请求头和响应头，它们都是以为 Key-Value 形式保存的，在 HTTP 发送请求时，会带上请求头信息，服务器返回数据时，会先返回响应头信息。至于 HTTP/1.0 具体的请求流程，可以参考下图。</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/http/http发展史/http10.webp" width="600px"><h3 id="http-1-0特点" tabindex="-1">HTTP/1.0特点 <a class="header-anchor" href="#http-1-0特点" aria-label="Permalink to &quot;HTTP/1.0特点&quot;">​</a></h3><p>HTTP/1.0的特性都是通过请求头和响应头来实现的</p><ul><li>不同文件类型、编码、压缩方式、语言类型等</li><li>引入了状态码</li><li>提供了<strong>Cache 机制</strong></li><li>请求头中加入了客户端信息</li></ul><h3 id="http-1-0缺陷" tabindex="-1">HTTP/1.0缺陷 <a class="header-anchor" href="#http-1-0缺陷" aria-label="Permalink to &quot;HTTP/1.0缺陷&quot;">​</a></h3><h4 id="连接不能持久化" tabindex="-1">连接不能持久化 <a class="header-anchor" href="#连接不能持久化" aria-label="Permalink to &quot;连接不能持久化&quot;">​</a></h4><p>HTTP/1.0 每进行一次 HTTP 通信，都需要经历建立 TCP 连接、传输 HTTP 数据和断开 TCP 连接三个阶段;但是随着浏览器普及，单个页面中的图片文件越来越多，有时候一个页面可能包含了几百个外部引用的资源文件，如果在下载每个文件的时候，都需要经历建立 TCP 连接、传输数据和断开连接这样的步骤，无疑会增加大量无谓的开销</p><h4 id="一个服务器只能支持一个域名" tabindex="-1">一个服务器只能支持一个域名 <a class="header-anchor" href="#一个服务器只能支持一个域名" aria-label="Permalink to &quot;一个服务器只能支持一个域名&quot;">​</a></h4><p>在 HTTP/1.0 中，每个域名绑定了一个唯一的 IP 地址，因此一个服务器只能支持一个域名。但是随着虚拟主机技术的发展，需要实现在一台物理主机上绑定多个虚拟主机，每个虚拟主机都有自己的单独的域名，这些单独的域名都公用同一个 IP 地址</p><h4 id="不支持动态生成的内容" tabindex="-1">不支持动态生成的内容 <a class="header-anchor" href="#不支持动态生成的内容" aria-label="Permalink to &quot;不支持动态生成的内容&quot;">​</a></h4><p>在设计 HTTP/1.0 时，需要在响应头中设置完整的数据大小，如Content-Length: 901，这样浏览器就可以根据设置的数据大小来接收数据。不过随着服务器端的技术发展，很多页面的内容都是动态生成的，因此在传输数据之前并不知道最终的数据大小，这就导致了浏览器不知道何时会接收完所有的文件数据</p><h2 id="缝缝补补的-http-1-1" tabindex="-1">缝缝补补的 HTTP/1.1 <a class="header-anchor" href="#缝缝补补的-http-1-1" aria-label="Permalink to &quot;缝缝补补的 HTTP/1.1&quot;">​</a></h2><h3 id="http-1-1特点" tabindex="-1">HTTP/1.1特点 <a class="header-anchor" href="#http-1-1特点" aria-label="Permalink to &quot;HTTP/1.1特点&quot;">​</a></h3><h4 id="支持持久连接" tabindex="-1">支持持久连接 <a class="header-anchor" href="#支持持久连接" aria-label="Permalink to &quot;支持持久连接&quot;">​</a></h4><p>HTTP/1.1 中增加了持久连接的方法，它的特点是在一个 TCP 连接上可以传输多个 HTTP 请求，只要浏览器或者服务器没有明确断开连接，那么该 TCP 连接会一直保持</p><p>持久连接在 HTTP/1.1 中是默认开启的，如果不想要采用持久连接，可以在 HTTP 请求头中加上<code>Connection: close</code>。<strong>目前浏览器中对于同一个域名，默认允许同时建立 6 个 TCP 持久连接</strong>。</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/http/http发展史/持久连接.webp" height="300px"><h4 id="提供虚拟主机的支持" tabindex="-1">提供虚拟主机的支持 <a class="header-anchor" href="#提供虚拟主机的支持" aria-label="Permalink to &quot;提供虚拟主机的支持&quot;">​</a></h4><p>HTTP/1.1 的请求头中增加了 Host 字段，用来表示当前的域名地址，这样服务器就可以根据不同的 Host 值做不同的处理。</p><h4 id="对动态生成的内容提供了完美支持" tabindex="-1">对动态生成的内容提供了完美支持 <a class="header-anchor" href="#对动态生成的内容提供了完美支持" aria-label="Permalink to &quot;对动态生成的内容提供了完美支持&quot;">​</a></h4><p>HTTP/1.1 通过引入 Chunk transfer 机制来解决这个问题，服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。这样就提供了对动态内容的支持。</p><h4 id="客户端-cookie、安全机制" tabindex="-1">客户端 Cookie、安全机制 <a class="header-anchor" href="#客户端-cookie、安全机制" aria-label="Permalink to &quot;客户端 Cookie、安全机制&quot;">​</a></h4><p>HTTP/1.1 还引入了客户端 Cookie 机制和安全机制。</p><h4 id="使用-cdn-的实现域名分片机制" tabindex="-1">使用 CDN 的实现域名分片机制 <a class="header-anchor" href="#使用-cdn-的实现域名分片机制" aria-label="Permalink to &quot;使用 CDN 的实现域名分片机制&quot;">​</a></h4><p>将一个页面的资源利用多个域名下载，提高tcp并发数量</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/http/http发展史/cdn分片.webp" height="300px"><p>在该图中，引入了 CDN，并同时为每个域名维护 6 个连接，这样就大大减轻了整个资源的下载时间。这里我们可以简单计算下：如果使用单个 TCP 的持久连接，下载 100 个资源所花费的时间为 100 * n * RTT；若通过上面的技术，就可以把整个时间缩短为 100 * n * RTT/(6 * CDN 个数)。从这个计算结果来看，我们的页面加载速度变快了不少。</p><h3 id="http-1-1-的缺陷-对带宽的利用率并不理想" tabindex="-1">HTTP/1.1 的缺陷：对带宽的利用率并不理想 <a class="header-anchor" href="#http-1-1-的缺陷-对带宽的利用率并不理想" aria-label="Permalink to &quot;HTTP/1.1 的缺陷：对带宽的利用率并不理想&quot;">​</a></h3><p><strong>带宽是指每秒最大能发送或者接收的字节数。我们把每秒能发送的最大字节数称为上行带宽，每秒能够接收的最大字节数称为下行带宽。</strong></p><p>之所以说 HTTP/1.1 对带宽的利用率不理想，是因为 HTTP/1.1 很难将带宽用满。比如我们常说的 100M 带宽，实际的下载速度能达到 12.5M/S，而采用 HTTP/1.1 时，也许在加载页面资源时最大只能使用到 2.5M/S，很难将 12.5M 全部用满。</p><p>之所以会出现这个问题，主要是由以下三个原因导致的。</p><h4 id="tcp-的慢启动" tabindex="-1">TCP 的慢启动 <a class="header-anchor" href="#tcp-的慢启动" aria-label="Permalink to &quot;TCP 的慢启动&quot;">​</a></h4><p>一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。</p><p>而之所以说慢启动会带来性能问题，是因为页面中常用的一些关键资源文件本来就不大，如 HTML 文件、CSS 文件和 JavaScript 文件，通常这些文件在 TCP 连接建立好之后就要发起请求的，但这个过程是慢启动，所以耗费的时间比正常的时间要多很多，这样就推迟了宝贵的首次渲染页面的时长了。</p><h4 id="同时开启了多条-tcp-连接-那么这些连接会竞争固定的带宽" tabindex="-1">同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽 <a class="header-anchor" href="#同时开启了多条-tcp-连接-那么这些连接会竞争固定的带宽" aria-label="Permalink to &quot;同时开启了多条 TCP 连接，那么这些连接会竞争固定的带宽&quot;">​</a></h4><p>系统同时建立了多条 TCP 连接，当带宽充足时，每条连接发送或者接收速度会慢慢向上增加；而一旦带宽不足时，这些 TCP 连接又会减慢发送或者接收的速度。比如一个页面有 200 个文件，使用了 3 个 CDN，那么加载该网页的时候就需要建立 6 * 3，也就是 18 个 TCP 连接来下载资源；在下载过程中，当发现带宽不足的时候，各个 TCP 连接就需要动态减慢接收数据的速度。</p><p>这样就会出现一个问题，因为有的 TCP 连接下载的是一些关键资源，如 CSS 文件、JavaScript 文件等，而有的 TCP 连接下载的是图片、视频等普通的资源文件，但是多条 TCP 连接之间又不能协商让哪些关键资源优先下载，这样就有可能影响那些关键资源的下载速度了。</p><h4 id="http-1-1-队头阻塞的问题" tabindex="-1">HTTP/1.1 队头阻塞的问题 <a class="header-anchor" href="#http-1-1-队头阻塞的问题" aria-label="Permalink to &quot;HTTP/1.1 队头阻塞的问题&quot;">​</a></h4><p>在 HTTP/1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。这就是著名的队头阻塞的问题。</p><p>HTTP/1.1 中试图通过管线化的技术来解决队头阻塞的问题。HTTP/1.1 中的管线化是指将多个 HTTP 请求整批提交给服务器的技术，虽然可以整批发送请求，不过服务器依然需要根据请求顺序来回复浏览器的请求。</p><p>FireFox、Chrome 都做过管线化的试验，但是由于各种原因，它们最终都放弃了管线化技术。</p>',55),i=[r];function o(l,p,P,n,s,c){return e(),t("div",null,i)}const u=a(T,[["render",o]]);export{H as __pageData,u as default};
