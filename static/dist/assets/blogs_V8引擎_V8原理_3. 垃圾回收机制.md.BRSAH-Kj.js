import{_ as a,c as s,o as i,a4 as e}from"./chunks/framework.BOW58p_D.js";const m=JSON.parse('{"title":"垃圾回收机制（GC）","description":"","frontmatter":{},"headers":[],"relativePath":"blogs/V8引擎/V8原理/3. 垃圾回收机制.md","filePath":"blogs/V8引擎/V8原理/3. 垃圾回收机制.md"}'),t={name:"blogs/V8引擎/V8原理/3. 垃圾回收机制.md"},l=e(`<h1 id="垃圾回收机制-gc" tabindex="-1">垃圾回收机制（GC） <a class="header-anchor" href="#垃圾回收机制-gc" aria-label="Permalink to &quot;垃圾回收机制（GC）&quot;">​</a></h1><h2 id="垃圾回收机制-gc-是什么" tabindex="-1">垃圾回收机制（GC）是什么 <a class="header-anchor" href="#垃圾回收机制-gc-是什么" aria-label="Permalink to &quot;垃圾回收机制（GC）是什么&quot;">​</a></h2><p>GC 即 Garbage Collection ，程序工作过程中会产生很多“垃圾”，这些“垃圾”是程序不用的内存或者是之前用过了，以后不会再用的内存空间，而 GC 就是负责回收垃圾的，因为他工作在引擎内部，所以对于我们前端来说，GC 过程是相对比较无感的。</p><p>当然也不是所有语言都有 GC，一般的高级语言里面会自带 GC，比如 Java、Python、JavaScript 等，也有无 GC 的语言，比如 C、C++ 等，那这种就需要我们程序员手动管理内存了，相对比较麻烦。</p><p>JavaScript 中所有变量存储在栈和堆两种内存空间中，所以接下来就来分别介绍栈中的垃圾回收和堆中的垃圾回收。</p><h2 id="栈中的垃圾回收" tabindex="-1">栈中的垃圾回收 <a class="header-anchor" href="#栈中的垃圾回收" aria-label="Permalink to &quot;栈中的垃圾回收&quot;">​</a></h2><p>在函数执行过程中，函数的执行上下文会压入到调用栈中，并且会有一个<strong>记录当前执行状态的指针（称为 ESP）</strong>，指向调用栈中正在执行的函数的执行上下文。</p><p>当一个函数执行结束之后，V8 引擎会向下移动 ESP，让 ESP 指向调用栈中父级函数的执行上下文，此时该函数保存在栈中的执行上下文已经是无效内存了。当父级函数内再次调用另一个函数时，当前函数的执行上下文就会被覆盖掉。</p><p>通过一段示例代码的执行流程来分析其回收机制，具体如下：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {name:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;极客邦&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> showName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> c </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> d </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {name:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;极客时间&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    showName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>当执行到<code>var d = {name:&quot;极客时间&quot;}</code>时，其调用栈和堆空间状态图如下所示：</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/栈垃圾回收示例1.jpg" height="400px"><p>此时 ESP 指向<code>showName</code>函数的执行上下文，当<code>showName</code>函数执行完成后，ESP 向下移动，指向<code>foo</code>函数的执行上下文</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/栈垃圾回收示例2.jpg" height="400px"><p>上面<code>showName</code>的执行上下文虽然保存在栈内存中，但是已经是无效内存了。比如当<code>foo</code>函数再次调用另外一个函数时，这块内容会被直接覆盖掉，用来存放另外一个函数的执行上下文。</p><h2 id="堆中的垃圾回收" tabindex="-1">堆中的垃圾回收 <a class="header-anchor" href="#堆中的垃圾回收" aria-label="Permalink to &quot;堆中的垃圾回收&quot;">​</a></h2><p>当上面那段代码的<code>foo</code>函数执行结束之后，ESP 应该是指向全局执行上下文的，那这样的话，<code>showName</code>函数和<code>foo</code>函数的执行上下文就处于无效状态了，不过保存在堆中的两个对象依然占用着空间，如下图所示：</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/堆中的垃圾回收示例1.webp" height="300px"><p>从图中可以看出，1003 和 1050 这两块内存依然被占用。要回收堆中的垃圾数据，就需要用到 JavaScript 中的垃圾回收器了。</p><h3 id="活动对象和非活动对象" tabindex="-1">活动对象和非活动对象 <a class="header-anchor" href="#活动对象和非活动对象" aria-label="Permalink to &quot;活动对象和非活动对象&quot;">​</a></h3><p>对象区域中的元素分为活动对象和非活动对象。</p><ul><li>通过 GC Root 遍历到的对象，我们就认为该对象是<strong>可访问的（reachable）</strong>，那么必须保证这些对象应该在内存中保留，我们也称可访问的对象为活动对象。</li><li>通过 GC Root 没有遍历到的对象，则是<strong>不可访问的（unreachable）</strong>，那么这些不可访问的对象就可能被回收，我们称不可访问的对象为非活动对象。</li></ul><h4 id="gc-root" tabindex="-1">GC Root <a class="header-anchor" href="#gc-root" aria-label="Permalink to &quot;GC Root&quot;">​</a></h4><p>在浏览器环境中，GC Root 有很多，通常包括了以下几种 (但是不止于这几种)：</p><ul><li>全局的 window 对象（位于每个 iframe 中）。</li><li>文档 DOM 树，由可以通过遍历文档到达的所有原生 DOM 节点组成。</li><li>存放在栈上的变量。</li></ul><h3 id="代际假说" tabindex="-1">代际假说 <a class="header-anchor" href="#代际假说" aria-label="Permalink to &quot;代际假说&quot;">​</a></h3><p>代际假说（The Generational Hypothesis）的内容是垃圾回收领域中一个重要的术语，后续垃圾回收的策略都是建立在该假说的基础之上的。</p><p>代际假说有以下两个特点：</p><ul><li>第一个是大部分对象在内存中存活的时间很短。比如函数内部声明的变量，或者块级作用域中的变量，当函数或者代码块执行结束时，作用域中定义的变量就会被销毁。因此这一类对象一经分配内存，很快就变得不可访问。</li><li>第二个是不死的对象会活得更久。比如全局的 window、DOM、Web API 等对象。</li></ul><p>V8 的垃圾回收策略就是建立在该假说的基础之上的。所以，在 V8 中会把堆分为新生代和老生代两个区域：</p><ul><li>新生代中存放的是生存时间短或内存占用较小的对象。</li><li>老生代中存放的生存时间久或内存占用较大的对象。</li></ul><p>新生代通常只支持 1～8M 的容量，而老生代支持的容量就大很多了。对于这两块区域，V8 分别使用两个不同的垃圾回收器，以便更高效地实施垃圾回收。</p><ul><li>副垃圾回收器 -Minor GC (Scavenger)，主要负责新生代的垃圾回收。</li><li>主垃圾回收器 -Major GC，主要负责老生代的垃圾回收。</li></ul><h3 id="副垃圾回收器" tabindex="-1">副垃圾回收器 <a class="header-anchor" href="#副垃圾回收器" aria-label="Permalink to &quot;副垃圾回收器&quot;">​</a></h3><p>新生代中的垃圾数据用 <strong>Scavenge 算法</strong>来处理。垃圾回收比较频繁的。</p><h4 id="scavenge-算法" tabindex="-1">Scavenge 算法 <a class="header-anchor" href="#scavenge-算法" aria-label="Permalink to &quot;Scavenge 算法&quot;">​</a></h4><p>所谓 Scavenge 算法，是把新生代空间对半划分为两个区域，一半是对象区域 (from-space)，一半是空闲区域 (to-space)，如下图所示：</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/新生区和老生区.webp" height="300px"><p>新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</p><p>在垃圾回收过程中，首先标记出对象区域内的非活动对象；标记完成之后，就进入垃圾清理阶段。副垃圾回收器会把这些存活的对象复制到空闲区域中，同时它还会把这些对象有序地排列起来，所以这个复制过程，也就相当于完成了内存整理操作，复制后空闲区域就没有内存碎片了。</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/Scavenge算法1.webp" height="300px"><p>复制过程中由于数据的地址发生了改变，所以还需要同步更新引用这些对象的指针。</p><p>完成复制后，对象区域与空闲区域进行角色翻转，也就是原来的对象区域变成空闲区域，原来的空闲区域变成了对象区域。这样就完成了垃圾对象的回收操作，<strong>同时，这种角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。</strong></p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/Scavenge算法2.webp" height="300px"><h4 id="为什么新生代空间比较小" tabindex="-1">为什么新生代空间比较小？ <a class="header-anchor" href="#为什么新生代空间比较小" aria-label="Permalink to &quot;为什么新生代空间比较小？&quot;">​</a></h4><p>副垃圾回收器每次执行清理操作时，都需要将存活的对象从对象区域复制到空闲区域，复制操作需要时间成本，如果新生代空间设置得太大了，那么每次清理的时间就会过久，所以为了执行效率，一般新生代的空间会被设置得比较小，通常只支持 1～8M 的容量。</p><h4 id="对象晋升策略" tabindex="-1">对象晋升策略 <a class="header-anchor" href="#对象晋升策略" aria-label="Permalink to &quot;对象晋升策略&quot;">​</a></h4><p>因为新生代的空间不大，所以很容易被存活的对象装满整个区域，所以为了避免新生代频繁触发垃圾回收，V8增加了对象晋升策略。</p><p><strong>也就是移动那些经过两次垃圾回收依然还存活的对象到老生代中。</strong></p><h3 id="主垃圾回收器" tabindex="-1">主垃圾回收器 <a class="header-anchor" href="#主垃圾回收器" aria-label="Permalink to &quot;主垃圾回收器&quot;">​</a></h3><p>老生代中的对象有两个特点：</p><ul><li>一个是对象占用空间大。</li><li>另一个是对象存活时间长。</li></ul><p>主垃圾回收器触发条件：</p><ul><li><strong>当达到 N 字节后会触发回收。</strong> 初次达到 N 字节进行回收后，会对回收率做判断： <ul><li>如果回收率高，具体数字记得是 85%，说明活动对象少，那么下次增大这个 N，从而降低回收频率。</li><li>如果是小于 15%，说明活动对象多，那么下次降低这个 N，从而提高回收频率。</li></ul></li><li><strong>当前标签页处于非活动状态的时候，主副垃圾回收器都会执行</strong>。</li></ul><p>主垃圾回收器是采用<strong>标记 - 清除（Mark-Sweep）算法</strong>进行垃圾回收的。</p><h4 id="标记-清除-mark-sweep-算法" tabindex="-1">标记 - 清除（Mark-Sweep）算法 <a class="header-anchor" href="#标记-清除-mark-sweep-算法" aria-label="Permalink to &quot;标记 - 清除（Mark-Sweep）算法&quot;">​</a></h4><p><strong>首先是标记过程阶段。</strong> 标记阶段使用三色（白灰黑）标记法。从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。</p><p><strong>接下来就是垃圾的清除过程。</strong> 它和副垃圾回收器的垃圾清除过程完全不同，主垃圾回收器会直接将标记为垃圾的数据清理掉。</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/标记清除.webp" height="300px"><p>当对一块内存多次执行标记 - 清除算法后，会产生大量不连续的内存碎片。而碎片过多会导致大对象无法分配到足够的连续内存，于是又引入了另外一种算法——<strong>标记 - 整理（Mark-Compact）</strong>。</p><p>标记 - 整理（Mark-Compact）算法就是将所有活动对象向内存的一端移动，最后清理掉边界的内存。</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/标记整理.webp" height="300px"><p><strong>先标记 - 清除算法，后标记 - 整理算法，但并不是所有时候都需要做内存整理。</strong></p><h2 id="全停顿-stop-the-world" tabindex="-1">全停顿（Stop-The-World） <a class="header-anchor" href="#全停顿-stop-the-world" aria-label="Permalink to &quot;全停顿（Stop-The-World）&quot;">​</a></h2><p>由于 JavaScript 是运行在主线程之上的，因此，一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。</p><p>比如，页面正在执行一个 JavaScript 动画，因为垃圾回收器在工作，就会导致这个动画在一段时间内无法执行，造成页面的卡顿 (Jank)，用户体验不佳。</p><p>为了解决全停顿而造成的用户体验的问题，V8 团队向现有的垃圾回收器添加<strong>并行</strong>、<strong>并发</strong>和<strong>增量</strong>等垃圾回收技术，这些技术主要是从两方面来解决垃圾回收效率问题的：</p><ul><li><strong>第一，任务拆解。</strong> 将一个完整的垃圾回收的任务拆分成多个小的任务，这样就消灭了单个长的垃圾回收任务。</li><li><strong>第二，多线程。</strong> 将标记对象、移动对象等任务转移到后台线程进行，这会大大减少主线程暂停的时间，改善页面卡顿的问题，让动画、滚动和用户交互更加流畅。</li></ul><h3 id="副垃圾回收器中优化全停顿" tabindex="-1">副垃圾回收器中优化全停顿 <a class="header-anchor" href="#副垃圾回收器中优化全停顿" aria-label="Permalink to &quot;副垃圾回收器中优化全停顿&quot;">​</a></h3><p>V8 的副垃圾回收器所采用的就是并行策略，它在执行垃圾回收的过程中，启动了多个线程来负责新生代中的垃圾清理操作，这些线程同时将对象空间中的数据移动到空闲区域。</p><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/副垃圾回收优化.webp" width="500px"><h3 id="主垃圾回收器中优化全停顿" tabindex="-1">主垃圾回收器中优化全停顿 <a class="header-anchor" href="#主垃圾回收器中优化全停顿" aria-label="Permalink to &quot;主垃圾回收器中优化全停顿&quot;">​</a></h3><img src="https://gitee.com/CwdyBic/myBlog/raw/master/assets/V8引擎/主垃圾回收优化.webp" width="500px"><p>可以看出来，主垃圾回收器同时采用了这三种策略：</p><ul><li>首先主垃圾回收器主要使用并发标记。在主线程执行 JavaScript 时，辅助线程就开始执行标记操作了，所以说标记是在辅助线程中完成的。</li><li>标记完成之后，再执行并行清理操作。主线程在执行清理操作时，多个辅助线程也在执行清理操作。</li><li>另外，主垃圾回收器还采用了增量式垃圾回收，清理的任务会穿插在各种 JavaScript 任务之间执行。</li></ul>`,75),r=[l];function p(n,o,h,c,d,g){return i(),s("div",null,r)}const u=a(t,[["render",p]]);export{m as __pageData,u as default};
